category: Analytics & SIEM
commonfields:
  id: Devo_v2
  version: -1
configuration:
- defaultvalue: https://apiv2-us.devo.com/search/query
  display: Query Server Endpoint (e.g. https://apiv2-us.devo.com/search/query)
  name: reader_endpoint
  required: true
  type: 0
- defaultvalue: ""
  display: OAuth Token (Preferred method)
  name: reader_oauth_token
  required: true
  type: 4
- defaultvalue: ""
  display: Writer relay to connect to (e.g. us.elb.relay.logtrust.net)
  name: writer_relay
  required: false
  type: 0
- defaultvalue: ""
  display: Writer JSON credentials
  name: writer_credentials
  required: false
  type: 4
- defaultvalue: https://us.devo.com/welcome
  display: Devo base domain
  name: linq_link_base
  required: false
  type: 0
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: ""
  display: Fetch incidents alert filter (Same filters for get-alerts)
  name: fetch_incidents_filters
  required: false
  type: 12
- defaultvalue: ""
  display: Deduplication parameters JSON if required
  name: fetch_incidents_deduplication
  required: false
  type: 12
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Use the Devo v2 integration to query Devo for alerts, lookup tables,
  and to write to lookup tables.
detaileddescription: |
  ## Configure API Credentials
  To configure an instance of the integration in Demisto, you will need to provide a Devo apiv2 OAuth token with `*.**`
  permissions for the time being if you want the fetch incidents to work correctly. Otherwise only grant access to particular
  tables but `siem.logtrust.alert.info` is used when fetching alerts.

  If writing back to Devo make sure to also create a set of TLS credentials.

  ### Get your Demisto OAuth Token
  1. Login to your Devo domain with a user with the ability to create security credentials.
  2. Navigate to __Administration__ > __Credentials__ > __Authentication Tokens__.
  3. If a token for Demisto has not already been  created, Click __CREATE NEW TOKEN__
    * Create the Token with `*.**` table permissions as an `apiv2` token.
  4. Note the generated `Token`

  ### Get your Demisto Writer Credentials
  1. Login to your Devo domain with a user with the ability to create security credentials.
  2. Navigate to __Administration__ > __Credentials__ > __X.509 Certificates__.
  3. Click `NEW CERTIFICATE` if you do not already have a set of keys for Demisto.
  4. Download the following files:
    * `Certificate`
    * `Private Key`
    * `CHAIN CA`

  ## Setting Up an Instance
  1. Name
    - Identifiable name of the instance you wish to create
  2. Query Server Endpoint
    - APIv2 Devo query endpoint. Additional information found here: [Devo API Ref](https://docs.devo.com/confluence/ndt/api-reference/rest-api)
  3. Oauth Token
    - APIv2 Oauth token with `*.**` table query access permissions
  4. Writer relay to connect to
    - In Devo: Navigate to __Administration__ > __Relays__
    - Look for the relay named `central` with type `Secure`.
    - Use the `Address` for that given relay, we assume port __443__ so please omit, e.g. `us.elb.relay.logtrust.net`
  5. Writer JSON Credentials
    - From the Writer Credentials that were downloaded please format them into JSON as follows:
    ```
    {
      "key": "contents of key file formatted as a single line string",
      "crt": "contents of certificate file formatted as a single line string",
      "chain": "contents of chain file formatted as a single line string"
    }
    ```
  6. Devo base domain
    - This is the base web UI URL that you use to interact with Devo. If you login to `us.devo.com` -> `https://us.devo.com/welcome`
  7. Fetches incidents
    - Check this box if you would like for the plugin to pull in Devo alerts as incidents. Please refer to `Fetch incident alert filter` and
      `Deduplication parameters JSON` for advanced configuration
  8. Incident type
    - Demisto incident type to create all incidents as.
  9. Fetch incidents alert filter
    - If you would like a subset of your alerts to only show up in Demisto please use this filtering.
    ```
    {
        "type": <"AND" | "OR">,
        "filters" : [
          {"key": <String Devo Column Name>, "operator": <Devo Linq Operator>, "value": <string>},
          {"key": <String Devo Column Name>, "operator": <Devo Linq Operator>, "value": <string>},
          ...
          {"key": <String Devo Column Name>, "operator": <Devo Linq Operator>, "value": <string>}
        ]
    }
    ```
    - Currently supports the following operators: `=`, `/=`, `>`, `<`, `>=`, `<=`, `->`, `and`, `or`, '->'
    - Please refer to [LINQ Operations Ref](https://docs.devo.com/confluence/ndt/searching-data/building-a-query/operations-reference)
  10. Deduplication parameters JSON (BETA)
    - If you have some alerts that you only want to run 1 playbook on for a given time period with a cooldown please use this.
    ```
    {
        "cooldown": <int seconds cooldown for each type of alert>
    }
    ```
    - Uses the `context` column to group all alerts so all alerts that get processed by this will share the same cooldown.
    - This is a Beta feature so please use with caution as we will make usability enhancements.
  11. Use system proxy settings
    - Uses the proxy on the system.
display: Devo_v2
image: data:image/png;base64,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
name: Devo_v2
script:
  commands:
  - arguments:
    - description: A LINQ query to run in Devo.
      name: query
      required: true
    - description: Start datetime for the specified query. This argument supports
        natural language (e.g., 2 day, 3 week), Unix timestamps, Python datetime objects,
        and string datetimes.
      name: from
      required: true
    - description: End datetime for specified query. If provided must be in same format
        as "from" argument. This argument is ignored in a date range.
      name: to
    - defaultValue: "true"
      description: Whether to write results to context. Can be "true" or "false".
        The default value is "true".
      name: writeToContext
    description: Queries Devo based on the specified LINQ query.
    name: devo-run-query
    outputs:
    - contextPath: Devo.QueryResults
      description: List of dictionary alerts from the specified time range.
      type: unknown
    - contextPath: Devo.QueryLink
      description: The link to the Devo table for executed query.
  - arguments:
    - description: Start datetime for alerts to fetch.
      name: from
      required: true
    - description: End datetime for alerts to fetch.
      name: to
    - description: Key value filter to apply to retrieve the specified alerts. For
        more information, see the Devo documentation.
      isArray: true
      name: filters
    - defaultValue: "true"
      description: Whether to write results to context. Can be "true" or "false".
        The default value is "true".
      name: writeToContext
    description: Queries alerts in the specified timeframe.
    name: devo-get-alerts
    outputs:
    - contextPath: Devo.AlertsResults
      description: List of dictionary alerts from the specified time range.
    - contextPath: Devo.QueryLink
      description: The link to the Devo table for the executed query.
  - arguments:
    - description: A list of table names to check for the searchToken.
      isArray: true
      name: tables
      required: true
    - description: A string to search for in the specified tables (in any column).
      name: searchToken
      required: true
    - description: Start datetime for the specified query. This argument supports
        natural language (e.g., 2 day, 3 week), Unix timestamps, Python datetime objects,
        and string datetimes
      name: from
      required: true
    - description: End datetime for specified query. If provided must be in same format
        as "from" argument. This argument is ignored in a date range.
      name: to
    - defaultValue: "true"
      description: Whether to write results to context. Can be "true" or "false".
        The default value is "true".
      name: writeToContext
    description: Queries multiple tables for a given token and returns relevant results.
    name: devo-multi-table-query
    outputs:
    - contextPath: Devo.MultiResults
      description: A list of dictionary results.
  - arguments:
    - description: The name of the table to write to.
      name: tableName
      required: true
    - description: Records to write to the specified table.
      isArray: true
      name: records
      required: true
    description: Writes records to a specified Devo table.
    execution: true
    name: devo-write-to-table
    outputs:
    - contextPath: Devo.RecordsWritten
      description: Records written to specified Devo table.
      type: unknown
    - contextPath: Devo.LinqQuery
      description: The LINQ query to use to see your data in Devo.
    - contextPath: Devo.QueryLink
      description: The link to the Devo table for the executed query.
  - arguments:
    - description: The lookup table name to write to.
      name: lookupTableName
      required: true
    - description: Headers for lookup table control.
      isArray: true
      name: headers
      required: true
    - description: Records to write to the specified table.
      isArray: true
      name: records
      required: true
    description: Writes lookup table entry records to a specified Devo table.
    execution: true
    name: devo-write-to-lookup-table
    outputs:
    - contextPath: Devo.RecordsWritten
      description: Lookup records written to the lookup table.
      type: unknown
  dockerimage: demisto/devo:1.0.0.1978
  isfetch: true
  runonce: false
  script: |2


    ''' IMPORTS '''
    import base64
    import json
    import time
    import devodsconnector as ds
    import concurrent.futures
    import tempfile
    import urllib.parse
    import re
    import os
    from datetime import datetime
    from devo.sender import Lookup, SenderConfigSSL, Sender
    from typing import List, Dict, Set

    ''' GLOBAL VARS '''
    ALLOW_INSECURE = demisto.params().get('insecure', False)
    READER_ENDPOINT = demisto.params().get('reader_endpoint', None)
    READER_OAUTH_TOKEN = demisto.params().get('reader_oauth_token', None)
    WRITER_RELAY = demisto.params().get('writer_relay', None)
    WRITER_CREDENTIALS = demisto.params().get('writer_credentials', None)
    LINQ_LINK_BASE = demisto.params().get('linq_link_base', "https://us.devo.com/welcome")
    FETCH_INCIDENTS_FILTER = demisto.params().get('fetch_incidents_filters', None)
    FETCH_INCIDENTS_DEDUPE = demisto.params().get('fetch_incidents_deduplication', None)
    HEALTHCHECK_WRITER_RECORD = [{'hello': 'world', 'from': 'demisto-integration'}]
    HEALTHCHECK_WRITER_TABLE = 'test.keep.free'
    RANGE_PATTERN = re.compile('^[0-9]+ [a-zA-Z]+')
    TIMESTAMP_PATTERN = re.compile('^[0-9]+')
    TIMESTAMP_PATTERN_MILLI = re.compile('^[0-9]+.[0-9]+')
    ALERTS_QUERY = '''
    from
        siem.logtrust.alert.info
    select
        eventdate,
        alertHost,
        domain,
        priority,
        context,
        category,
        status,
        alertId,
        srcIp,
        srcPort,
        srcHost,
        dstIp,
        dstPort,
        dstHost,
        application,
        engine,
        extraData
    '''
    HEALTHCHECK_QUERY = '''
    from
        test.keep.free
    select
        *
    '''
    SEVERITY_LEVELS_MAP = {
        '1': 0.5,
        '2': 1,
        '3': 2,
        '4': 3,
        '5': 4,
        'informational': 0.5,
        'low': 1,
        'medium': 2,
        'high': 3,
        'critical': 4
    }


    ''' HELPER FUNCTIONS '''


    def alert_to_incident(alert):
        alert_severity = float(1)
        alert_name = alert['context'].split('.')[-1]
        alert_description = None
        alert_occurred = demisto_ISO(float(alert['eventdate']))
        alert_labels = []

        if demisto.get(alert['extraData'], 'alertPriority'):
            alert_severity = SEVERITY_LEVELS_MAP[str(alert['extraData']['alertPriority']).lower()]

        if demisto.get(alert['extraData'], 'alertName'):
            alert_name = alert['extraData']['alertName']

        if demisto.get(alert['extraData'], 'alertDescription'):
            alert_description = alert['extraData']['alertDescription']

        new_alert: Dict = {
            'devo.metadata.alert': {}
        }
        for key in alert:
            if key == 'extraData':
                continue
            new_alert['devo.metadata.alert'][key] = alert[key]
            alert_labels.append({'type': f'devo.metadata.alert.{key}', 'value': str(alert[key])})

        for key in alert['extraData']:
            new_alert[key] = alert['extraData'][key]
            alert_labels.append({'type': f'{key}', 'value': str(alert['extraData'][key])})

        incident = {
            'name': alert_name,
            'severity': alert_severity,
            'details': alert_description,
            'occurred': alert_occurred,
            'labels': alert_labels,
            'rawJSON': json.dumps(new_alert)
        }

        return incident


    def build_link(query, start_ts_milli, end_ts_milli, mode='queryApp'):
        myb64str = base64.b64encode((json.dumps({
            'query': query,
            'mode': mode,
            'dates': {
                'from': start_ts_milli,
                'to': end_ts_milli
            }
        }).encode('ascii'))).decode()
        url = LINQ_LINK_BASE + f"#/verticalApp?path=apps/custom/queryApp_dev&targetQuery={myb64str}"
        return url


    def check_configuration():
        # Check all settings related if set
        # Basic functionality of integration
        list(ds.Reader(oauth_token=READER_OAUTH_TOKEN, end_point=READER_ENDPOINT)
             .query(HEALTHCHECK_QUERY, start=int(time.time() - 1), stop=int(time.time()), output='dict'))

        if WRITER_RELAY and WRITER_CREDENTIALS:
            creds = get_writer_creds()
            ds.Writer(key=creds['key'].name, crt=creds['crt'].name, chain=creds['chain'].name, relay=WRITER_RELAY)\
                .load(HEALTHCHECK_WRITER_RECORD, HEALTHCHECK_WRITER_TABLE, historical=False)

        if FETCH_INCIDENTS_FILTER:
            alert_filters = check_type(FETCH_INCIDENTS_FILTER, dict)

            assert alert_filters['type'] in ['AND', 'OR'], 'Missing key:"type" or unsupported value in fetch_incidents_filters'

            filters = check_type(alert_filters['filters'], list)

            for filt in filters:
                assert filt['key'], 'Missing key: "key" in fetch_incidents_filters.filters configuration'
                assert filt['operator'] in ['=', '/=', '>', '<', '>=', '<=', 'and', 'or', '->'], 'Missing key: "operator"'\
                    ' or unsupported operator in fetch_incidents_filters.filters configuration'
                assert filt['value'], 'Missing key:"value" in fetch_incidents_filters.filters configuration'

        if FETCH_INCIDENTS_DEDUPE:
            dedupe_conf = check_type(FETCH_INCIDENTS_DEDUPE, dict)

            assert isinstance(dedupe_conf['cooldown'], (int, float)), 'Invalid fetch_incidents_deduplication configuration'

        return True


    def check_type(input, tar_type):
        if isinstance(input, str):
            input = json.loads(input)
            if not isinstance(input, tar_type):
                raise ValueError(f'tables to query should either be a json string of a {tar_type} or a {tar_type} input')
        elif isinstance(input, tar_type):
            pass
        else:
            raise ValueError(f'tables to query should either be a json string of a {tar_type} or a {tar_type} input')
        return input


    # Converts epoch (miliseconds) to ISO string
    def demisto_ISO(s_epoch):
        if s_epoch >= 0:
            return datetime.utcfromtimestamp(s_epoch).strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        return s_epoch


    # We will assume timestamp_from and timestamp_to will be the same format or to will be None
    def get_time_range(timestamp_from, timestamp_to):
        if isinstance(timestamp_from, (int, float)):
            t_from = timestamp_from
            if timestamp_to is None:
                t_to = time.time()
            else:
                t_to = timestamp_to
        elif isinstance(timestamp_from, str):
            if re.fullmatch(RANGE_PATTERN, timestamp_from):
                t_range = parse_date_range(timestamp_from)
                t_from = t_range[0].timestamp()
                t_to = t_range[1].timestamp()
            elif re.fullmatch(TIMESTAMP_PATTERN, timestamp_from) or re.fullmatch(TIMESTAMP_PATTERN_MILLI, timestamp_from):
                t_from = float(timestamp_from)
                if timestamp_to is None:
                    t_to = time.time()
                else:
                    t_to = float(timestamp_to)
            else:
                t_from = date_to_timestamp(timestamp_from) / 1000
                if timestamp_to is None:
                    t_to = time.time()
                else:
                    t_to = date_to_timestamp(timestamp_to) / 1000
        elif isinstance(timestamp_from, datetime):
            t_from = timestamp_from.timestamp()
            if timestamp_to is None:
                t_to = time.time()
            else:
                t_to = timestamp_to.timestamp()

        return (t_from, t_to)


    def get_writer_creds():
        if WRITER_RELAY is None:
            raise ValueError('writer_relay is not set in your Devo Integration')

        if WRITER_CREDENTIALS is None:
            raise ValueError('writer_credentials are not set in your Devo Integration')

        write_credentials = check_type(WRITER_CREDENTIALS, dict)
        assert write_credentials['key'], 'Required key: "key" is not present in writer credentials'
        assert write_credentials['crt'], 'Required key: "crt" is not present in writer credentials'
        assert write_credentials['chain'], 'Required key: "chain" is not present in writer credentials'

        # Limitation in Devo DS Connector SDK. Currently require filepaths for credentials.
        # Will accept file-handler type objects in the future.
        key_tmp = tempfile.NamedTemporaryFile(mode='w')
        crt_tmp = tempfile.NamedTemporaryFile(mode='w')
        chain_tmp = tempfile.NamedTemporaryFile(mode='w')

        key_tmp.write(write_credentials['key'])
        crt_tmp.write(write_credentials['crt'])
        chain_tmp.write(write_credentials['chain'])

        key_tmp.flush()
        crt_tmp.flush()
        chain_tmp.flush()

        creds = {
            'key': key_tmp,
            'crt': crt_tmp,
            'chain': chain_tmp
        }

        return creds


    def parallel_query_helper(sub_query, append_list, timestamp_from, timestamp_to):
        append_list.extend(list(ds.Reader(oauth_token=READER_OAUTH_TOKEN, end_point=READER_ENDPOINT)
                           .query(sub_query, start=float(timestamp_from), stop=float(timestamp_to),
                           output='dict', ts_format='iso')))


    ''' FUNCTIONS '''


    def fetch_incidents():
        last_run = demisto.getLastRun()
        alert_query = ALERTS_QUERY
        to_time = time.time()
        dedupe_config = None
        alerts_list: Dict = {}
        new_last_run: Dict = {
            'from_time': to_time
        }

        if FETCH_INCIDENTS_FILTER:
            alert_filters = check_type(FETCH_INCIDENTS_FILTER, dict)

            if alert_filters['type'] == 'AND':
                filter_string = ' , '.join([f'{filt["key"]} {filt["operator"]} "{urllib.parse.quote(filt["value"])}"'
                                           for filt in alert_filters['filters']])
            elif alert_filters['type'] == 'OR':
                filter_string = ' or '.join([f'{filt["key"]} {filt["operator"]} "{urllib.parse.quote(filt["value"])}"'
                                            for filt in alert_filters['filters']])

            alert_query = f'{alert_query} where {filter_string}'

        from_time = to_time - 3600
        if 'from_time' in last_run:
            from_time = float(last_run['from_time'])

        if FETCH_INCIDENTS_DEDUPE:
            dedupe_config = check_type(FETCH_INCIDENTS_DEDUPE, dict)
            if 'alerts_list' in last_run:
                alerts_list = last_run['alerts_list']
            alerts_list = {k: v for k, v in alerts_list.items() if alerts_list[k] >= (to_time - float(dedupe_config['cooldown']))}

        # execute the query and get the events
        # reverse the list so that the most recent event timestamp event is taken when de-duping if needed.
        events = list(ds.Reader(oauth_token=READER_OAUTH_TOKEN, end_point=READER_ENDPOINT)
                        .query(alert_query, start=float(from_time), stop=float(to_time),
                               output='dict', ts_format='timestamp'))[::-1]

        deduped_events: List[Dict] = []
        if FETCH_INCIDENTS_DEDUPE:
            # Expire out of rolling time window events
            for event in events:
                if any(de['context'] == event['context'] for de in deduped_events):
                    continue
                if event['context'] in alerts_list:
                    continue
                deduped_events.append(event)
                alerts_list[event['context']] = event['eventdate']

            events = deduped_events
            new_last_run['alerts_list'] = alerts_list

        # convert the events to demisto incident
        incidents = []

        for event in events:
            event['extraData'] = json.loads(event['extraData'])
            for ed in event['extraData']:
                event['extraData'][ed] = urllib.parse.unquote_plus(event['extraData'][ed])
            inc = alert_to_incident(event)
            incidents.append(inc)

        demisto.setLastRun(new_last_run)

        # this command will create incidents in Demisto
        demisto.incidents(incidents)

        return incidents


    def run_query_command():
        to_query = demisto.args()['query']
        timestamp_from = demisto.args()['from']
        timestamp_to = demisto.args().get('to', None)
        write_context = demisto.args()['writeToContext'].lower()

        time_range = get_time_range(timestamp_from, timestamp_to)

        results = list(ds.Reader(oauth_token=READER_OAUTH_TOKEN, end_point=READER_ENDPOINT)
                       .query(to_query, start=float(time_range[0]), stop=float(time_range[1]),
                       output='dict', ts_format='iso'))

        querylink = {'DevoTableLink': build_link(to_query, int(1000 * float(time_range[0])), int(1000 * float(time_range[1])))}

        entry = {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown']
        }
        entry_linq = {
            'Type': entryTypes['note'],
            'Contents': querylink,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown']
        }

        if len(results) == 0:
            entry['HumanReadable'] = 'No results found'
            entry['Devo.QueryResults'] = None
            entry['Devo.QueryLink'] = querylink
            return entry
        headers = list(results[0].keys())

        md = tableToMarkdown('Devo query results', results, headers)
        entry['HumanReadable'] = md

        md_linq = tableToMarkdown('Link to Devo Query', {'DevoTableLink': f'[Devo Direct Link]({querylink["DevoTableLink"]})'})
        entry_linq['HumanReadable'] = md_linq

        if write_context == 'true':
            entry['EntryContext'] = {
                'Devo.QueryResults': createContext(results)
            }
            entry_linq['EntryContext'] = {
                'Devo.QueryLink': createContext(querylink)
            }
        return [entry, entry_linq]


    def get_alerts_command():
        timestamp_from = demisto.args()['from']
        timestamp_to = demisto.args().get('to', None)
        alert_filters = demisto.args().get('filters', None)
        write_context = demisto.args()['writeToContext'].lower()
        alert_query = ALERTS_QUERY

        time_range = get_time_range(timestamp_from, timestamp_to)

        if alert_filters:
            alert_filters = check_type(alert_filters, dict)
            if alert_filters['type'] == 'AND':
                filter_string = ', '\
                    .join([f'{filt["key"]} {filt["operator"]} "{urllib.parse.quote(filt["value"])}"'
                          for filt in alert_filters['filters']])
            elif alert_filters['type'] == 'OR':
                filter_string = ' or '\
                    .join([f'{filt["key"]} {filt["operator"]} "{urllib.parse.quote(filt["value"])}"'
                          for filt in alert_filters['filters']])
            alert_query = f'{alert_query} where {filter_string}'

        results = list(ds.Reader(oauth_token=READER_OAUTH_TOKEN, end_point=READER_ENDPOINT)
                       .query(alert_query, start=float(time_range[0]), stop=float(time_range[1]),
                       output='dict', ts_format='iso'))

        querylink = {'DevoTableLink': build_link(alert_query, int(1000 * float(time_range[0])), int(1000 * float(time_range[1])))}

        for res in results:
            res['extraData'] = json.loads(res['extraData'])
            for ed in res['extraData']:
                res['extraData'][ed] = urllib.parse.unquote_plus(res['extraData'][ed])

        entry = {
            'Type': entryTypes['note'],
            'Contents': results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown']
        }
        entry_linq = {
            'Type': entryTypes['note'],
            'Contents': querylink,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown']
        }

        if len(results) == 0:
            entry['HumanReadable'] = 'No results found'
            entry['Devo.AlertsResults'] = None
            entry_linq['Devo.QueryLink'] = querylink
            return entry

        headers = list(results[0].keys())

        md = tableToMarkdown('Devo query results', results, headers)
        entry['HumanReadable'] = md

        md_linq = tableToMarkdown('Link to Devo Query', {'DevoTableLink': f'[Devo Direct Link]({querylink["DevoTableLink"]})'})
        entry_linq['HumanReadable'] = md_linq

        if write_context == 'true':
            entry['EntryContext'] = {
                'Devo.AlertsResults': createContext(results)
            }
            entry_linq['EntryContext'] = {
                'Devo.QueryLink': createContext(querylink)
            }

        return [entry, entry_linq]


    def multi_table_query_command():
        tables_to_query = check_type(demisto.args()['tables'], list)
        search_token = demisto.args()['searchToken']
        timestamp_from = demisto.args()['from']
        timestamp_to = demisto.args().get('to', None)
        write_context = demisto.args()['writeToContext'].lower()

        time_range = get_time_range(timestamp_from, timestamp_to)

        futures = []
        all_results: List[Dict] = []
        sub_queries = []

        for table in tables_to_query:
            fields = ds.Reader(oauth_token=READER_OAUTH_TOKEN, end_point=READER_ENDPOINT)\
                ._get_types(f'from {table} select *', 'now', 'iso').keys()
            clauses = [f"( isnotnull({field}) and str({field})->\"" + search_token + "\")" for field in fields]
            sub_queries.append("from " + table + " where" + " or ".join(clauses) + " select *")

        with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
            for q in sub_queries:
                futures.append(executor.submit(parallel_query_helper, q, all_results, time_range[0], time_range[1]))

        concurrent.futures.wait(futures)

        entry = {
            'Type': entryTypes['note'],
            'Contents': all_results,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown']
        }

        if len(all_results) == 0:
            entry['HumanReadable'] = 'No results found'
            return entry

        headers: Set = set().union(*(r.keys() for r in all_results))

        md = tableToMarkdown('Devo query results', all_results, headers)
        entry['HumanReadable'] = md

        if write_context == 'true':
            entry['EntryContext'] = {
                'Devo.MultiResults': createContext(all_results)
            }

        return entry


    def write_to_table_command():
        table_name = demisto.args()['tableName']
        records = check_type(demisto.args()['records'], list)

        creds = get_writer_creds()

        linq = ds.Writer(key=creds['key'].name, crt=creds['crt'].name, chain=creds['chain'].name, relay=WRITER_RELAY)\
            .load(records, table_name, historical=False, linq_func=(lambda x: x))

        querylink = {'DevoTableLink': build_link(linq, int(1000 * time.time()) - 3600000, int(1000 * time.time()))}

        entry = {
            'Type': entryTypes['note'],
            'Contents': {'recordsWritten': records},
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'EntryContext': {
                'Devo.RecordsWritten': records,
                'Devo.LinqQuery': linq
            }
        }
        entry_linq = {
            'Type': entryTypes['note'],
            'Contents': querylink,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'EntryContext': {
                'Devo.QueryLink': createContext(querylink)
            }
        }
        md = tableToMarkdown('Entries to load into Devo', records)
        entry['HumanReadable'] = md

        md_linq = tableToMarkdown('Link to Devo Query', {'DevoTableLink': f'[Devo Direct Link]({querylink["DevoTableLink"]})'})
        entry_linq['HumanReadable'] = md_linq

        return [entry, entry_linq]


    def write_to_lookup_table_command():
        lookup_table_name = demisto.args()['lookupTableName']
        headers = check_type(demisto.args()['headers'], list)
        records = check_type(demisto.args()['records'], list)

        creds = get_writer_creds()

        engine_config = SenderConfigSSL(address=(WRITER_RELAY, 443),
                                        key=creds['key'].name,
                                        cert=creds['crt'].name,
                                        chain=creds['chain'].name)

        try:
            con = Sender(config=engine_config, timeout=60)

            lookup = Lookup(name=lookup_table_name,
                            historic_tag=None,
                            con=con)
            # Order sensitive list
            pHeaders = json.dumps(headers)

            lookup.send_control('START', pHeaders, 'INC')

            for r in records:
                lookup.send_data_line(key=r['key'], fields=r['values'])

            lookup.send_control('END', pHeaders, 'INC')
        finally:
            con.flush_buffer()
            con.socket.shutdown(0)

        entry = {
            'Type': entryTypes['note'],
            'Contents': {'recordsWritten': records},
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'EntryContext': {
                'Devo.RecordsWritten': records
            }
        }

        md = tableToMarkdown('Entries to load into Devo', records)
        entry['HumanReadable'] = md

        return [entry]


    ''' EXECUTION CODE '''
    try:
        if ALLOW_INSECURE:
            os.environ['CURL_CA_BUNDLE'] = ''
            os.environ['PYTHONWARNINGS'] = 'ignore:Unverified HTTPS request'
        handle_proxy()
        if demisto.command() == 'test-module':
            check_configuration()
            demisto.results('ok')
        elif demisto.command() == 'fetch-incidents':
            fetch_incidents()
        elif demisto.command() == 'devo-run-query':
            demisto.results(run_query_command())
        elif demisto.command() == 'devo-get-alerts':
            demisto.results(get_alerts_command())
        elif demisto.command() == 'devo-multi-table-query':
            demisto.results(multi_table_query_command())
        elif demisto.command() == 'devo-write-to-table':
            demisto.results(write_to_table_command())
        elif demisto.command() == 'devo-write-to-lookup-table':
            demisto.results(write_to_lookup_table_command())

    except Exception as e:
        return_error('Failed to execute command {}. Error: {}'.format(demisto.command(), str(e)))
  subtype: python3
  type: python
system: true
