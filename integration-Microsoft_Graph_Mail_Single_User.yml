category: Email Gateway
commonfields:
  id: Microsoft Graph Mail Single User
  version: -1
configuration:
- defaultvalue: ""
  display: ID (received from the authorization step - see Detailed Instructions (?)
    section)
  name: auth_id
  required: true
  type: 4
- defaultvalue: ""
  display: Token (received from the authorization step - see Detailed Instructions
    (?) section)
  name: refresh_token
  required: true
  type: 4
- defaultvalue: ""
  display: Key (received from the authorization step - see Detailed Instructions (?)
    section)
  name: enc_key
  required: true
  type: 4
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Email address from which to fetch incidents (e.g. "example@demisto.com")
  name: mailbox_to_fetch
  required: true
  type: 0
- defaultvalue: Inbox
  display: Name of the folder from which to fetch incidents (supports Folder ID and
    sub-folders e.g. Inbox/Phishing)
  name: folder_to_fetch
  required: true
  type: 0
- defaultvalue: 15 minutes
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: first_fetch
  required: false
  type: 0
- defaultvalue: "50"
  display: Maximum number of emails to pull per fetch
  name: fetch_limit
  required: false
  type: 0
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Use a self-deployed Azure application
  name: self_deployed
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
description: Microsoft Graph grants Demisto authorized access to a user's Microsoft
  Outlook mail data in a personal account or organization account.
detaileddescription: |2
   To allow us access to Microsoft Graph Mail, you need to approve our app, by clicking on the following [link](https://oproxy.demisto.ninja/ms-graph-mail-listener).
   After authorizing the Demisto app, you will receive an ID, Refresh Token, and Key, which needs to be added to the integration instance configuration's corresponding fields.
display: Microsoft Graph Mail Single User
image: data:image/png;base64,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
name: Microsoft Graph Mail Single User
script:
  commands:
  - arguments:
    - description: A comma-separated list of email addresses for the 'to' field.
      isArray: true
      name: to
    - description: A comma-separated list of email addresses for the 'cc' field.
      isArray: true
      name: cc
    - description: A comma-separated list of email addresses for the 'bcc' field.
      isArray: true
      name: bcc
    - description: The subject for the draft.
      name: subject
      required: true
    - description: The contents (body) of the draft.
      name: body
    - auto: PREDEFINED
      defaultValue: text
      description: 'The body type of the email. Can be: "text", or "HTML".'
      name: body_type
      predefined:
      - text
      - HTML
    - auto: PREDEFINED
      defaultValue: notFlagged
      description: 'The flag value that indicates the status of the draft. Can be:
        "notFlagged", "complete", or "flagged".'
      name: flag
      predefined:
      - notFlagged
      - complete
      - flagged
    - auto: PREDEFINED
      defaultValue: Low
      description: 'The importance of the draft. Can be: "Low", "Normal", or "High".'
      name: importance
      predefined:
      - Low
      - Normal
      - High
    - description: A comma-separated list of additional headers in the format, headerName:headerValue.
        For example, "headerName1:headerValue1,headerName2:headerValue2".
      isArray: true
      name: headers
    - description: A comma-separated list of War Room entry IDs that contain files,
        which are used to attach files to the draft. For example, attachIDs=15@8,19@8.
      isArray: true
      name: attach_ids
    - description: A comma-separated list of names of attachments to be displayed
        in the draft. Must be the same number of elements as attachIDs.
      isArray: true
      name: attach_names
    - description: A comma-separated list of CIDs to embed attachments within the
        actual email.
      isArray: true
      name: attach_cids
    description: Creates a draft message in the specified user's mailbox.
    name: msgraph-mail-create-draft
    outputs:
    - contextPath: MicrosoftGraph.Draft.Cc
      description: The CC recipients of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.IsRead
      description: The "Is read" status of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.Bcc
      description: The BCC recipients of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.Body
      description: The body of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.MessageID
      description: The message ID of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.SentTime
      description: The created time of the draft email.
      type: Date
    - contextPath: MicrosoftGraph.Draft.Headers
      description: The headers of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.From
      description: The user that sent the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.Subject
      description: The subject of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.ReceivedTime
      description: The received time of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.Importance
      description: The importance status of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.CreatedTime
      description: The created time of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.Sender
      description: The sender of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.ModifiedTime
      description: The modified time of the draft email.
      type: Date
    - contextPath: MicrosoftGraph.Draft.IsDraft
      description: Whether it is a draft email.
      type: Boolean
    - contextPath: MicrosoftGraph.Draft.ID
      description: The ID of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.To
      description: The 'to' recipients of the draft email.
      type: String
    - contextPath: MicrosoftGraph.Draft.BodyType
      description: The body type of the draft email.
      type: Unknown
    - contextPath: MicrosoftGraph.Draft.ConversationID
      description: The conversation ID of the draft email.
      type: String
  - arguments:
    - description: A comma-separated list of email addresses for the 'to' field.
      isArray: true
      name: to
    - description: A comma-separated list of email addresses for the 'cc' field.
      isArray: true
      name: cc
    - description: A comma-separated list of email addresses for the 'bcc' field.
      isArray: true
      name: bcc
    - description: The subject of the email.
      name: subject
      required: true
    - description: The contents (body) of the email.
      name: body
    - auto: PREDEFINED
      description: 'The body type of the email. Can be: "text", or "HTML".'
      name: body_type
      predefined:
      - text
      - HTML
    - auto: PREDEFINED
      defaultValue: notFlagged
      description: 'The flag value that indicates the status for the email. Can be:
        "notFlagged", "complete", or "flagged".'
      name: flag
      predefined:
      - notFlagged
      - complete
      - flagged
    - auto: PREDEFINED
      defaultValue: Low
      description: 'The importance of the email. Can be: "Low", "Normal", or "High".'
      name: importance
      predefined:
      - Low
      - Normal
      - High
    - description: 'A comma-separated list of additional headers in the format: headerName:headerValue.
        For example: "headerName1:headerValue1,headerName2:headerValue2".'
      isArray: true
      name: headers
    - description: A comma-separated list of War Room entry IDs that contain files,
        which are used to attach files for the email to send. For example, attachIDs=15@8,19@8.
      isArray: true
      name: attach_ids
    - description: A comma-separated list of names of attachments to display in the
        email to send. Must be the same number of elements as attachIDs.
      isArray: true
      name: attach_names
    - description: A comma-separated list of CIDs to embed attachments within the
        actual email.
      isArray: true
      name: attach_cids
    description: Sends an email using Microsoft Graph.
    name: send-mail
    outputs:
    - contextPath: MicrosoftGraph.Email.internetMessageHeaders
      description: The email headers.
      type: String
    - contextPath: MicrosoftGraph.Email.body
      description: The body of the email.
      type: String
    - contextPath: MicrosoftGraph.Email.bodyPreview
      description: The body preview of the email.
      type: String
    - contextPath: MicrosoftGraph.Email.subject
      description: The subject of the email.
      type: String
    - contextPath: MicrosoftGraph.Email.flag
      description: The flag status of the email.
      type: String
    - contextPath: MicrosoftGraph.Email.importance
      description: The importance status of the email.
      type: String
    - contextPath: MicrosoftGraph.Email.toRecipients
      description: The 'to' recipients of the email.
      type: String
    - contextPath: MicrosoftGraph.Email.ccRecipients
      description: The CC recipients of the email.
      type: String
    - contextPath: MicrosoftGraph.Email.bccRecipients
      description: The BCC recipients of the email.
      type: String
  - arguments:
    - description: The ID of the message.
      name: message_id
      required: true
    - description: The comment of the replied message.
      name: comment
      required: true
    - description: A comma-separated list of email addresses for the 'to' field.
      isArray: true
      name: to
      required: true
    description: The replies to the recipients of a message.
    name: msgraph-mail-reply-to
  - arguments:
    - description: The ID of the draft email.
      name: draft_id
      required: true
    description: Sends a draft email using Microsoft Graph.
    name: msgraph-mail-send-draft
  - arguments: []
    description: Tests connectivity of the email.
    name: msgraph-mail-test
  dockerimage: demisto/crypto:1.0.0.303
  isfetch: true
  runonce: false
  script: |2




    ''' IMPORTS '''
    import requests
    import base64
    import os
    import json

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL VARS '''

    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'

    # Well known folders shortcut in MS Graph API
    # For more information: https://docs.microsoft.com/en-us/graph/api/resources/mailfolder?view=graph-rest-1.0
    WELL_KNOWN_FOLDERS = {
        'archive': 'archive',
        'conversation history': 'conversationhistory',
        'deleted items': 'deleteditems',
        'drafts': 'drafts',
        'inbox': 'inbox',
        'junk email': 'junkemail',
        'outbox': 'outbox',
        'sent items': 'sentitems',
    }

    EMAIL_DATA_MAPPING = {
        'id': 'ID',
        'createdDateTime': 'CreatedTime',
        'lastModifiedDateTime': 'ModifiedTime',
        'receivedDateTime': 'ReceivedTime',
        'sentDateTime': 'SentTime',
        'subject': 'Subject',
        'importance': 'Importance',
        'conversationId': 'ConversationID',
        'isRead': 'IsRead',
        'isDraft': 'IsDraft',
        'internetMessageId': 'MessageID'
    }

    ''' HELPER FUNCTIONS '''


    def get_now_utc():
        """
        Creates UTC current time of format Y-m-dTH:M:SZ (e.g. 2019-11-06T09:06:39Z)

        :return: String format of current UTC time
        :rtype: ``str``
        """
        return datetime.utcnow().strftime(DATE_FORMAT)


    def add_second_to_str_date(date_string, seconds=1):
        """
        Add seconds to date string.

        Is used as workaround to Graph API bug, for more information go to:
        https://stackoverflow.com/questions/35729273/office-365-graph-api-greater-than-filter-on-received-date

        :type date_string: ``str``
        :param date_string: Date string to add seconds

        :type seconds: int
        :param seconds: Seconds to add to date, by default is set to 1

        :return: Date time string appended seconds
        :rtype: ``str``
        """
        added_result = datetime.strptime(date_string, DATE_FORMAT) + timedelta(seconds=seconds)
        return datetime.strftime(added_result, DATE_FORMAT)


    def upload_file(filename, content, attachments_list):
        """
        Uploads file to War room.

        :type filename: ``str``
        :param filename: file name to upload

        :type content: ``str``
        :param content: Content of file to upload

        :type attachments_list: ``list``
        :param attachments_list: List of uploaded file data to War Room
        """
        file_result = fileResult(filename, content)

        if is_error(file_result):
            demisto.error(file_result['Contents'])
            raise Exception(file_result['Contents'])

        attachments_list.append({
            'path': file_result['FileID'],
            'name': file_result['File']
        })


    def read_file_and_encode64(attach_id):
        """
        Reads file that was uploaded to War Room and encodes it's content to base 64.

        :type attach_id: ``str``
        :param attach_id: The id of uploaded file to War Room

        :return: Base 64 encoded data, size of the encoded data in bytes and uploaded file name.
        :rtype: ``bytes``, ``int``, ``str``
        """
        try:
            file_info = demisto.getFilePath(attach_id)
            with open(file_info['path'], 'rb') as file_data:
                b64_encoded_data = base64.b64encode(file_data.read())
                file_size = os.path.getsize(file_info['path'])
                return b64_encoded_data, file_size, file_info['name']
        except Exception as e:
            raise Exception(f'Unable to read and decode in base 64 file with id {attach_id}', e)


    def prepare_args(command, args):
        """
        Receives command and prepares the arguments for future usage.

        :type command: ``str``
        :param command: Command to execute

        :type args: ``dict``
        :param args: Demisto args

        :return: Prepared args
        :rtype: ``dict``
        """
        if command in ['msgraph-mail-create-draft', 'send-mail']:
            return {
                'to_recipients': argToList(args.get('to')),
                'cc_recipients': argToList(args.get('cc')),
                'bcc_recipients': argToList(args.get('bcc')),
                'subject': args.get('subject', ''),
                'body': args.get('body', ''),
                'body_type': args.get('body_type', 'text'),
                'flag': args.get('flag', 'notFlagged'),
                'importance': args.get('importance', 'Low'),
                'internet_message_headers': argToList(args.get('headers')),
                'attach_ids': argToList(args.get('attach_ids')),
                'attach_names': argToList(args.get('attach_names')),
                'attach_cids': argToList((args.get('attach_cids'))),
                'manual_attachments': args.get('manualAttachObj', [])
            }

        elif command == 'msgraph-mail-reply-to':
            return {
                'to_recipients': argToList(args.get('to')),
                'message_id': args.get('message_id', ''),
                'comment': args.get('comment')
            }

        return args


    ''' MICROSOFT GRAPH MAIL CLIENT '''


    class MsGraphClient:
        """
        Microsoft Graph Mail Client enables authorized access to a user's Office 365 mail data in a personal account.
        """
        ITEM_ATTACHMENT = '#microsoft.graph.itemAttachment'
        FILE_ATTACHMENT = '#microsoft.graph.fileAttachment'
        CONTEXT_DRAFT_PATH = 'MicrosoftGraph.Draft(val.ID && val.ID == obj.ID)'
        CONTEXT_SENT_EMAIL_PATH = 'MicrosoftGraph.Email'

        def __init__(self, ms_client, mailbox_to_fetch, folder_to_fetch, first_fetch_interval, emails_fetch_limit):
            self.ms_client = ms_client
            self._mailbox_to_fetch = mailbox_to_fetch
            self._folder_to_fetch = folder_to_fetch
            self._first_fetch_interval = first_fetch_interval
            self._emails_fetch_limit = emails_fetch_limit

        def _get_root_folder_children(self, user_id):
            """
            Get the root folder (Top Of Information Store) children collection.

            :type user_id: ``str``
            :param user_id: Mailbox address

            :raises: ``Exception``: No folders found under Top Of Information Store folder

            :return: List of root folder children
            rtype: ``list``
            """
            suffix_endpoint = f'users/{user_id}/mailFolders/msgfolderroot/childFolders?$top=250'
            root_folder_children = self.ms_client.http_request('GET', suffix_endpoint).get('value', None)
            if not root_folder_children:
                raise Exception("No folders found under Top Of Information Store folder")

            return root_folder_children

        def _get_folder_children(self, user_id, folder_id):
            """
            Get the folder collection under the specified folder.

            :type user_id ``str``
            :param user_id: Mailbox address

            :type folder_id: ``str``
            :param folder_id: Folder id

            :return: List of folders that contain basic folder information
            :rtype: ``list``
            """
            suffix_endpoint = f'users/{user_id}/mailFolders/{folder_id}/childFolders?$top=250'
            folder_children = self.ms_client.http_request('GET', suffix_endpoint).get('value', [])
            return folder_children

        def _get_folder_info(self, user_id, folder_id):
            """
            Returns folder information.

            :type user_id: ``str``
            :param user_id: Mailbox address

            :type folder_id: ``str``
            :param folder_id: Folder id

            :raises: ``Exception``: No info found for folder {folder id}

            :return: Folder information if found
            :rtype: ``dict``
            """

            suffix_endpoint = f'users/{user_id}/mailFolders/{folder_id}'
            folder_info = self.ms_client.http_request('GET', suffix_endpoint)
            if not folder_info:
                raise Exception(f'No info found for folder {folder_id}')
            return folder_info

        def _get_folder_by_path(self, user_id, folder_path):
            """
            Searches and returns basic folder information.

            Receives mailbox address and folder path (e.g Inbox/Phishing) and iteratively retrieves folders info until
            reaches the last folder of a path. In case that such folder exist, basic information that includes folder id,
            display name, parent folder id, child folders count, unread items count and total items count will be returned.

            :type user_id: ``str``
            :param user_id: Mailbox address

            :type folder_path: ``str``
            :param folder_path: Folder path of searched folder

            :raises: ``Exception``: No such folder exist: {folder path}

            :return: Folder information if found
            :rtype: ``dict``
            """
            folders_names = folder_path.replace('\\', '/').split('/')  # replaced backslash in original folder path

            # Optimization step in order to improve performance before iterating the folder path in order to skip API call
            # for getting Top of Information Store children collection if possible.
            if folders_names[0].lower() in WELL_KNOWN_FOLDERS:
                # check if first folder in the path is known folder in order to skip not necessary api call
                folder_id = WELL_KNOWN_FOLDERS[folders_names[0].lower()]  # get folder shortcut instead of using folder id
                if len(folders_names) == 1:  # in such case the folder path consist only from one well known folder
                    return self._get_folder_info(user_id, folder_id)
                else:
                    current_directory_level_folders = self._get_folder_children(user_id, folder_id)
                    folders_names.pop(0)  # remove the first folder name from the path before iterating
            else:  # in such case the optimization step is skipped
                # current_directory_level_folders will be set to folders that are under Top Of Information Store (root)
                current_directory_level_folders = self._get_root_folder_children(user_id)

            for index, folder_name in enumerate(folders_names):
                # searching for folder in current_directory_level_folders list by display name or id
                found_folder = [f for f in current_directory_level_folders if
                                f.get('displayName', '').lower() == folder_name.lower() or f.get('id', '') == folder_name]

                if not found_folder:  # no folder found, return error
                    raise Exception(f'No such folder exist: {folder_path}')
                found_folder = found_folder[0]  # found_folder will be list with only one element in such case

                if index == len(folders_names) - 1:  # reached the final folder in the path
                    # skip get folder children step in such case
                    return found_folder
                # didn't reach the end of the loop, set the current_directory_level_folders to folder children
                current_directory_level_folders = self._get_folder_children(user_id, found_folder.get('id', ''))

        def _fetch_last_emails(self, folder_id, last_fetch, exclude_ids):
            """
            Fetches emails from given folder that were modified after specific datetime (last_fetch).

            All fields are fetched for given email using select=* clause,
            for more information https://docs.microsoft.com/en-us/graph/query-parameters.
            The email will be excluded from returned results if it's id is presented in exclude_ids.
            Number of fetched emails is limited by _emails_fetch_limit parameter.
            The filtering and ordering is done based on modified time.

            :type folder_id: ``str``
            :param folder_id: Folder id

            :type last_fetch: ``dict``
            :param last_fetch: Previous fetch data

            :type exclude_ids: ``list``
            :param exclude_ids: List of previous fetch email ids to exclude in current run

            :return: Fetched emails and exclude ids list that contains the new ids of fetched emails
            :rtype: ``list`` and ``list``
            """
            target_modified_time = add_second_to_str_date(last_fetch)  # workaround to Graph API bug
            suffix_endpoint = (f"users/{self._mailbox_to_fetch}/mailFolders/{folder_id}/messages"
                               f"?$filter=lastModifiedDateTime ge {target_modified_time}"
                               f"&$orderby=lastModifiedDateTime &$top={self._emails_fetch_limit}&select=*")
            fetched_emails = self.ms_client.http_request('GET', suffix_endpoint).get('value', [])[:self._emails_fetch_limit]

            if exclude_ids:  # removing emails in order to prevent duplicate incidents
                fetched_emails = [email for email in fetched_emails if email.get('id') not in exclude_ids]

            fetched_emails_ids = [email.get('id') for email in fetched_emails]
            return fetched_emails, fetched_emails_ids

        @staticmethod
        def _get_next_run_time(fetched_emails, start_time):
            """
            Returns modified time of last email if exist, else utc time that was passed as start_time.

            The elements in fetched emails are ordered by modified time in ascending order,
            meaning the last element has the latest modified time.

            :type fetched_emails: ``list``
            :param fetched_emails: List of fetched emails

            :type start_time: ``str``
            :param start_time: utc string of format Y-m-dTH:M:SZ

            :return: Returns str date of format Y-m-dTH:M:SZ
            :rtype: `str`
            """
            next_run_time = fetched_emails[-1].get('lastModifiedDateTime') if fetched_emails else start_time

            return next_run_time

        @staticmethod
        def _get_recipient_address(email_address):
            """
            Receives dict of form  "emailAddress":{"name":"_", "address":"_"} and return the address

            :type email_address: ``dict``
            :param email_address: Recipient address

            :return: The address of recipient
            :rtype: ``str``
            """
            return email_address.get('emailAddress', {}).get('address', '')

        @staticmethod
        def _parse_email_as_labels(parsed_email):
            """
            Parses the email as incident labels.

            :type parsed_email: ``dict``
            :param parsed_email: The parsed email from which create incidents labels.

            :return: Incident labels
            :rtype: ``list``
            """
            labels = []

            for (key, value) in parsed_email.items():
                if key == 'Headers':
                    headers_labels = [
                        {'type': 'Email/Header/{}'.format(header.get('name', '')), 'value': header.get('value', '')}
                        for header in value]
                    labels.extend(headers_labels)
                elif key in ['To', 'Cc', 'Bcc']:
                    recipients_labels = [{'type': f'Email/{key}', 'value': recipient} for recipient in value]
                    labels.extend(recipients_labels)
                else:
                    labels.append({'type': f'Email/{key}', 'value': f'{value}'})

            return labels

        @staticmethod
        def _parse_item_as_dict(email):
            """
            Parses basic data of email.

            Additional info https://docs.microsoft.com/en-us/graph/api/resources/message?view=graph-rest-1.0

            :type email: ``dict``
            :param email: Email to parse

            :return: Parsed email
            :rtype: ``dict``
            """
            parsed_email = {EMAIL_DATA_MAPPING[k]: v for (k, v) in email.items() if k in EMAIL_DATA_MAPPING}
            parsed_email['Headers'] = email.get('internetMessageHeaders', [])

            email_body = email.get('body', {}) or email.get('uniqueBody', {})
            parsed_email['Body'] = email_body.get('content', '')
            parsed_email['BodyType'] = email_body.get('contentType', '')

            parsed_email['Sender'] = MsGraphClient._get_recipient_address(email.get('sender', {}))
            parsed_email['From'] = MsGraphClient._get_recipient_address(email.get('from', {}))
            parsed_email['To'] = list(map(MsGraphClient._get_recipient_address, email.get('toRecipients', [])))
            parsed_email['Cc'] = list(map(MsGraphClient._get_recipient_address, email.get('ccRecipients', [])))
            parsed_email['Bcc'] = list(map(MsGraphClient._get_recipient_address, email.get('bccRecipients', [])))

            return parsed_email

        @staticmethod
        def _build_recipient_input(recipients):
            """
            Builds legal recipients list.

            :type recipients: ``list``
            :param recipients: List of recipients

            :return: List of email addresses recipients
            :rtype: ``list``
            """
            return [{'emailAddress': {'address': r}} for r in recipients] if recipients else []

        @staticmethod
        def _build_body_input(body, body_type):
            """
            Builds message body input.

            :type body: ``str``
            :param body: The body of the message

            :type body_type: The body type of the message, html or text.
            :param body_type:

            :return: The message body
            :rtype ``dict``
            """
            return {
                "content": body,
                "contentType": body_type
            }

        @staticmethod
        def _build_flag_input(flag):
            """
            Builds flag status of the message.

            :type flag: ``str``
            :param flag: The flag of the message

            :return: The flag status of the message
            :rtype ``dict``
            """
            return {'flagStatus': flag}

        @staticmethod
        def _build_headers_input(internet_message_headers):
            """
            Builds valid headers input.

            :type internet_message_headers: ``list``
            :param internet_message_headers: List of headers to build.

            :return: List of transformed headers
            :rtype: ``list``
            """
            return [{'name': kv[0], 'value': kv[1]} for kv in (h.split(':') for h in internet_message_headers)]

        @classmethod
        def _build_attachments_input(cls, ids, attach_names=None, is_inline=False):
            """
            Builds valid attachment input of the message. Is used for both in-line and regular attachments.

            :type ids: ``list``
            :param ids: List of uploaded to War Room files ids

            :type attach_names: ``list``
            :param attach_names: List of attachment name, not required.

            :type is_inline: ``bool``
            :param is_inline: Indicates whether the attachment is inline or not

            :return: List of valid attachments of message
            :rtype: ``list``
            """
            provided_names = bool(attach_names)

            if provided_names and len(ids) != len(attach_names):
                raise Exception("Invalid input, attach_ids and attach_names lists should be the same length.")

            file_attachments_result = []
            # in case that no attach names where provided, ids are zipped together and the attach_name value is ignored
            attachments = zip(ids, attach_names) if provided_names else zip(ids, ids)

            for attach_id, attach_name in attachments:
                b64_encoded_data, file_size, uploaded_file_name = read_file_and_encode64(attach_id)
                attachment = {
                    '@odata.type': cls.FILE_ATTACHMENT,
                    'contentBytes': b64_encoded_data.decode('utf-8'),
                    'isInline': is_inline,
                    'name': attach_name if provided_names else uploaded_file_name,
                    'size': file_size
                }
                file_attachments_result.append(attachment)

            return file_attachments_result

        @staticmethod
        def _build_file_attachments_input(attach_ids, attach_names, attach_cids, manual_attachments):
            """
            Builds both inline and regular attachments.

            :type attach_ids: ``list``
            :param attach_ids: List of uploaded to War Room regular attachments to send

            :type attach_names: ``list``
            :param attach_names: List of regular attachments names to send

            :type attach_cids: ``list``
            :param attach_cids: List of uploaded to War Room inline attachments to send

            :type manual_attachments: ``list``
            :param manual_attachments: List of manual attachments reports to send

            :return: List of both inline and regular attachments of the message
            :rtype: ``list``
            """
            regular_attachments = MsGraphClient._build_attachments_input(ids=attach_ids, attach_names=attach_names)
            inline_attachments = MsGraphClient._build_attachments_input(ids=attach_cids, is_inline=True)
            # collecting manual attachments info
            manual_att_ids = [os.path.basename(att['RealFileName']) for att in manual_attachments if 'RealFileName' in att]
            manual_att_names = [att['FileName'] for att in manual_attachments if 'FileName' in att]
            manual_report_attachments = MsGraphClient._build_attachments_input(ids=manual_att_ids,
                                                                               attach_names=manual_att_names)

            return regular_attachments + inline_attachments + manual_report_attachments

        @staticmethod
        def _build_message(to_recipients, cc_recipients, bcc_recipients, subject, body, body_type, flag, importance,
                           internet_message_headers, attach_ids, attach_names, attach_cids, manual_attachments):
            """
            Builds valid message dict.
            For more information https://docs.microsoft.com/en-us/graph/api/resources/message?view=graph-rest-1.0
            """
            message = {
                'toRecipients': MsGraphClient._build_recipient_input(to_recipients),
                'ccRecipients': MsGraphClient._build_recipient_input(cc_recipients),
                'bccRecipients': MsGraphClient._build_recipient_input(bcc_recipients),
                'subject': subject,
                'body': MsGraphClient._build_body_input(body=body, body_type=body_type),
                'bodyPreview': body[:255],
                'importance': importance,
                'flag': MsGraphClient._build_flag_input(flag),
                'attachments': MsGraphClient._build_file_attachments_input(attach_ids, attach_names, attach_cids,
                                                                           manual_attachments)
            }

            if internet_message_headers:
                message['internetMessageHeaders'] = MsGraphClient._build_headers_input(internet_message_headers)

            return message

        @staticmethod
        def _build_reply(to_recipients, comment):
            """
            Builds the reply message that includes recipients to reply and reply message.

            :type to_recipients: ``list``
            :param to_recipients: The recipients list to reply

            :type comment: ``str``
            :param comment: The message to reply.

            :return: Returns legal reply message.
            :rtype: ``dict``
            """
            return {
                'message': {
                    'toRecipients': MsGraphClient._build_recipient_input(to_recipients)
                },
                'comment': comment
            }

        def _get_attachment_mime(self, message_id, attachment_id):
            """
            Gets attachment mime.

            :type attachment_id: ``str``
            :param attachment_id: Attachment id to get MIME

            :return: The MIME of the attachment
            :rtype: ``str``
            """
            suffix_endpoint = f'users/{self._mailbox_to_fetch}/messages/{message_id}/attachments/{attachment_id}/$value'
            mime_content = self.ms_client.http_request('GET', suffix_endpoint, resp_type='text')

            return mime_content

        def _get_email_attachments(self, message_id):
            """
            Get email attachments  and upload to War Room.

            :type message_id: ``str``
            :param message_id: The email id to get attachments

            :return: List of uploaded to War Room data, uploaded file path and name
            :rtype: ``list``
            """

            attachment_results = []  # type: ignore
            suffix_endpoint = f'users/{self._mailbox_to_fetch}/messages/{message_id}/attachments'
            attachments = self.ms_client.http_request('Get', suffix_endpoint).get('value', [])

            for attachment in attachments:
                attachment_type = attachment.get('@odata.type', '')
                attachment_name = attachment.get('name', 'untitled_attachment')
                if attachment_type == self.FILE_ATTACHMENT:
                    try:
                        attachment_content = base64.b64decode(attachment.get('contentBytes', ''))
                    except Exception as e:  # skip the uploading file step
                        demisto.info(f"MS-Graph-Listener: failed in decoding base64 file attachment with error {str(e)}")
                        continue
                elif attachment_type == self.ITEM_ATTACHMENT:
                    attachment_id = attachment.get('id', '')
                    attachment_content = self._get_attachment_mime(message_id, attachment_id)
                    attachment_name = f'{attachment_name}.eml'
                # upload the item/file attachment to War Room
                upload_file(attachment_name, attachment_content, attachment_results)

            return attachment_results

        def _parse_email_as_incident(self, email):
            """
            Parses fetched emails as incidents.

            :type email: ``dict``
            :param email: Fetched email to parse

            :return: Parsed email
            :rtype: ``dict``
            """
            parsed_email = MsGraphClient._parse_item_as_dict(email)

            if email.get('hasAttachments', False):  # handling attachments of fetched email
                parsed_email['Attachments'] = self._get_email_attachments(message_id=email.get('id', ''))

            incident = {
                'name': parsed_email['Subject'],
                'details': email.get('bodyPreview', '') or parsed_email['Body'],
                'labels': MsGraphClient._parse_email_as_labels(parsed_email),
                'occurred': parsed_email['ModifiedTime'],
                'attachment': parsed_email.get('Attachments', []),
                'rawJSON': json.dumps(parsed_email)
            }

            return incident

        @logger
        def fetch_incidents(self, last_run):
            """
            Fetches emails from office 365 mailbox and creates incidents of parsed emails.

            :type last_run: ``dict``
            :param last_run:
                Previous fetch run data that holds the fetch time in utc Y-m-dTH:M:SZ format,
                ids of fetched emails, id and path of folder to fetch incidents from

            :return: Next run data and parsed fetched incidents
            :rtype: ``dict`` and ``list``
            """
            start_time = get_now_utc()
            last_fetch = last_run.get('LAST_RUN_TIME')
            exclude_ids = last_run.get('LAST_RUN_IDS', [])
            last_run_folder_path = last_run.get('LAST_RUN_FOLDER_PATH')
            folder_path_changed = (last_run_folder_path != self._folder_to_fetch)

            if folder_path_changed:
                # detected folder path change, get new folder id
                folder_id = self._get_folder_by_path(self._mailbox_to_fetch, self._folder_to_fetch).get('id')
                demisto.info("MS-Graph-Listener: detected file path change, ignored last run.")
            else:
                # LAST_RUN_FOLDER_ID is stored in order to avoid calling _get_folder_by_path method in each fetch
                folder_id = last_run.get('LAST_RUN_FOLDER_ID')

            if not last_fetch or folder_path_changed:  # initialized fetch
                last_fetch, _ = parse_date_range(self._first_fetch_interval, date_format=DATE_FORMAT, utc=True)
                demisto.info(f"MS-Graph-Listener: initialize fetch and pull emails from date :{last_fetch}")

            fetched_emails, fetched_emails_ids = self._fetch_last_emails(folder_id=folder_id, last_fetch=last_fetch,
                                                                         exclude_ids=exclude_ids)
            incidents = list(map(self._parse_email_as_incident, fetched_emails))
            next_run_time = MsGraphClient._get_next_run_time(fetched_emails, start_time)
            next_run = {
                'LAST_RUN_TIME': next_run_time,
                'LAST_RUN_IDS': fetched_emails_ids,
                'LAST_RUN_FOLDER_ID': folder_id,
                'LAST_RUN_FOLDER_PATH': self._folder_to_fetch
            }
            demisto.info(f"MS-Graph-Listener: fetched {len(incidents)} incidents")

            return next_run, incidents

        def create_draft(self, **kwargs):
            """
            Creates draft message in user's mailbox, in draft folder.
            """
            suffix_endpoint = f'/users/{self._mailbox_to_fetch}/messages'
            draft = MsGraphClient._build_message(**kwargs)

            created_draft = self.ms_client.http_request('POST', suffix_endpoint, json_data=draft)
            parsed_draft = MsGraphClient._parse_item_as_dict(created_draft)
            human_readable = tableToMarkdown(f'Created draft with id: {parsed_draft.get("ID", "")}', parsed_draft)
            ec = {self.CONTEXT_DRAFT_PATH: parsed_draft}

            return human_readable, ec, created_draft

        def send_email(self, **kwargs):
            """
            Sends email from user's mailbox, the sent message will appear in Sent Items folder
            """
            suffix_endpoint = f'/users/{self._mailbox_to_fetch}/sendMail'
            message_content = MsGraphClient._build_message(**kwargs)
            self.ms_client.http_request('POST', suffix_endpoint, json_data={'message': message_content},
                                        resp_type="text")

            message_content.pop('attachments', None)
            message_content.pop('internet_message_headers', None)
            human_readable = tableToMarkdown(f'Email was sent successfully.', message_content)
            ec = {self.CONTEXT_SENT_EMAIL_PATH: message_content}

            return human_readable, ec

        def reply_to(self, to_recipients, comment, message_id):
            """
            Sends reply message to recipients.

            :type to_recipients: ``list``
            :param to_recipients: List of recipients to reply.

            :type comment: ``str``
            :param comment: The comment to send as a reply

            :type message_id: ``str``
            :param message_id: The message id to reply.

            :return: String representation of markdown message regarding successful message submission.
            rtype: ``str``
            """
            suffix_endpoint = f'/users/{self._mailbox_to_fetch}/messages/{message_id}/reply'
            reply = MsGraphClient._build_reply(to_recipients, comment)
            self.ms_client.http_request('POST', suffix_endpoint, json_data=reply, resp_type="text")

            return f'### Replied to: {", ".join(to_recipients)} with comment: {comment}'

        def send_draft(self, draft_id):
            """
            Send draft message.

            :type draft_id: ``str``
            :param draft_id: Draft id to send.

            :return: String representation of markdown message regarding successful message submission.
            :rtype: ``str``
            """
            suffix_endpoint = f'/users/{self._mailbox_to_fetch}/messages/{draft_id}/send'
            self.ms_client.http_request('POST', suffix_endpoint, resp_type="text")

            return f'### Draft with: {draft_id} id was sent successfully.'

        def test_connection(self):
            """
            Basic connection test instead of test-module.

            :return: Returns markdown string representation of success or Exception in case of login failure.
            rtype: ``str`` or Exception
            """
            suffix_endpoint = f'users/{self._mailbox_to_fetch}'
            user_response = self.ms_client.http_request('GET', suffix_endpoint)

            if user_response.get('mail') != '' and user_response.get('id') != '':
                return_outputs('```✅ Success!```')
            else:
                raise Exception("Failed validating the user.")


    def main():
        """ COMMANDS MANAGER / SWITCH PANEL """
        params = demisto.params()

        self_deployed = params.get('self_deployed', False)

        # params related to common instance configuration
        base_url = 'https://graph.microsoft.com/v1.0/'
        verify = not params.get('insecure', False)
        proxy = params.get('proxy', False)
        ok_codes = (200, 201, 202)

        # params related to mailbox to fetch incidents
        mailbox_to_fetch = params.get('mailbox_to_fetch', '')
        folder_to_fetch = params.get('folder_to_fetch', 'Inbox')
        first_fetch_interval = params.get('first_fetch', '15 minutes')
        emails_fetch_limit = int(params.get('fetch_limit', '50'))

        if self_deployed:
            tenant_id = params.get('refresh_token')
            app_url = f'https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token'
            ms_client = MicrosoftClient.from_self_deployed(tenant_id, params.get('auth_id'),
                                                           params.get('enc_key'), app_url=app_url,
                                                           scope='https://graph.microsoft.com/.default',
                                                           base_url=base_url, verify=verify, proxy=proxy, ok_codes=ok_codes)
        else:
            # params related to oproxy
            # In case the script is running for the first time, refresh token is retrieved from integration parameters,
            # in other case it's retrieved from integration context.
            refresh_token = (demisto.getIntegrationContext().get('current_refresh_token')
                             or params.get('refresh_token', ''))
            enc_key = params.get('enc_key')
            app_name = 'ms-graph-mail-listener'
            ms_client = MicrosoftClient.from_oproxy(params.get('auth_id', ''), enc_key, app_name,
                                                    refresh_token=refresh_token,
                                                    base_url=base_url, verify=verify, proxy=proxy, ok_codes=ok_codes)
        client = MsGraphClient(ms_client, mailbox_to_fetch, folder_to_fetch, first_fetch_interval, emails_fetch_limit)
        try:
            command = demisto.command()
            args = prepare_args(command, demisto.args())
            LOG(f'Command being called is {command}')

            if command == 'test-module':
                # cannot use test module due to the lack of ability to set refresh token to integration context
                raise Exception("Please use !msgraph-mail-test instead")
            if command == 'msgraph-mail-test':
                client.test_connection()
            if command == 'fetch-incidents':
                next_run, incidents = client.fetch_incidents(demisto.getLastRun())
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)
            elif command == 'msgraph-mail-create-draft':
                human_readable, ec, raw_response = client.create_draft(**args)
                return_outputs(human_readable, ec, raw_response)
            elif command == 'msgraph-mail-reply-to':
                human_readable = client.reply_to(**args)  # pylint: disable=E1123
                return_outputs(human_readable)
            elif command == 'msgraph-mail-send-draft':
                human_readable = client.send_draft(**args)  # pylint: disable=E1123
                return_outputs(human_readable)
            elif command == 'send-mail':
                human_readable, ec = client.send_email(**args)
                return_outputs(human_readable, ec)
        except Exception as e:
            return_error(str(e))



    ### GENERATED CODE ###
    # This code was inserted in place of an API module.


    import requests
    import base64
    from typing import Dict, Tuple
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM

    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'


    class MicrosoftClient(BaseClient):

        def __init__(self, tenant_id: str = '', auth_id: str = '', enc_key: str = '',
                     token_retrieval_url: str = '', app_name: str = '', refresh_token: str = '',
                     client_id: str = '', client_secret: str = '', scope: str = '', resource: str = '', app_url: str = '',
                     verify: bool = True, auth_type: str = OPROXY_AUTH_TYPE, *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]
            self.auth_type = auth_type
            self.app_url = app_url
            self.tenant_id = tenant_id
            self.auth_id = auth_id
            self.enc_key = enc_key
            self.token_retrieval_url = token_retrieval_url
            self.app_name = app_name
            self.refresh_token = refresh_token
            self.client_id = client_id
            self.client_secret = client_secret
            self.scope = scope
            self.resource = resource
            self.verify = verify

        @classmethod
        def from_oproxy(cls, auth_id_and_token_url: str, enc_key: str, app_name: str,
                        tenant_id: str = '', refresh_token: str = '', *args, **kwargs):
            """
            Args:
                auth_id_and_token_url: Authentication ID and the oproxy url to use
                enc_key: Encryption key
                app_name: The application name in oproxy
                tenant_id: The tenant ID
                refresh_token: The current refresh token
            Returns:
                An instance of Microsoft Client with oproxy authentication.
            """
            auth_id_and_token_retrieval_url = auth_id_and_token_url.split('@')
            auth_id = auth_id_and_token_retrieval_url[0]
            if len(auth_id_and_token_retrieval_url) != 2:
                token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # disable-secrets-detection
            else:
                token_retrieval_url = auth_id_and_token_retrieval_url[1]

            return cls(tenant_id=tenant_id, auth_id=auth_id, enc_key=enc_key,  # type: ignore[misc]
                       token_retrieval_url=token_retrieval_url, auth_type=OPROXY_AUTH_TYPE,
                       app_name=app_name, refresh_token=refresh_token, *args, **kwargs)

        @classmethod
        def from_self_deployed(cls, tenant_id: str, client_id: str, client_secret: str, scope: str = '', resource: str = '',
                               app_url: str = '', *args, **kwargs):
            """
            Args:
                tenant_id: The self deployed tenant ID
                client_id: The self deployed client ID
                client_secret: The self deployed client secret
                scope: The self deployed application scope
                resource: The self deployed application resource
                app_url: The self deployed application request URL
            Returns:
                An instance of Microsoft Client with self deployed application authentication.
            """
            return cls(tenant_id=tenant_id, client_id=client_id,  # type: ignore[misc]
                       client_secret=client_secret, auth_type=SELF_DEPLOYED_AUTH_TYPE,
                       scope=scope, resource=resource, app_url=app_url, *args, **kwargs)

        def http_request(self, *args, **kwargs) -> requests.Response:
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Returns:
                requests.Response: The http response
            """
            token = self.get_access_token()
            headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            return super()._http_request(*args, headers=headers, **kwargs)  # type: ignore[misc]

        def get_access_token(self):
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = demisto.getIntegrationContext()
            access_token = integration_context.get('access_token')
            valid_until = integration_context.get('valid_until')
            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            auth_type = self.auth_type
            refresh_token = ''
            if auth_type == OPROXY_AUTH_TYPE:
                access_token, expires_in, refresh_token = self._oproxy_authorize()
            else:
                access_token, expires_in = self._get_self_deployed_token()
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer

            integration_context = {
                'access_token': access_token,
                'valid_until': time_now + expires_in,
            }

            if refresh_token:
                integration_context['current_refresh_token'] = refresh_token
            demisto.setIntegrationContext(integration_context)
            return access_token

        def _oproxy_authorize(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key)
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self) -> Tuple[str, int]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token and its expiry.
            """
            if not self.app_url:
                url = f'https://login.windows.net/{self.tenant_id}/oauth2/token'
            else:
                url = self.app_url
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': 'client_credentials'
            }

            if self.scope:
                data['scope'] = self.scope
            if self.resource:
                data['resource'] = self.resource

            body: dict = {}
            try:
                response = requests.post(url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                body = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = body.get('access_token', '')
            expires_in = int(body.get('expires_in', 3595))

            return access_token, expires_in

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                enc_key = base64.b64decode(enc_key)
                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                calling_context = demisto.callingContext.get('context', {})  # type: ignore[attr-defined]
                brand_name = calling_context.get('IntegrationBrand', '')
                instance_name = calling_context.get('IntegrationInstance', '')
                headers['X-Content-Version'] = CONTENT_RELEASE_VERSION
                headers['X-Content-Name'] = brand_name or instance_name or 'Name not found'
                if hasattr(demisto, 'demistoVersion'):
                    demisto_version = demisto.demistoVersion()
                    headers['X-Content-Server-Version'] = '{}-{}'.format(demisto_version.get('version'),
                                                                         demisto_version.get("buildNumber"))
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers




    if __name__ in ['__main__', '__builtin__', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
