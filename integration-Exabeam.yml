category: Analytics & SIEM
commonfields:
  id: Exabeam
  version: -1
configuration:
- defaultvalue: ""
  display: Server URL (e.g https://100.24.16.156:8484)
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: Username
  name: credentials
  required: true
  type: 9
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: The Exabeam Security Management Platform provides end-to-end detection,
  User Event Behavioral Analytics, and SOAR.
detaileddescription: ' '
display: Exabeam
image: data:image/png;base64,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
name: Exabeam
script:
  commands:
  - arguments:
    - description: The time period for which to fetch notable users, such as 3 months,
        2 days, 4 hours, 1 year, and so on.
      isArray: true
      name: time_period
      required: true
    - defaultValue: "10"
      description: The maximum number of returned results.
      name: limit
      required: true
    deprecated: true
    description: Returns notable users in a period of time.
    name: get-notable-users
    outputs:
    - contextPath: Exabeam.User.RiskScore
      description: The risk score of the notable user.
      type: Number
    - contextPath: Exabeam.User.UserFullName
      description: The full name of the user.
      type: String
    - contextPath: Exabeam.User.AverageRiskScore
      description: The average risk score of the user.
      type: Number
    - contextPath: Exabeam.User.FirstSeen
      description: The date the user was first seen.
      type: Date
    - contextPath: Exabeam.User.NotableSessionIds
      description: The ID of the notable session.
      type: String
    - contextPath: Exabeam.User.AccountsNumber
      description: The number of accounts.
      type: Number
    - contextPath: Exabeam.User.LastSeen
      description: The date the user was last seen.
      type: Date
    - contextPath: Exabeam.User.Location
      description: The location of the user.
      type: String
    - contextPath: Exabeam.User.UserName
      description: The name of the user.
      type: String
    - contextPath: Exabeam.User.Labels
      description: The labels of the user.
      type: String
    - contextPath: Exabeam.User.LastActivityType
      description: The last activity type of the user.
      type: String
    - contextPath: Exabeam.User.NotableUser
      description: Whether the user is a notable user.
      type: Boolean
  - arguments:
    - description: The time period for which to fetch notable users, such as 3 months,
        2 days, 4 hours, 1 year, and so on.
      isArray: true
      name: time_period
      required: true
    - defaultValue: "10"
      description: The maximum number of returned results.
      name: limit
      required: true
    description: Returns notable users in a period of time.
    name: exabeam-get-notable-users
    outputs:
    - contextPath: Exabeam.User.RiskScore
      description: The risk score of the notable user.
      type: Number
    - contextPath: Exabeam.User.UserFullName
      description: The full name of the user.
      type: String
    - contextPath: Exabeam.User.AverageRiskScore
      description: The average risk score of the user.
      type: Number
    - contextPath: Exabeam.User.FirstSeen
      description: The date the user was first seen.
      type: Date
    - contextPath: Exabeam.User.NotableSessionIds
      description: The ID of the notable session.
      type: String
    - contextPath: Exabeam.User.AccountsNumber
      description: The number of accounts.
      type: Number
    - contextPath: Exabeam.User.LastSeen
      description: The date the user was last seen.
      type: Date
    - contextPath: Exabeam.User.Location
      description: The location of the user.
      type: String
    - contextPath: Exabeam.User.UserName
      description: The name of the user.
      type: String
    - contextPath: Exabeam.User.Labels
      description: The labels of the user.
      type: String
    - contextPath: Exabeam.User.LastActivityType
      description: The last activity type of the user.
      type: String
    - contextPath: Exabeam.User.NotableUser
      description: Whether the user is a notable user.
      type: Boolean
  - arguments: []
    deprecated: true
    description: Returns all watchlist IDs and titles.
    name: get-watchlists
    outputs:
    - contextPath: Exabeam.Watchlist.Category
      description: The watchlist category.
      type: String
    - contextPath: Exabeam.Watchlist.Title
      description: The watchlist title.
      type: String
    - contextPath: Exabeam.Watchlist.WatchlistID
      description: The watchlist ID.
      type: String
  - arguments: []
    description: Returns all watchlist IDs and titles.
    name: exabeam-get-watchlists
    outputs:
    - contextPath: Exabeam.Watchlist.Category
      description: The watchlist category.
      type: String
    - contextPath: Exabeam.Watchlist.Title
      description: The watchlist title.
      type: String
    - contextPath: Exabeam.Watchlist.WatchlistID
      description: The watchlist ID.
      type: String
  - arguments: []
    deprecated: true
    description: Returns all peer groups.
    name: get-peer-groups
    outputs:
    - contextPath: Exabeam.PeerGroup.Name
      description: The name of the peer group.
      type: String
  - arguments: []
    description: Returns all peer groups.
    name: exabeam-get-peer-groups
    outputs:
    - contextPath: Exabeam.PeerGroup.Name
      description: The name of the peer group.
      type: String
  - arguments:
    - description: The username of the user to fetch.
      name: username
      required: true
    deprecated: true
    description: Returns user information data for the username.
    name: get-user-info
    outputs:
    - contextPath: Exabeam.User.RiskScore
      description: The risk score of the user.
      type: Number
    - contextPath: Exabeam.User.AverageRiskScore
      description: The average risk score.
      type: Number
    - contextPath: Exabeam.User.PeerGroupFieldName
      description: The field name of the peer group.
      type: String
    - contextPath: Exabeam.User.FirstSeen
      description: The date when the user was first seen.
      type: Date
    - contextPath: Exabeam.User.PeerGroupDisplayName
      description: The display name of the Peer group.
      type: String
    - contextPath: Exabeam.User.LastSeen
      description: The date the user was last seen.
      type: Date
    - contextPath: Exabeam.User.PeerGroupFieldValue
      description: The field value of the peer group.
      type: String
    - contextPath: Exabeam.User.Label
      description: The labels of the user.
      type: String
    - contextPath: Exabeam.User.Username
      description: The name of the user.
      type: String
    - contextPath: Exabeam.User.PeerGroupType
      description: The type of the peer group.
      type: String
    - contextPath: Exabeam.User.LastSessionID
      description: The last session ID of the user.
      type: String
    - contextPath: Exabeam.User.LastActivityType
      description: The last activity type of the user.
      type: String
    - contextPath: Exabeam.User.AccountNames
      description: The account name of the user.
      type: String
  - arguments:
    - description: The username of the user to fetch.
      name: username
      required: true
    description: Returns user information data for the username.
    name: exabeam-get-user-info
    outputs:
    - contextPath: Exabeam.User.RiskScore
      description: The risk score of the user.
      type: Number
    - contextPath: Exabeam.User.AverageRiskScore
      description: The average risk score.
      type: Number
    - contextPath: Exabeam.User.PeerGroupFieldName
      description: The field name of the peer group.
      type: String
    - contextPath: Exabeam.User.FirstSeen
      description: The date when the user was first seen.
      type: Date
    - contextPath: Exabeam.User.PeerGroupDisplayName
      description: The display name of the Peer group.
      type: String
    - contextPath: Exabeam.User.LastSeen
      description: The date the user was last seen.
      type: Date
    - contextPath: Exabeam.User.PeerGroupFieldValue
      description: The field value of the peer group.
      type: String
    - contextPath: Exabeam.User.Label
      description: The labels of the user.
      type: String
    - contextPath: Exabeam.User.Username
      description: The name of the user.
      type: String
    - contextPath: Exabeam.User.PeerGroupType
      description: The type of the peer group.
      type: String
    - contextPath: Exabeam.User.LastSessionID
      description: The last session ID of the user.
      type: String
    - contextPath: Exabeam.User.LastActivityType
      description: The last activity type of the user.
      type: String
    - contextPath: Exabeam.User.AccountNames
      description: The account name of the user.
      type: String
  - arguments: []
    deprecated: true
    description: Returns all labels of the user.
    name: get-user-labels
    outputs:
    - contextPath: Exabeam.UserLabel.Label
      description: The label of the user.
      type: String
  - arguments: []
    description: Returns all labels of the user.
    name: exabeam-get-user-labels
    outputs:
    - contextPath: Exabeam.UserLabel.Label
      description: The label of the user.
      type: String
  - arguments:
    - description: The username for which to fetch data.
      name: username
      required: true
    - description: The Start time of the time range. For example, 2018-08-01T11:50:16).
      name: start_time
    - description: The end time of the time range. For example, 2018-08-01T11:50:16.
      name: end_time
    deprecated: true
    description: Returns sessions for the given username and time range.
    name: get-user-sessions
    outputs:
    - contextPath: Exabeam.User.Session.EndTime
      description: The end time of the session.
      type: Date
    - contextPath: Exabeam.User.Session.InitialRiskScore
      description: The initial risk score of the session.
      type: Number
    - contextPath: Exabeam.User.Session.Label
      description: The label of the session.
      type: String
    - contextPath: Exabeam.User.Session.LoginHost
      description: The login host.
      type: String
    - contextPath: Exabeam.User.Session.RiskScore
      description: The risk score of the session.
      type: Number
    - contextPath: Exabeam.User.Session.SessionID
      description: The ID of the session.
      type: String
    - contextPath: Exabeam.User.Session.StartTime
      description: The start time of the session.
      type: Date
    - contextPath: Exabeam.User.Username
      description: The username of the session.
      type: String
  - arguments:
    - description: The username for which to fetch data.
      name: username
      required: true
    - description: The Start time of the time range. For example, 2018-08-01T11:50:16).
      name: start_time
    - description: The end time of the time range. For example, 2018-08-01T11:50:16.
      name: end_time
    description: Returns sessions for the given username and time range.
    name: exabeam-get-user-sessions
    outputs:
    - contextPath: Exabeam.User.Session.EndTime
      description: The end time of the session.
      type: Date
    - contextPath: Exabeam.User.Session.InitialRiskScore
      description: The initial risk score of the session.
      type: Number
    - contextPath: Exabeam.User.Session.Label
      description: The label of the session.
      type: String
    - contextPath: Exabeam.User.Session.LoginHost
      description: The login host.
      type: String
    - contextPath: Exabeam.User.Session.RiskScore
      description: The risk score of the session.
      type: Number
    - contextPath: Exabeam.User.Session.SessionID
      description: The ID of the session.
      type: String
    - contextPath: Exabeam.User.Session.StartTime
      description: The start time of the session.
      type: Date
    - contextPath: Exabeam.User.Username
      description: The username of the session.
      type: String
  - arguments:
    - description: The watchlist ID.
      name: watchlist_id
      required: true
    description: Deletes a watchlist.
    name: exabeam-delete-watchlist
  - arguments:
    - description: The name of the asset.
      name: asset_name
      required: true
    description: Returns asset data.
    name: exabeam-get-asset-data
    outputs:
    - contextPath: Exabeam.Asset.HostName
      description: The host name of the asset.
      type: String
    - contextPath: Exabeam.Asset.IPAddress
      description: The IP address of the asset.
      type: String
    - contextPath: Exabeam.Asset.AssetType
      description: Thr type of the asset.
      type: String
    - contextPath: Exabeam.Asset.FirstSeen
      description: The date the asset was first seen.
      type: Date
    - contextPath: Exabeam.Asset.LastSeen
      description: The date the asset was last seen.
      type: String
  dockerimage: demisto/python3:3.7.4.1900
  runonce: false
  script: |2



    from typing import Tuple, Dict, List, Any, Optional
    import requests

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()


    def convert_unix_to_date(timestamp):
        """Convert unix timestamp to datetime in iso format.

        Args:
            timestamp: the date in unix to convert.

        Returns:
            converted date.
        """
        return datetime.fromtimestamp(int(timestamp) / 1000).isoformat()


    class Client(BaseClient):
        """
        Client to use in the Exabeam integration. Overrides BaseClient
        """
        def __init__(self, base_url: str, username: str, password: str, verify: bool,
                     proxy: bool, headers):
            super().__init__(base_url=f'{base_url}', headers=headers, verify=verify, proxy=proxy)
            self.username = username
            self.password = password
            self.session = requests.Session()
            self.session.headers = headers
            self._login()

        def __del__(self):
            self._logout()

        def http_request(self, method: str, url_suffix: str = None, full_url: str = None, params: dict = None,
                         data: dict = None, resp_type: str = 'json'):
            """
            Generic request to Exabeam
            """
            full_url = full_url if full_url else f'{self._base_url}{url_suffix}'
            try:
                res = self.session.request(
                    method,
                    full_url,
                    headers=self._headers,
                    verify=self._verify,
                    data=data,
                    params=params
                )
                if not res.ok:
                    raise ValueError(f'Error in API call to Exabeam {res.status_code}. Reason: {res.text}')

                try:
                    if resp_type == 'json':
                        return res.json()
                    return res.text
                except Exception:
                    raise ValueError(
                        f'Failed to parse http response to JSON format. Original response body: \n{res.text}')

            except requests.exceptions.ConnectTimeout as exception:
                err_msg = 'Connection Timeout Error - potential reasons might be that the Server URL parameter' \
                          ' is incorrect or that the Server is not accessible from your host.'
                raise DemistoException(err_msg, exception)

            except requests.exceptions.SSLError as exception:
                err_msg = 'SSL Certificate Verification Failed - try selecting \'Trust any certificate\' checkbox in' \
                          ' the integration configuration.'
                raise DemistoException(err_msg, exception)

            except requests.exceptions.ProxyError as exception:
                err_msg = 'Proxy Error - if the \'Use system proxy\' checkbox in the integration configuration is' \
                          ' selected, try clearing the checkbox.'
                raise DemistoException(err_msg, exception)

            except requests.exceptions.ConnectionError as exception:
                # Get originating Exception in Exception chain
                error_class = str(exception.__class__)
                err_type = '<' + error_class[error_class.find('\'') + 1: error_class.rfind('\'')] + '>'
                err_msg = f'\nError Type: {err_type}\nError Number: [{exception.errno}]\nMessage: {exception.strerror}\n ' \
                          f'Verify that the server URL parameter ' \
                          f'is correct and that you have access to the server from your host.'
                raise DemistoException(err_msg, exception)

            except Exception as exception:
                raise Exception(str(exception))

        def _login(self):
            """
            Login using the credentials and store the cookie
            """
            self.http_request('POST', full_url=f'{self._base_url}/api/auth/login', data={
                'username': self.username,
                'password': self.password
            })

        def _logout(self):
            """
            Logout from the session
            """
            try:
                self.http_request('GET', self.http_request('GET', f'{self._base_url}/api/auth/logout'))
            except Exception as err:
                demisto.debug(f'An error occurred during the logout.\n{str(err)}')

        def test_module_request(self):
            """
            Performs basic get request to check if the server is reachable.
            """
            self.http_request('GET', '/uba/api/ping', resp_type='text')

        def get_notable_users_request(self, api_unit: str = None, num: str = None, limit: int = None) -> Dict:
            """
            Args:
                api_unit:
                num: num of notable users
                limit: limit of notable users

            Returns:
                notable users
            """
            params = {
                'unit': api_unit,
                'num': num,
                'numberOfResults': limit
            }
            response = self.http_request('GET', url_suffix='/uba/api/users/notable', params=params)
            return response

        def get_user_info_request(self, username: str) -> Dict:
            """
            Args:
                username: the username

            Returns:
                the user info
            """
            response = self.http_request('GET', url_suffix=f'/uba/api/user/{username}/info')
            return response

        def get_peer_groups_request(self) -> Dict:
            """
            Returns:
                peer groups
            """
            response = self.http_request('GET', url_suffix='/uba/api/peerGroup')
            return response

        def get_user_labels_request(self) -> Dict:
            """
            Returns:
                user labels
            """
            response = self.http_request('GET', url_suffix='/uba/api/userLabel')
            return response

        def user_sequence_request(self, username: str = None, parse_start_time=None, parse_end_time=None) -> Dict:
            """
            Args:
                username:
                parse_start_time: start time
                parse_end_time: end time

            Returns:
                user sequence relevant to the time period
            """
            params = {
                'username': username,
                'startTime': parse_start_time,
                'endTime': parse_end_time
            }
            response = self.http_request('GET', url_suffix=f'/uba/api/user/{username}/sequences', params=params)
            return response

        def get_watchlist_request(self):
            """
            Returns:
                a watchlist
            """
            response = self.http_request('GET', url_suffix='/uba/api/watchlist')
            return response

        def delete_watchlist_request(self, watchlist_id: str = None):
            """
            Args:
                watchlist_id: watchlist id

            """
            self.http_request('DELETE', url_suffix=f'/uba/api/watchlist/{watchlist_id}/')

        def get_asset_data_request(self, asset_name: str = None) -> Dict:
            """

            Args:
                asset_name: asset name

            Returns:
                asset data
            """
            response = self.http_request('GET', url_suffix=f'/uba/api/asset/{asset_name}/data')
            return response


    def test_module(client: Client, *_):
        """test function

        Args:
            client:
            *_:

        Returns:
            ok if successful
        """
        client.test_module_request()
        demisto.results('ok')
        return '', None, None


    def contents_append_notable_user_info(contents, user, user_, user_info) -> List[Any]:
        """Appends a dictionary of data to the base list

        Args:
            contents: base list
            user: user object
            user_: user object
            user_info: user info object

        Returns:
            A contents list with the relevant notable user data
        """
        contents.append({
            'UserName': user_.get('username'),
            'RiskScore': round(user_info.get('riskScore')) if 'riskScore' in user_info else None,
            'FirstSeen': convert_unix_to_date(user_.get('firstSeen')) if 'firstSeen' in user_ else None,
            'LastSeen': convert_unix_to_date(user_.get('lastSeen')) if 'lastSeen' in user_ else None,
            'LastActivity': user_.get('lastActivityType'),
            'Labels': user_.get('labels'),
            'UserFullName': user.get('userFullName'),
            'Location': user_info.get('location'),
            'NotableSessionIds': user.get('notableSessionIds'),
            'NotableUser': True,
            'HighestRiskSession': user.get('highestRiskSession'),
            'EmployeeType': user_info.get('employeeType'),
            'Department': user_info.get('department'),
            'Title': user_info.get('title')
        })
        return contents


    def get_notable_users(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """ Get notable users in a period of time

        Args:
            client: Client
            args: Dict

        """
        limit: int = args.get('limit', 10)
        time_period: str = args.get('time_period', '')
        time_ = time_period.split(' ')
        if not len(time_) == 2:
            raise Exception('Got invalid time period. Enter the time period number and unit.')
        num: str = time_[0]
        unit: str = time_[1]
        api_unit = unit[0]
        if api_unit == 'm':
            api_unit = api_unit.upper()

        if api_unit not in {'d', 'y', 'M', 'h'}:
            raise Exception('The time unit is incorrect - can be hours, days, months, years.')

        contents: list = []
        headers = ['UserName', 'UserFullName', 'Title', 'Department', 'RiskScore', 'Labels', 'NotableSessionIds',
                   'EmployeeType', 'FirstSeen', 'LastSeen', 'LastActivity', 'Location']
        raw_users = client.get_notable_users_request(api_unit, num, limit)
        users = raw_users.get('users', [])
        if not users:
            return 'No users were found in this period of time.', {}, {}

        for user in users:
            user_ = user.get('user', {})
            user_info = user_.get('info', {})
            contents = contents_append_notable_user_info(contents, user, user_, user_info)

        entry_context = {'Exabeam.User(val.UserName && val.UserName === obj.UserName)': contents}
        human_readable = tableToMarkdown('Exabeam Notable Users:', contents, headers=headers, removeNull=True)

        return human_readable, entry_context, raw_users


    def contents_user_info(user, user_info) -> Dict:
        """create a content obj for the user

        Args:
            user: user object
            user_info: user info object

        Returns:
            A contents dict with the relevant user data
        """
        contents = {
            'Username': user.get('username'),
            'RiskScore': round(user_info.get('riskScore')) if 'riskScore' in user_info else None,
            'AverageRiskScore': user_info.get('averageRiskScore'),
            'LastSessionID': user_info.get('lastSessionId'),
            'FirstSeen': convert_unix_to_date(user_info.get('firstSeen')) if 'firstSeen' in user_info else None,
            'LastSeen': convert_unix_to_date(user_info.get('lastSeen')) if 'lastSeen' in user_info else None,
            'LastActivityType': user_info.get('lastActivityType'),
            'Label': user_info.get('labels'),
            'AccountNames': user.get('accountNames'),
            'PeerGroupFieldName': user.get('peerGroupFieldName'),
            'PeerGroupFieldValue': user.get('peerGroupFieldValue'),
            'PeerGroupDisplayName': user.get('peerGroupDisplayName'),
            'PeerGroupType': user.get('peerGroupType')
        }
        return contents


    def get_user_info(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Returns User info data for the given username
        Args:
            client: Client
            args: Dict

        """
        username: str = args.get('username', '')
        headers = ['Username', 'RiskScore', 'AverageRiskScore', 'LastSessionID', 'Labels', 'FirstSeen',
                   'LastSeen', 'LastActivityType', 'AccountNames', 'PeerGroupFieldName', 'PeerGroupFieldValue',
                   'PeerGroupDisplayName', 'PeerGroupType']
        user = client.get_user_info_request(username)
        user_info = user.get('userInfo', {})
        if not user_info:
            raise Exception('User has no info. Please check that the username and not the userFullName was inserted.')
        contents = contents_user_info(user, user_info)
        context = {'Exabeam.User(val.UserName && val.UserName === obj.UserName)': contents}

        if not user_info.get('firstSeen'):
            return f'The user {username} was not found', {}, {}

        human_readable = tableToMarkdown(f'User {username} information:', contents, headers, removeNull=True)
        return human_readable, context, user


    def get_user_sessions(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Returns sessions for the given username and time range

        Args:
            client: Client
            args: Dict

        """
        username = args.get('username')
        start_time = args.get('start_time', datetime.now() - timedelta(days=30))
        end_time = args.get('end_time', datetime.now())
        parse_start_time = date_to_timestamp(start_time)
        parse_end_time = date_to_timestamp(end_time)
        contents = []
        headers = ['SessionID', 'RiskScore', 'InitialRiskScore', 'StartTime', 'EndTime', 'LoginHost', 'Label']

        user = client.user_sequence_request(username, parse_start_time, parse_end_time)
        session = user.get('sessions')
        if not session:
            return f'The user {username} has no sessions in this time frame.', {}, {}

        for session_ in session:
            contents.append({
                'SessionID': session_.get('sessionId'),
                'StartTime': convert_unix_to_date(session_.get('startTime')),
                'EndTime': convert_unix_to_date(session_.get('endTime')),
                'InitialRiskScore': session_.get('initialRiskScore'),
                'RiskScore': round(session_.get('riskScore')),
                'LoginHost': session_.get('loginHost'),
                'Label': session_.get('label')
            })

        entry_context = {
            'Exabeam.User(val.SessionID && val.SessionID === obj.SessionID)': {
                'Username': username,
                'Session': contents
            }
        }
        human_readable = tableToMarkdown(f'User {username} sessions information:', contents, headers, removeNull=True)

        return human_readable, entry_context, user


    def get_peer_groups(client: Client, *_) -> Tuple[str, Dict, Dict]:
        """Returns all peer groups

        Args:
            client: Client

        """
        groups = client.get_peer_groups_request()
        contents = []
        for group in groups:
            contents.append({'Name': group})

        entry_context = {'Exabeam.PeerGroup(val.Name && val.Name === obj.Name)': contents}
        human_readable = tableToMarkdown('Exabeam Peer Groups:', contents)

        return human_readable, entry_context, groups


    def get_user_labels(client: Client, *_) -> Tuple[str, Dict, Dict]:
        """ Returns all user Labels

        Args:
            client: Client

        """
        labels = client.get_user_labels_request()
        contents = []
        for label in labels:
            contents.append({'Label': label})

        entry_context = {'Exabeam.UserLabel(val.Label && val.Label === obj.Label)': contents}
        human_readable = tableToMarkdown('Exabeam User Labels:', contents)

        return human_readable, entry_context, labels


    def get_watchlist(client: Client, *_) -> Tuple[str, Dict, Dict]:
        """  Returns all watchlist ids and titles.

        Args:
            client: Client

        """

        watchlist = client.get_watchlist_request()
        contents = []
        for list_ in watchlist:
            contents.append({
                'WatchlistID': list_.get('watchlistId'),
                'Title': list_.get('title'),
                'Category': list_.get('category')
            })

        entry_context = {'Exabeam.Watchlist(val.WatchlistID && val.WatchlistID === obj.WatchlistID)': contents}
        human_readable = tableToMarkdown('Exabeam Watchlists:', contents, headers=['WatchlistID', 'Title', 'Category'])

        return human_readable, entry_context, watchlist


    def delete_watchlist(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Delete a watchlist

        Args:
            client: Client
            args: Dict

        """

        watchlist_id = args.get('watchlist_id')
        client.delete_watchlist_request(watchlist_id)

        return f'The watchlist {watchlist_id} was deleted successfully.', {}, {}


    def contents_asset_data(asset_data) -> Dict:
        """create a content obj for the asset

        Args:
            asset_data: asset data
        Returns:
            A contents dict with the relevant asset data
        """
        contents = {
            'HostName': asset_data.get('hostName'),
            'IPAddress': asset_data.get('ipAddress'),
            'AssetType': asset_data.get('assetType'),
            'FirstSeen': convert_unix_to_date(asset_data.get('firstSeen')),
            'LastSeen': convert_unix_to_date(asset_data.get('lastSeen')),
            'Labels': asset_data.get('labels')
        }
        return contents


    def get_asset_data(client: Client, args: Dict) -> Tuple[Any, Dict[str, Dict[Any, Any]], Optional[Any]]:
        """  Return asset data for given asset ID (hostname or IP address)

        Args:
            client: Client
            args: Dict

        """
        asset_name = args.get('asset_name')
        asset_raw_data = client.get_asset_data_request(asset_name)

        if not asset_raw_data or 'asset' not in asset_raw_data:
            raise Exception(f'The asset {asset_name} has no data. Please verify that the asset name is valid.')

        asset_data = asset_raw_data.get('asset')
        contents = contents_asset_data(asset_data)
        entry_context = {'Exabeam.Asset(val.IPAddress && val.IPAddress === obj.IPAddress)': contents}
        human_readable = tableToMarkdown('Exabeam Asset Data:', contents, removeNull=True)

        return human_readable, entry_context, asset_raw_data


    def main():
        """
        PARSE AND VALIDATE INTEGRATION PARAMS
        """
        username = demisto.params().get('credentials').get('identifier')
        password = demisto.params().get('credentials').get('password')
        base_url = demisto.params().get('url')
        verify_certificate = not demisto.params().get('insecure', False)
        headers = {'Accept': 'application/json'}
        proxy = demisto.params().get('proxy', False)

        commands = {
            'test-module': test_module,
            'get-notable-users': get_notable_users,
            'exabeam-get-notable-users': get_notable_users,
            'get-peer-groups': get_peer_groups,
            'exabeam-get-peer-groups': get_peer_groups,
            'get-user-info': get_user_info,
            'exabeam-get-user-info': get_user_info,
            'get-user-labels': get_user_labels,
            'exabeam-get-user-labels': get_user_labels,
            'get-user-sessions': get_user_sessions,
            'exabeam-get-user-sessions': get_user_sessions,
            'get-watchlists': get_watchlist,
            'exabeam-get-watchlists': get_watchlist,
            'exabeam-delete-watchlist': delete_watchlist,
            'exabeam-get-asset-data': get_asset_data
        }

        try:
            client = Client(base_url.rstrip('/'), verify=verify_certificate, username=username,
                            password=password, proxy=proxy, headers=headers)
            command = demisto.command()
            LOG(f'Command being called is {command}.')
            if command in commands:
                return_outputs(*commands[command](client, demisto.args()))  # type: ignore
            else:
                raise NotImplementedError(f'Command "{command}" is not implemented.')

        except Exception as err:
            return_error(str(err))


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
