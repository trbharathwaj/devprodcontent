category: Analytics & SIEM
commonfields:
  id: FireEyeHelix
  version: -1
configuration:
- defaultvalue: https://apps.fireeye.com
  display: Server URL (e.g. https://apps.fireeye.com)
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: Customer ID
  name: h_id
  required: true
  type: 0
- defaultvalue: ""
  display: API Token
  name: token
  required: true
  type: 4
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days, 3
    months, 1 year)
  name: fetch_time
  required: false
  type: 0
- defaultvalue: ""
  display: Fetch incidents query
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: FireEye Helix is a security operations platform. FireEye Helix integrates
  security tools and augments them with next-generation SIEM, orchestration and threat
  intelligence tools such as alert management, search, analysis, investigations and
  reporting.
detaileddescription: "In order to configure this integration you will a FireEye customer
  ID. Your customer ID is used in your FireEye Helix  available in the URL of your
  FireEye Helix app after */helix/id/*. e.g. for the following URL *https://apps.fireeye.com/helix/id/**helixid***
  the customer ID is helixid.  \n\nThe API key can be found and generated in the API
  KEYS section. You can navigate to it from your FireEye Helix app home page by clicking
  on the user icon on the top right, and choosing HELIX Settings. You'll be redirected
  to the HELIX Settings page, where API KEYS can be found.\n"
display: FireEye Helix
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADKFJREFUeAHtWntwVcUZ38c55948bgISiORFsAGBm4SHYBWnxQd1Oo5o61C1TuvoPzpKRQKooK2mUtRCgAAVWh06Ustoy3TG2s4UQQsDvlpAQpILoUASwqNAeCUhN/dxzm5/e/Hgzc29IcGBP+zuzM2es/vtt7u/77l7QoguGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI/BNRIBezqYkudVoKDg92jHEBOnQ6ymTQUHZtrLmuq1gKC+Hpx5zZRDol4B355cXmNx5SBJ6vySyzKTMUgzUzyEyFKZk3tjm+uWfFtycZlknrImNjW1XZtmaa18R6JOAPy8pycqIeCsYJU9YhObaMFJbQsRxs3BCYcxyj+W1b+aO4w1GvDMMn3zFHwhE4sj041VGwLjUfLuK/eOsCH3DonRSBELtIiI2RGkGhEog9JgFM1QOIUWhqHeo2WEfo145xe4kTSBbe6k5dP+VQwBySV3qikq/Z0n6gUHJpC4pCIUwvZQRCFsNCkHUTVEiPg9L+UGXoBukkJ9YMhLuMs8KWHc7E3ROYLA/M/UM/1c9tLKysle8k6EhpVRgxwBP1n+ptpQDdxeNuQMx9i8gyFZEym4htQYIbhMjcqvDWL3liRwdtW9fR+IknxYUpGXzAa9nEPZABxOPljXV/zmRxn0HP/7FMP+UNMkeF0QMxzzd1qReQINGcdxMM2eO2lfbtJkQI7uwdJzJ5POOKReMO7Bnl+IXKPBfIyhZZDA6NgpvE19iTCURnNFWPP++M8fzt4k7d0Zri4oGmsQ3XVL6mAo7qQrDCjglh2xClpYdqv/0qaeeLTAsOoMyPtWx0ZqiMK6CF/mXYPY7VPAykN2Efa6rrvr1h5SiJ0mBIhjnOoJ3Y8b7qBQfOg5pZCZ7GKTjBV5SFQbDQ+DcB0Gtrq5e/ImiS+qia4rG+A3K1nkIzYblYu9kAyT8WyfCPxp7orYz1QTx7ZgqhHcLhv8gdrEeoPbYzGbMv6fQf5eXsHeAQoMjyC7MpXTpYnEFjMFnBTMVT+KDvDMpGehQeguLkoEucUcwbGdmevajGzy6T6fesCbuSFpoULnScyo8HG3L9nT5ok6ac5wTE0rSfYzLV9VQaoQkdryTky8VmocBfjPWHVOueNr459hKuDwowuQk53Ib3ODtnPGXZs2dp6z5g3ha9aysHML9ASN8HhZcIwX9mFLhQSzcT+3U61NjhYqTghymlLWrd1Viin3h8cLf3bnlGczjbPExPrFTiK2w2oVlh+s3xtNc6llZcBbJrvZw9liXlEcjhpw8sTHQkjiuIed6XyTd+AhxPNzutN05+ciRrkSaZO87CDHTi8qmRKlYB619oKy5fksyumRtas5ourkAG78FBvsg9nYwGd2Vaps5c26p4bFeJELkwtv8srrqtX+6cyl3PGvOc9M45S9AlAFY4q+WLXut0e2/nLpHTGAe8YKHspLz0pnRNdgztb/CVYsoxA+Lz1T6ZsLSLMHGq/bEAiuKwmrWUGnM76twE3n09/38qX0hWOIXUCqLSTmov+O/Lv2KFVX1Ihp9BZH1LJP0+YqKZ77j8qyYO+/7nBrPAZP9ERl+7esKV/Ht5qJr8keNhA8fcV7KWya0BPaQQ+7U/avPRKOMWSRHHaQ4pTwqRTk4/DWRy3DSHCIt5Hdu+/6SEo/7nKwuOXAgAsvr1U/tuOEGM7utrYfiKn6toRDLMHJyHWnfK6Rstb1Wk2oHQ36gpMSAb++1DPN45JhAwMYaVBhRSRM/ffo073UQOsPhsMjLy3NAr8YRxMeap5+es5CZnpcoM1+YOXP2y5xb6QhP82HFR+xI9JXXVy79j8tXue1jQ4dyT3190n25dKpOnKubgIVFwzTIH5mAOFs3rHQydn5dWUv9H+MZ9OW508zxZFFSoNIB7B7hiymjTlqUuzWLy6cbQjwVisgCgA38ehYoy7G91437CWmsSSmHvfmjBtmnQr9xiHcSkiwrnhee7SxqRWxhD8CaDguDzZtwYFdrbVHZwL1SPEQi5Ol85AwAOen8sSQrSg7uHuZfQA4FNs+ePbvgXEdojuX13WXbdkrFZJwR08r85GxHaBl2td3d2fLlS7bPmjV3IWHsRW561iD/o0LQeuJEF65cuWSPS6fq9vbgjZmdzT+TVsbNQohuMouno5gr3UgPgH4x2jervm7EE5r2HlKN2MSTJqFVNhV2IM+/1X+sZ/xUdMlKJQTqIxSCkkUOghwyT4iMpiejvRBLSx9EXrUGeehGuK1/4JZM5Qo9Cq5D20OMnuvREdcgItyUhiy2JT0rKH3vKz4yDQKa7GFsYliI1abDV45pqT2ihspw0BSe9CGcyjQq5To0nY9jGfcokecYp5AxH1aNts29xBT5OArilEjeRkIMHUpSsCnBZRO3+fHE3urqqs9mzZq3GNl4JURxPhyNLlq5vKo2kQ5WnYV4nA+DO0AYErWYH0ikAsyOJA6jx6mgsTUqim4CVg21haO/a0i6wsGyLJx5Q4Z4Gc2PqL6+lLvJDZyx0E3IwjPDSKGVQX6ZUfcYnplzvRep6AwuyIaylsA9PQgup0GSKOL/9rGH6hfGD9+d+60hYcv7lmR06IijF4Sr+pGJQzBSOsiIDR9dhJu3M/Hjen2WMiKks2tF9aIFvdL13tlo285BINVJbN6UihSWG4TRbFyxdPHyVDTJ2r9S8ou9bKIHcVO51xAEZFL6cG2h/5GL3Zd6yPuvKQSZ5pJhAoQ72eq+x9fnLenhkgwSktXEt3+dZ0gLXlZFhu4leuIgrJotxdFmamBY+e1uL79wkQDrpLSzk1hue19qDIF2xC4ikuDYFw6xxSKESa5+jMGiUhe1L9WvfGKfSw+GaNiGo41KJGIFxyRqMLK8tqBsyqW4VmIBXjpwBOVkChKrGDnwg7ekKeMmiCCT/i06xriffyYSEsWQnVjV+4I4T+4uL89QLAzTi73KLoPQNJzHB/SVrRDASCJnYWxgRUVFyhjcV3690Qm4RPRjKjbgViR2vdEm9vVw0aWHA9tri0rXpFP2eBBCwlci+HGaxZl8t6bAf++4I4F/JzJx36cUF1uIAz+1CPepO2ulJCEiIoLw3i4DoJkxK3DZ9Ll2lTBhgGpO2lXWUtcWyPevloyspe3Oj0D31skjgfYhReU7cLv0KBK9qtriMW/i+NIOD9aNhwGnQG0S7PBF9n+7oeE0PGYr4QO2MSEWIJgtmVnxzPvwHWG8dx9nGMSm7AyJBpurq6tT5BDIEBhU74JNJGxHHTWdBpubDbDy6ePbQkfLZz97EPMow+heMBcygY50iza++uqrp1VnDwtWjUEr9CyseFPalx5DXeHh3Hitxcl7tUWjpyqaxFIJXtfa3hG49nr0QuyFn8QVDHKP+gyzs1tW6I7NQOaEVUYApbKufpUorpCw+JCq3YHqig3qHUaukfTuEMgLGiEHVTIHPH/8ReH4vNtUvhQmn+Pz2M/haQqZZOtx27UJer0x/iek2MgNscYb4pPUfKtWrTofFOH3pRBLoQvTkGn8HSvZhP0jWfzqh0RzIzD4NcTkd9cZX3Nu4K5Q4kqf4NtM8kvCqqqqk1jvaqznQ4SEJVCHDfFzuM+Q7kYgurqrS9zoztFN29xGVe8qHjfAFNE3kWhNj8CSlXIZytYkCQLTX5w8NHjFbWTLRSB35I3MsQzzXSjFHerDhCpplHcFqfPE2ObA2lhDwh9cUPPRhaXFUY/Zro4sCd29vgYGD86M+PKHsk5xzL0+3YwlZg8fne+RmWF/8/YeWavL8OOcHN9Ab24uyR583B/YcjFr3pGXl+7h1wyF2ieNxV5BIpGsnBPxY9QZ9dy5c1mMpQ0RwkniPi3i8UQ7z6alnXqjsjLorsGtMd46dSqYk5aGLK95Uuv69fer9CdpAa1x7GxXns9g6Y7jJJWdbYiQyMxsXVVZGdtXUiKX+2b858agota5OOo8b+L0oyxTDUDiBYVXHx3o/NEtdTsVfd2Q4bnSk77UZGQabop8sJJoyJF/MLLkk/qbsIvo1a97FbC7nNg3YUHnIx+6BxbtVXEZwoUflG1wS2ujjK4ub65rqISbvi9v5EjDssaCoq1rkPmR+mLj8tH11UegTwJ2l1VXUFrOGPkh4sCdCHxj8FluQDoiYQdxQpD5uzhdvd3mnPnsat0ru+vSdWoE+iXgeDb78f9ZjkFGOsQuFoRdx6icSh22CUnPn8Yerq2Pp9XPGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0AhoBDQCGgGNgEZAI6AR0Ah8cxH4H9aAFXVhrGASAAAAAElFTkSuQmCC
name: FireEyeHelix
script:
  commands:
  - arguments:
    - description: Maximum number of results to return per page.
      name: page_size
    - description: The initial index from which to return the results.
      name: offset
    - description: Output values to display in the command result (comma separated
        values (no spaces) as they appear in the context. e.g. ID,Name,Hostname).
      isArray: true
      name: headers
    description: Returns all alerts.
    name: fireeye-helix-list-alerts
    outputs:
    - contextPath: FireEyeHelix.Alert.ID
      description: Primary ID of the alert.
      type: Number
    - contextPath: FireEyeHelix.Alert.AlertTypeID
      description: ID of the alert type.
      type: Number
    - contextPath: FireEyeHelix.Alert.AlertTypeName
      description: Name of the alert type.
      type: String
    - contextPath: FireEyeHelix.Alert.AssigneeID
      description: ID of the assignee.
      type: String
    - contextPath: FireEyeHelix.Alert.AssigneeName
      description: Assignee display name.
      type: String
    - contextPath: FireEyeHelix.Alert.CreatorID
      description: ID of the user who created the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.CreatorName
      description: Name of the user who created the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.UpdaterID
      description: ID of the user who updated the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.UpdaterName
      description: Name of the user who updated the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.CreatedTime
      description: Time the alert was created.
      type: Date
    - contextPath: FireEyeHelix.Alert.ModifiedTime
      description: Time the alert was modified.
      type: Date
    - contextPath: FireEyeHelix.Alert.ProcessPath
      description: Path of the process.
      type: String
    - contextPath: FireEyeHelix.Alert.Confidence
      description: FireEye Helix confidence with the result.
      type: String
    - contextPath: FireEyeHelix.Alert.SHA1
      description: SHA1 hash of the file.
      type: String
    - contextPath: FireEyeHelix.Alert.MD5
      description: MD5 hash of the file.
      type: String
    - contextPath: FireEyeHelix.Alert.Hostname
      description: Hostname of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.PID
      description: Process ID.
      type: Number
    - contextPath: FireEyeHelix.Alert.Size
      description: Size of the process in bytes.
      type: Number
    - contextPath: FireEyeHelix.Alert.Virues
      description: Virus name.
      type: String
    - contextPath: FireEyeHelix.Alert.Result
      description: Result of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.MalwareType
      description: Malware type.
      type: String
    - contextPath: FireEyeHelix.Alert.Filename
      description: Name of the file that contains the virus.
      type: String
    - contextPath: FireEyeHelix.Alert.RegPath
      description: Registry key path.
      type: String
    - contextPath: FireEyeHelix.Alert.EventTime
      description: Time of the event.
      type: Date
    - contextPath: FireEyeHelix.Alert.IOCNames
      description: Indicator of Compromise names.
      type: String
    - contextPath: FireEyeHelix.Alert.Process
      description: Name of the process that created the event.
      type: String
    - contextPath: FireEyeHelix.Alert.ParentProcess
      description: Name of the parent process of the process that created the event.
      type: String
    - contextPath: FireEyeHelix.Alert.SourceIPv4
      description: Source IP address of the event (IPv4).
      type: String
    - contextPath: FireEyeHelix.Alert.SourceIPv6
      description: Source IP address of the event (IPv6).
      type: String
    - contextPath: FireEyeHelix.Alert.DestinationIPv4
      description: Destination IP address of the event (IPv4).
      type: String
    - contextPath: FireEyeHelix.Alert.DestinationIPv6
      description: Destination IP address of the event (IPv6).
      type: String
    - contextPath: FireEyeHelix.Alert.DestinationPort
      description: Destination port of the event.
      type: String
    - contextPath: FireEyeHelix.Alert.URI
      description: URI address that created the event.
      type: String
    - contextPath: FireEyeHelix.Alert.HttpMethod
      description: HTTP method of the request that was called.
      type: String
    - contextPath: FireEyeHelix.Alert.Domain
      description: Domain of the URI that created the event.
      type: String
    - contextPath: FireEyeHelix.Alert.UserAgent
      description: User agent related to the event.
      type: String
    - contextPath: FireEyeHelix.Alert.EventsCount
      description: Number of events in the alert.
      type: Number
    - contextPath: FireEyeHelix.Alert.NotesCount
      description: Number of notes in the alert.
      type: Number
    - contextPath: FireEyeHelix.Alert.ClosedState
      description: Status of the alert in regards to it being closed.
      type: String
    - contextPath: FireEyeHelix.Alert.ClosedReason
      description: Reason the alert was closed.
      type: String
    - contextPath: FireEyeHelix.Alert.Confidence
      description: Helix confidence level of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Description
      description: Description of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.FirstEventTime
      description: Time that the first event occurred.
      type: Date
    - contextPath: FireEyeHelix.Alert.LastEventTime
      description: Time that the last event occurred.
      type: Date
    - contextPath: FireEyeHelix.Alert.ExternalIP
      description: External IP addresses for the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.InternalIP
      description: Internal IP addresses for the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Message
      description: Message of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Products
      description: Source of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Risk
      description: Risk of the events in the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Severity
      description: Severity of the events in the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.State
      description: State of the alert. Can be "Open", "Suppressed", "Closed", or "Reopened".
      type: String
    - contextPath: FireEyeHelix.Alert.Tag
      description: Tag of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Type
      description: Alert type.
      type: String
    - contextPath: FireEyeHelix.Alert.Count
      description: Number of alerts.
      type: String
  - arguments:
    - default: true
      description: The ID of the alert.
      name: id
      required: true
    - description: A comma-separated list (no spaces) of output values to display
        in the command result, e.g., ID,Name,Hostname.
      isArray: true
      name: headers
    description: Returns alert details, by alert ID.
    name: fireeye-helix-get-alert-by-id
    outputs:
    - contextPath: FireEyeHelix.Alert.ID
      description: Primary ID of the alert.
      type: Number
    - contextPath: FireEyeHelix.Alert.AlertTypeID
      description: ID of the alert type.
      type: Number
    - contextPath: FireEyeHelix.Alert.AlertTypeName
      description: Name of the alert type.
      type: String
    - contextPath: FireEyeHelix.Alert.AssigneeID
      description: ID of the alert assignee.
      type: String
    - contextPath: FireEyeHelix.Alert.AssigneeName
      description: Assignee display name.
      type: String
    - contextPath: FireEyeHelix.Alert.CreatorID
      description: ID of the user who created the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.CreatorName
      description: Name of the user who created the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.UpdaterID
      description: Name of the user who updated the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.UpdaterName
      description: Name of the user who updated the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.CreatedTime
      description: Time the alert was created.
      type: Date
    - contextPath: FireEyeHelix.Alert.ModifiedTime
      description: Time the alert was last modified.
      type: Date
    - contextPath: FireEyeHelix.Alert.ProcessPath
      description: Path of the process.
      type: String
    - contextPath: FireEyeHelix.Alert.Confidence
      description: Helix confidence level of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.SHA1
      description: SHA1 hash of the file.
      type: String
    - contextPath: FireEyeHelix.Alert.MD5
      description: MD5 hash of the file.
      type: String
    - contextPath: FireEyeHelix.Alert.Hostname
      description: Hostname of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.PID
      description: Process ID.
      type: Number
    - contextPath: FireEyeHelix.Alert.Size
      description: Size of the process in bytes.
      type: Number
    - contextPath: FireEyeHelix.Alert.Virus
      description: Virus name.
      type: String
    - contextPath: FireEyeHelix.Alert.Result
      description: Result of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.MalwareType
      description: Malware type.
      type: String
    - contextPath: FireEyeHelix.Alert.Filename
      description: Name of the file that contains the virus.
      type: String
    - contextPath: FireEyeHelix.Alert.RegPath
      description: Registry key path.
      type: String
    - contextPath: FireEyeHelix.Alert.EventTime
      description: Time that the event occurred.
      type: Date
    - contextPath: FireEyeHelix.Alert.IOCNames
      description: Indicator of Compromise names.
      type: String
    - contextPath: FireEyeHelix.Alert.Process
      description: Name of the process that created the event.
      type: String
    - contextPath: FireEyeHelix.Alert.ParentProcess
      description: Name of the parent process to the process that created the event.
      type: String
    - contextPath: FireEyeHelix.Alert.SourceIPv4
      description: Source IP address of the event (IPv4).
      type: String
    - contextPath: FireEyeHelix.Alert.SourceIPv6
      description: Source IP address of the event (IPv6).
      type: String
    - contextPath: FireEyeHelix.Alert.DestinationIPv4
      description: Destination IP address of the event (IPv4).
      type: String
    - contextPath: FireEyeHelix.Alert.DestinationIPv6
      description: Destination IP address of the event (IPv6).
      type: String
    - contextPath: FireEyeHelix.Alert.DestinationPort
      description: Destination port of the event.
      type: String
    - contextPath: FireEyeHelix.Alert.URI
      description: URI address that created the event.
      type: String
    - contextPath: FireEyeHelix.Alert.HttpMethod
      description: HTTP method of the request that was called.
      type: String
    - contextPath: FireEyeHelix.Alert.Domain
      description: Domain of the URI that created the event.
      type: String
    - contextPath: FireEyeHelix.Alert.UserAgent
      description: User agent related to the event.
      type: String
    - contextPath: FireEyeHelix.Alert.EventsCount
      description: Number of events in the alert.
      type: Number
    - contextPath: FireEyeHelix.Alert.NotesCount
      description: Number of notes in the alert.
      type: Number
    - contextPath: FireEyeHelix.Alert.ClosedState
      description: State the alert in regards to it being closed.
      type: String
    - contextPath: FireEyeHelix.Alert.ClosedReason
      description: Reason the alert was closed.
      type: String
    - contextPath: FireEyeHelix.Alert.Confidence
      description: Helix confidence level of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Description
      description: Description of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.FirstEventTime
      description: Time that the first event occurred.
      type: Date
    - contextPath: FireEyeHelix.Alert.LastEventTime
      description: Time that the last event occurred.
      type: Date
    - contextPath: FireEyeHelix.Alert.ExternalIP
      description: External IP addresses for the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.InternalIP
      description: Internal IP addresses for the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Message
      description: Message of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Products
      description: Source of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Risk
      description: Risk of the events in the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Severity
      description: Severity of the events in the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.State
      description: State of the alert. Can be "Open", "Suppressed", "Closed", or "Reopened".
      type: String
    - contextPath: FireEyeHelix.Alert.Tag
      description: Tag of the alert.
      type: String
    - contextPath: FireEyeHelix.Alert.Type
      description: Alert type.
      type: String
    - contextPath: FireEyeHelix.Alert.Count
      description: Number of alerts.
      type: String
  - arguments:
    - default: true
      description: ID of the alert for which the note is being created.
      name: alert_id
      required: true
    - description: The note to add to the alert.
      name: note
      required: true
    description: Creates an alert note.
    name: fireeye-helix-alert-create-note
    outputs:
    - contextPath: FireEyeHelix.Note.ID
      description: Note ID.
      type: Number
    - contextPath: FireEyeHelix.Note.CreatedTime
      description: Time the note was created.
      type: Date
    - contextPath: FireEyeHelix.Note.UpdatedTime
      description: Time the note was updated.
      type: Date
    - contextPath: FireEyeHelix.Note.Message
      description: Message of the note.
      type: String
    - contextPath: FireEyeHelix.Note.CreatorID
      description: ID of the note creator.
      type: String
    - contextPath: FireEyeHelix.Note.CreatorName
      description: Name of the note creator.
      type: String
    - contextPath: FireEyeHelix.Note.AlertID
      description: ID of the related alert.
      type: Number
  - arguments:
    - default: true
      description: Alert ID for which to get events.
      name: alert_id
      required: true
    - description: A comma-separated list (no spaces) of output values to display
        in the command result, e.g., ID,Type,SourceIPv4).
      isArray: true
      name: headers
    description: Lists alert events for a specific alert.
    name: fireeye-helix-get-events-by-alert
    outputs:
    - contextPath: FireEyeHelix.Event.ID
      description: Event ID.
      type: String
    - contextPath: FireEyeHelix.Event.Type
      description: Event type.
      type: String
    - contextPath: FireEyeHelix.Event.Result
      description: Event result.
      type: String
    - contextPath: FireEyeHelix.Event.MatchedAt
      description: Time that the event was matched.
      type: Date
    - contextPath: FireEyeHelix.Event.Confidence
      description: Confidence of the event. Can be "low", "medium", or "high".
      type: String
    - contextPath: FireEyeHelix.Event.Status
      description: Status of the event.
      type: String
    - contextPath: FireEyeHelix.Event.EventTime
      description: Time that the event occurred.
      type: Date
    - contextPath: FireEyeHelix.Event.DetectedRuleID
      description: ID of the detected rule.
      type: String
    - contextPath: FireEyeHelix.Event.PID
      description: Process ID.
      type: String
    - contextPath: FireEyeHelix.Event.Process
      description: Process details.
      type: String
    - contextPath: FireEyeHelix.Event.ProcessPath
      description: Process path.
      type: String
    - contextPath: FireEyeHelix.Event.FileName
      description: Name of the file affected by the event.
      type: String
    - contextPath: FireEyeHelix.Event.FilePath
      description: Path of the the file affected by the event.
      type: String
    - contextPath: FireEyeHelix.Event.DeviceName
      description: Device name.
      type: String
    - contextPath: FireEyeHelix.Event.Size
      description: Size of the file (in bytes) that created the event.
      type: String
    - contextPath: FireEyeHelix.Event.Virus
      description: Virus that was detected in the event.
      type: String
    - contextPath: FireEyeHelix.Event.MalwareType
      description: Malware type of the virus that was detected.
      type: String
    - contextPath: FireEyeHelix.Event.CreatedTime
      description: Time that the event was created.
      type: Date
    - contextPath: FireEyeHelix.Event.Class
      description: Event class.
      type: String
    - contextPath: FireEyeHelix.Event.MD5
      description: MD5 hash of the affected file.
      type: String
    - contextPath: FireEyeHelix.Event.SHA1
      description: SHA1 hash of the affected file.
      type: String
    - contextPath: FireEyeHelix.Event.Protocol
      description: Protocol used in the event.
      type: String
    - contextPath: FireEyeHelix.Event.SourceIPv4
      description: IPv4 address of the event source.
      type: String
    - contextPath: FireEyeHelix.Event.SourceIPv6
      description: IPv6 address of the event source.
      type: String
    - contextPath: FireEyeHelix.Event.SourcePort
      description: Port of the event source address.
      type: String
    - contextPath: FireEyeHelix.Event.SourceLongitude
      description: Longitude of the event source address.
      type: String
    - contextPath: FireEyeHelix.Event.SourceLatitude
      description: Latitude of the event source address.
      type: String
    - contextPath: FireEyeHelix.Event.DestinationIPv4
      description: IPv4 address of the event destination.
      type: String
    - contextPath: FireEyeHelix.Event.DestinationIPv6
      description: IPv6 address of the event destination.
      type: String
    - contextPath: FireEyeHelix.Event.DestinationPort
      description: Port of the event destination address.
      type: String
    - contextPath: FireEyeHelix.Event.ReportTime
      description: Time that the event was reported.
      type: Date
    - contextPath: FireEyeHelix.Event.FalsePositive
      description: Whether the event is a false positive.
      type: String
    - contextPath: FireEyeHelix.Event.Domain
      description: Domain of the recipient.
      type: String
    - contextPath: FireEyeHelix.Event.From
      description: Source email address.
      type: String
    - contextPath: FireEyeHelix.Event.SourceDomain
      description: Domain of the host that created the event.
      type: String
    - contextPath: FireEyeHelix.Event.SourceISP
      description: ISP of the source of the event.
      type: String
    - contextPath: FireEyeHelix.Event.DestinationISP
      description: ISP of the destination of the event.
      type: String
    - contextPath: FireEyeHelix.Event.To
      description: Destination email address.
      type: String
    - contextPath: FireEyeHelix.Event.Attachment
      description: Email attachment.
      type: Unknown
    - contextPath: FireEyeHelix.Event.Count
      description: Total number of events.
      type: Number
  - arguments:
    - default: true
      description: ID of an alert.
      name: alert_id
      required: true
    - description: Offset to the result. Default is 0.
      name: offset
    description: Retrieves a specific alert from an helix endpoint.
    name: fireeye-helix-get-endpoints-by-alert
    outputs:
    - contextPath: FireEyeHelix.Endpoint.ID
      description: Endpoint ID.
      type: Number
    - contextPath: FireEyeHelix.Endpoint.CustomerID
      description: Customer ID.
      type: String
    - contextPath: FireEyeHelix.Endpoint.DeviceID
      description: Device ID.
      type: String
    - contextPath: FireEyeHelix.Endpoint.Domain
      description: Domain of the endpoint.
      type: String
    - contextPath: FireEyeHelix.Endpoint.Hostname
      description: Hostname of the endpoint.
      type: String
    - contextPath: FireEyeHelix.Endpoint.MACAddress
      description: MAC address of the endpoint.
      type: String
    - contextPath: FireEyeHelix.Endpoint.OS
      description: Operating system of the endpoint.
      type: String
    - contextPath: FireEyeHelix.Endpoint.IP
      description: IP address of the endpoint.
      type: String
    - contextPath: FireEyeHelix.Endpoint.UpdatedTime
      description: Time the endpoint was last updated.
      type: Date
    - contextPath: FireEyeHelix.Endpoint.ContainmentState
      description: Containment state of the endpoint.
      type: String
    - contextPath: FireEyeHelix.Endpoint.Count
      description: Total number of endpoints.
      type: Number
  - arguments:
    - default: true
      description: ID of an alert.
      name: alert_id
      required: true
    - description: Number of results to return per page.
      name: page_size
    - description: The initial index from which to return the results.
      name: offset
    - description: The field by which to order the results.
      name: order_by
    description: Returns cases of an alert.
    name: fireeye-helix-get-cases-by-alert
    outputs:
    - contextPath: FireEyeHelix.Case.AlertsCount
      description: Number of alerts related to the case.
      type: Number
    - contextPath: FireEyeHelix.Case.AssigneeID
      description: ID of the assignee.
      type: String
    - contextPath: FireEyeHelix.Case.AssigneeName
      description: Name of the assignee.
      type: String
    - contextPath: FireEyeHelix.Case.CreatorID
      description: ID of the case creator.
      type: String
    - contextPath: FireEyeHelix.Case.CreatorName
      description: Name of the case creator.
      type: String
    - contextPath: FireEyeHelix.Case.UpdaterID
      description: ID of the user who last updated the case.
      type: String
    - contextPath: FireEyeHelix.Case.UpdaterName
      description: Name of the user who last updated the case.
      type: String
    - contextPath: FireEyeHelix.Case.CreatedTime
      description: Time that the case was created.
      type: Date
    - contextPath: FireEyeHelix.Case.ModifiedTime
      description: Time that the case was last modified.
      type: Date
    - contextPath: FireEyeHelix.Case.Description
      description: Case description.
      type: String
    - contextPath: FireEyeHelix.Case.EventsCount
      description: Number of events in the case.
      type: Number
    - contextPath: FireEyeHelix.Case.ID
      description: ID of the case.
      type: Number
    - contextPath: FireEyeHelix.Case.InfoLinks
      description: Informational or reference links.
      type: Unknown
    - contextPath: FireEyeHelix.Case.Name
      description: Name of the case.
      type: String
    - contextPath: FireEyeHelix.Case.NotesCount
      description: Number of notes in the case.
      type: Number
    - contextPath: FireEyeHelix.Case.Priority
      description: Provides an indication of the order in which the case should be
        examined as compared to other cases. Priority can be "Critical", "High", "Medium",
        or "Low".
      type: String
    - contextPath: FireEyeHelix.Case.PriorityOrder
      description: Provides an indication of the order in which the case should be
        examined as compared to other cases. Priority order can be "4", "3", "2",
        or "1".
      type: Number
    - contextPath: FireEyeHelix.Case.Severity
      description: The potential impact that the case could have on the organization
        if it is a true positive. It is calculated based on the risk of the alert.
      type: Number
    - contextPath: FireEyeHelix.Case.State
      description: State of the case.
      type: String
    - contextPath: FireEyeHelix.Case.Status
      description: |-
        Cases with the following statuses are considered open: Declared, Scoped, Contained.
        Cases with the following statuses are considered closed: Recovered, Improved.
      type: String
    - contextPath: FireEyeHelix.Case.Tags
      description: Tags of the case.
      type: Unknown
    - contextPath: FireEyeHelix.Case.TotalDaysUnresolved
      description: The number of days the case has been unresolved.
      type: Number
    - contextPath: FireEyeHelix.Case.Count
      description: Total number of cases.
      type: Number
  - arguments:
    - description: Number of results to return per page.
      name: page_size
    - description: The initial index from which to return the results.
      name: offset
    - description: Multiple values may be separated by commas.
      name: usage
    - description: The date that the list was created.
      name: created_at
    - description: Description of the list.
      name: description
    - auto: PREDEFINED
      description: Whether the list is active. Can be "true" or "false".
      name: is_active
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Whether the list is internal. Can be "true" or "false".
      name: is_internal
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Whether the list is protected. Can be "true" or "false".
      name: is_protected
      predefined:
      - "true"
      - "false"
    - description: Name of the list.
      name: name
    - description: Short name of the list.
      name: short_name
    - description: List type.
      name: type
    - description: The time the list was last updated.
      name: updated_at
    - description: The field by which to order the results.
      name: order_by
    description: Returns lists.
    name: fireeye-helix-get-lists
    outputs:
    - contextPath: FireEyeHelix.List.ID
      description: List ID.
      type: Number
    - contextPath: FireEyeHelix.List.Description
      description: List description.
      type: Number
    - contextPath: FireEyeHelix.List.ShortName
      description: Short name of the list.
      type: String
    - contextPath: FireEyeHelix.List.Name
      description: Name of the list.
      type: String
    - contextPath: FireEyeHelix.List.ContentTypes
      description: Content types of the list. Can be Email, FQDN, IPv4, Ipv6, SHA1,
        MD5, or Misc.
      type: String
    - contextPath: FireEyeHelix.List.CreatorID
      description: ID of the creator.
      type: String
    - contextPath: FireEyeHelix.List.CreatorName
      description: Name of the creator.
      type: String
    - contextPath: FireEyeHelix.List.UpdatedByID
      description: ID of the user who last updated the list.
      type: String
    - contextPath: FireEyeHelix.List.CreatedTime
      description: Time that the rule was created.
      type: Date
    - contextPath: FireEyeHelix.List.UpdatedTime
      description: Time that the rule was last updated.
      type: Date
    - contextPath: FireEyeHelix.List.Type
      description: List type. Can be Default, Analytics Whitelist, or Intel Matching.
      type: String
    - contextPath: FireEyeHelix.List.UpdatedByName
      description: User who last updated the list.
      type: String
    - contextPath: FireEyeHelix.List.Internal
      description: Whether the list is internal. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.List.Protected
      description: Whether the list is protected. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.List.Active
      description: Whether the list is active. Can be true or false.
      type: Unknown
    - contextPath: FireEyeHelix.List.Count
      description: Total number of lists.
      type: Number
  - arguments:
    - default: true
      description: ID of the list.
      name: id
      required: true
    description: Returns a specific list by list ID.
    name: fireeye-helix-get-list-by-id
    outputs:
    - contextPath: FireEyeHelix.List.ID
      description: List ID.
      type: Number
    - contextPath: FireEyeHelix.List.Description
      description: List description.
      type: Number
    - contextPath: FireEyeHelix.List.ShortName
      description: Short name of the list.
      type: String
    - contextPath: FireEyeHelix.List.Name
      description: Name of the list.
      type: String
    - contextPath: FireEyeHelix.List.ContentTypes
      description: Content types of the list. Can be Email, FQDN, IPv4, Ipv6, SHA1,
        MD5, or Misc.
      type: String
    - contextPath: FireEyeHelix.List.CreatorID
      description: ID of the creator.
      type: String
    - contextPath: FireEyeHelix.List.CreatorName
      description: Name of the creator.
      type: String
    - contextPath: FireEyeHelix.List.UpdatedByID
      description: ID of the user who last updated the list.
      type: String
    - contextPath: FireEyeHelix.List.CreatedTime
      description: Time that the rule was created.
      type: Date
    - contextPath: FireEyeHelix.List.UpdatedTime
      description: Time that the rule was last updated.
      type: Date
    - contextPath: FireEyeHelix.List.Type
      description: List type. Can be Default, Analytics Whitelist, or Intel Matching.
      type: String
    - contextPath: FireEyeHelix.List.UpdatedByName
      description: Name of the user who last updated the list.
      type: String
    - contextPath: FireEyeHelix.List.Internal
      description: Whether the list is internal. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.List.Protected
      description: Whether the list is protected. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.List.Active
      description: Whether the list is active. Can be true or false.
      type: Unknown
  - arguments:
    - default: true
      description: Name of the list.
      name: name
      required: true
    - description: Short name of the list.
      name: short_name
    - auto: PREDEFINED
      description: Whether the list is internal. Can be true or false.
      name: is_internal
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Whether the list is active. Can be true or false.
      name: is_active
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Whether the list is protected. Can be true or false.
      name: is_protected
      predefined:
      - "true"
      - "false"
    - description: A comma-separated list of list uses.
      isArray: true
      name: usage
    - auto: PREDEFINED
      description: Whether the list is hiddne. Can be true or false.
      name: is_hidden
      predefined:
      - "true"
      - "false"
    - description: List type.
      name: type
    - description: Description of the list.
      name: description
    description: Creates a list.
    name: fireeye-helix-create-list
    outputs:
    - contextPath: FireEyeHelix.List.ID
      description: List ID.
      type: Number
    - contextPath: FireEyeHelix.List.Description
      description: List description.
      type: Number
    - contextPath: FireEyeHelix.List.ShortName
      description: Short name of the list.
      type: String
    - contextPath: FireEyeHelix.List.Name
      description: Name of the list.
      type: String
    - contextPath: FireEyeHelix.List.ContentTypes
      description: Content types of the list. Can be Email, FQDN, IPv4, IPv6, SHA1,
        MD5, or Misc.
      type: String
    - contextPath: FireEyeHelix.List.CreatorID
      description: ID of the list creator.
      type: String
    - contextPath: FireEyeHelix.List.CreatorName
      description: Name of the list creator.
      type: String
    - contextPath: FireEyeHelix.List.UpdatedByID
      description: ID of the user who last updated the list.
      type: String
    - contextPath: FireEyeHelix.List.CreatedTime
      description: Time that the rule was created.
      type: Date
    - contextPath: FireEyeHelix.List.UpdatedTime
      description: Time that the rule was last updated.
      type: Date
    - contextPath: FireEyeHelix.List.Type
      description: List type. Can be Default, Analytics Whitelist, or Intel Matching.
      type: String
    - contextPath: FireEyeHelix.List.UpdatedByName
      description: Name of the user who last updated the list.
      type: Unknown
    - contextPath: FireEyeHelix.List.Internal
      description: Whether the list is internal. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.List.Protected
      description: Whether the list is protected. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.List.Active
      description: Whether the list is active. Can be true or false.
      type: Unknown
  - arguments:
    - description: Name of the list to update.
      name: name
    - description: Short name of the list.
      name: short_name
    - auto: PREDEFINED
      description: Whether the list is internal. Can be true or false.
      name: is_internal
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Whether the list is active. Can be true or false.
      name: is_active
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: Whether the list is protected. Can be true or false.
      name: is_protected
      predefined:
      - "true"
      - "false"
    - description: A comma-separated list of list uses.
      name: usage
    - auto: PREDEFINED
      description: Whether the list is hiddne. Can be true or false.
      name: is_hidden
      predefined:
      - "true"
      - "false"
    - description: List type.
      name: type
    - description: Description of the list.
      name: description
    - default: true
      description: ID of the list.
      name: list_id
      required: true
    description: Updates an existing list.
    name: fireeye-helix-update-list
    outputs:
    - contextPath: FireEyeHelix.List.ID
      description: List ID.
      type: Number
    - contextPath: FireEyeHelix.List.Description
      description: List description.
      type: Number
    - contextPath: FireEyeHelix.List.ShortName
      description: Short name of the list.
      type: String
    - contextPath: FireEyeHelix.List.Name
      description: Name of the list.
      type: String
    - contextPath: FireEyeHelix.List.ContentTypes
      description: Content types of the list. Can be Email, FQDN, IPv4, IPv6, SHA1,
        MD5, or Misc.
      type: String
    - contextPath: FireEyeHelix.List.CreatorID
      description: ID of the creator.
      type: String
    - contextPath: FireEyeHelix.List.CreatorName
      description: Name of the creator.
      type: String
    - contextPath: FireEyeHelix.List.UpdatedByID
      description: ID of the user who last updated the list.
      type: String
    - contextPath: FireEyeHelix.List.CreatedTime
      description: Time that the rule was created.
      type: Date
    - contextPath: FireEyeHelix.List.UpdatedTime
      description: Time that the rule was last updated.
      type: Date
    - contextPath: FireEyeHelix.List.Type
      description: List type. Can be Default, Analytics Whitelist, Intel Matching.
      type: String
    - contextPath: FireEyeHelix.List.UpdatedByName
      description: Name of the user who last updated the list.
      type: Unknown
    - contextPath: FireEyeHelix.List.Internal
      description: Whether the list is internal. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.List.Protected
      description: Whether the list is protected. Can be true or flase.
      type: Boolean
    - contextPath: FireEyeHelix.List.Active
      description: Whether the list is active. Can be true or false.
      type: Unknown
  - arguments:
    - default: true
      description: ID of the list to delete.
      name: list_id
      required: true
    description: Deletes a single list by list ID.
    name: fireeye-helix-delete-list
  - arguments:
    - description: Maximum number of results to return per page.
      name: page_size
    - description: The initial index from which to return the results.
      name: offset
    - description: Host name of the sensor.
      name: hostname
    - description: Status of the sensor.
      name: status
    description: Fetches all sensors.
    name: fireeye-helix-list-sensors
  - arguments:
    - description: Maximum number of results to return per page.
      name: page_size
    - description: The initial index from which to return the results.
      name: offset
    - description: 'A comma-separated list of field names by which to sort the results.
        For example: “createDate” or "-updateDate,riskOrder"'
      name: sort
    description: Returns all rules.
    name: fireeye-helix-list-rules
    outputs:
    - contextPath: FireEyeHelix.Rule.ID
      description: Rule ID.
      type: String
    - contextPath: FireEyeHelix.Rule.RulePack
      description: Rule package version.
      type: String
    - contextPath: FireEyeHelix.Rule.Description
      description: Rule description.
      type: String
    - contextPath: FireEyeHelix.Rule.Internal
      description: Whether the rule is internal. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.Rule.Deleted
      description: Whether the rule was deleted. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.Rule.Enabled
      description: Whether the rule is enabled. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.Rule.Supported
      description: Whether the rule is supported. Can be true or false.
      type: Boolean
    - contextPath: FireEyeHelix.Rule.CreatorID
      description: ID of the rule creator.
      type: String
    - contextPath: FireEyeHelix.Rule.CreatorName
      description: Name of the rule creator.
      type: String
    - contextPath: FireEyeHelix.Rule.UpdatedByID
      description: ID of the user who updated the rule.
      type: String
    - contextPath: FireEyeHelix.Rule.UpdatedByName
      description: Name of the user who updated the rule.
      type: String
    - contextPath: FireEyeHelix.Rule.Risk
      description: The risk to your environment when an event matches this rule. Can
        be low, medium, high, or critical.
      type: String
    - contextPath: FireEyeHelix.Rule.Confidence
      description: Confidence that indicates how likely it is that the rule will detect
        events that correspond to the type of activity anticipated (that is, the likelihood
        that the rule will produce true positives). Confidence and Severity combine
        to form the risk attribute of the alert. Can be low, medium, or high.
      type: String
    - contextPath: FireEyeHelix.Rule.Severity
      description: |-
        Severity that indicates how much of an impact a hit with this rule could have on an organization if
        verified to be a true positive. Confidence and Severity combine to form the risk attribute of the alert. Can be low, medium, or high.
      type: String
    - contextPath: FireEyeHelix.Rule.Tags
      description: Rule tags.
      type: String
    - contextPath: FireEyeHelix.Rule.Type
      description: Rule type.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: Whether the rule is enabled. Can be true or false.
      name: enabled
      predefined:
      - "true"
      - "false"
    - default: true
      description: ID of the rule.
      name: rule_id
      required: true
    description: Modifies an existing rule.
    name: fireeye-helix-edit-rule
  - arguments:
    - default: true
      description: Alert ID.
      name: alert_id
      required: true
    description: Returns all notes related to an alert.
    name: fireeye-helix-alert-get-notes
    outputs:
    - contextPath: FireEyeHelix.Note.ID
      description: Note ID.
      type: Number
    - contextPath: FireEyeHelix.Note.CreatedTime
      description: Time that the note was created.
      type: Date
    - contextPath: FireEyeHelix.Note.UpdatedTime
      description: Time that the note was updated.
      type: Date
    - contextPath: FireEyeHelix.Note.Message
      description: Message of the note.
      type: String
    - contextPath: FireEyeHelix.Note.CreatorID
      description: ID of the note creator.
      type: String
    - contextPath: FireEyeHelix.Note.CreatorName
      description: Name of the note creator.
      type: String
    - contextPath: FireEyeHelix.Note.AlertID
      description: ID of the related alert.
      type: Number
    - contextPath: FireEyeHelix.Note.Count
      description: Total number of notes for the alert.
      type: Number
  - arguments:
    - default: true
      description: ID of the alert to delete.
      name: alert_id
      required: true
    - defaultValue: Note ID.
      description: Note ID.
      name: note_id
      required: true
    description: Deletes an alert note.
    name: fireeye-helix-alert-delete-note
  - arguments:
    - description: Start time of the event in the format yyyy-mm-dd or yyyy-mm.
      name: start
    - description: End time of the event in the format yyyy-mm-dd or yyyy-mm.
      name: end
    - description: Maximum number of results to return.
      name: page_size
    - description: Offset of the result.
      name: offset
    - description: Returns the unique values for the specified field and groups them
        based on the specified frequency. For example, groupby="srcipv4 5 100" will
        group the top five srcipv4 addresses that have at least 100 occurrences. Supports
        comma-separated values.
      name: groupby
    - description: The field by which to sort results.
      name: sort_by
    - auto: PREDEFINED
      defaultValue: desc
      description: Controls the order of the results sorted by the sort_by argument.
        Can be "asc" for ascending or "desc" for descending. Default is "desc".
      name: sort_order
      predefined:
      - asc
      - desc
    - default: true
      description: The query to execute. This is the search clause in an MQL.
      name: query
      required: true
    - description: The number of events to search.
      name: limit
    - description: A comma-separated list (no spaces) of output values to display
        in the command result, e.g., ID,Type,SourceIPv4.
      isArray: true
      name: headers
    description: Executes a search in FireEye Helix using MQL.
    name: fireeye-helix-search
    outputs:
    - contextPath: FireEyeHelixSearch.Result.ID
      description: Event ID.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Type
      description: Event type.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Result
      description: Event result.
      type: String
    - contextPath: FireEyeHelixSearch.Result.MatchedAt
      description: Time that the event was matched.
      type: Date
    - contextPath: FireEyeHelixSearch.Result.Confidence
      description: Confidence of the event. Can be low, medium, or high.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Status
      description: Status of the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.EventTime
      description: Time that the event took occurred.
      type: Date
    - contextPath: FireEyeHelixSearch.Result.DetectedRuleID
      description: ID of the detected rule.
      type: String
    - contextPath: FireEyeHelixSearch.Result.PID
      description: Process ID.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Process
      description: Process details.
      type: String
    - contextPath: FireEyeHelixSearch.Result.ProcessPath
      description: Process path.
      type: String
    - contextPath: FireEyeHelixSearch.Result.FileName
      description: Name of the file affected by the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.FilePath
      description: Path of the the file affected by the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.DeviceName
      description: Device name.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Size
      description: Size of the file (in bytes) that created the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Virus
      description: Virus that was detected in the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.MalwareType
      description: Malware type of the virus that was detected.
      type: String
    - contextPath: FireEyeHelixSearch.Result.CreatedTime
      description: Time that the event was created.
      type: Date
    - contextPath: FireEyeHelixSearch.Result.Class
      description: Event class.
      type: String
    - contextPath: FireEyeHelixSearch.Result.MD5
      description: MD5 hash of the affected file.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SHA1
      description: SHA1 hash of the affected file.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Protocol
      description: Protocol used in the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceIPv4
      description: IPv4 address of the event source.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceIPv6
      description: IPv6 address of the event source.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourcePort
      description: Port of the event source address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceLongitude
      description: Longitude of the event source address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceLatitude
      description: Latitude of the event source address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.DestinationIPv4
      description: IPv4 address of the event destination.
      type: String
    - contextPath: FireEyeHelixSearch.Result.DestinationIPv6
      description: IPv6 address of the event destination.
      type: String
    - contextPath: FireEyeHelixSearch.Result.DestinationPort
      description: Port of the event destination address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.ReportTime
      description: Time that the event was reported.
      type: Date
    - contextPath: FireEyeHelixSearch.Result.FalsePositive
      description: Whether the event is a false positive.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Domain
      description: Domain of the recepient.
      type: String
    - contextPath: FireEyeHelixSearch.Result.From
      description: Source email address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceDomain
      description: Domain of the host that created the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceISP
      description: ISP of the source of the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.DestinationISP
      description: ISP of the destination of the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.To
      description: Destination email address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Attachment
      description: Email attachment.
      type: Unknown
    - contextPath: FireEyeHelixSearch.MQL
      description: MQL query that created the result.
      type: String
    - contextPath: FireEyeHelixSearch.GroupBy
      description: Group by values.
      type: Unknown
    - contextPath: FireEyeHelixSearch.GroupBy.DocCount
      description: Number of matches for the group.
      type: Number
    - contextPath: FireEyeHelixSearch.Result.RcpTo
      description: Recipient email address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.InReplyTo
      description: Reply email address.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: Item type. Can be email, fqdn, ipv4, ipv6, md5, misc, or sha-1.
      name: type
      predefined:
      - email
      - fqdn
      - ipv4
      - ipv6
      - md5
      - misc
      - sha-1
      required: true
    - description: Item value.
      name: value
      required: true
    - description: ID of the list.
      name: list_id
      required: true
    - auto: PREDEFINED
      description: Risk of the item. Can be Low, Medium, High, or Critical.
      name: risk
      predefined:
      - Low
      - Medium
      - High
      - Critical
    - description: Item notes.
      name: notes
    description: Adds an item to a list.
    name: fireeye-helix-add-list-item
    outputs:
    - contextPath: FireEyeHelixList.Item.ID
      description: Item ID.
      type: Number
    - contextPath: FireEyeHelixList.Item.Value
      description: Item value.
      type: String
    - contextPath: FireEyeHelixList.Item.Type
      description: Item type. Can be email, fqdn, ipv4, ipv6, md5, misc, or sha-1.
      type: String
    - contextPath: FireEyeHelixList.Item.Risk
      description: Risk of the item. Can be Low, Medium, High, or Critical.
      type: String
    - contextPath: FireEyeHelixList.Item.Notes
      description: Item notes.
      type: String
    - contextPath: FireEyeHelixList.Item.ListID
      description: List ID with which the item is associated.
      type: String
  - arguments:
    - default: true
      description: ID of the list for which to fetch items.
      name: list_id
      required: true
    - description: Item offset. Default is 0.
      name: offset
    description: Fetches items of a list.
    name: fireeye-helix-get-list-items
    outputs:
    - contextPath: FireEyeHelixList.Item.ID
      description: Item ID.
      type: Number
    - contextPath: FireEyeHelixList.Item.Value
      description: Item value.
      type: String
    - contextPath: FireEyeHelixList.Item.Type
      description: Item type. Can be email, fqdn, ipv4, ipv6, md5, misc, or sha-1.
      type: String
    - contextPath: FireEyeHelixList.Item.Risk
      description: Risk of the item. Can be Low, Medium, High, or Critical.
      type: String
    - contextPath: FireEyeHelixList.Item.Notes
      description: Item notes.
      type: String
    - contextPath: FireEyeHelixList.Item.ListID
      description: List ID with which the item is associated.
      type: String
    - contextPath: FireEyeHelixList.Item.Count
      description: Number of items in the list.
      type: Number
  - arguments:
    - default: true
      description: ID of the item to update.
      name: item_id
      required: true
    - auto: PREDEFINED
      description: Item type. Can be email, fqdn, ipv4, ipv6, md5, misc, or sha-1.
      name: type
      predefined:
      - email
      - fqdn
      - ipv4
      - ipv6
      - md5
      - misc
      - sha-1
    - description: Item value.
      name: value
    - description: ID of the list.
      name: list_id
      required: true
    - auto: PREDEFINED
      description: Risk of the item. Can be Low, Medium, High, or Critical.
      name: risk
      predefined:
      - Low
      - Medium
      - High
      - Critical
    - description: Item notes.
      name: notes
    description: Updates a single list item.
    name: fireeye-helix-update-list-item
    outputs:
    - contextPath: FireEyeHelixList.Item.ID
      description: Item ID.
      type: Number
    - contextPath: FireEyeHelixList.Item.Value
      description: Item value.
      type: String
    - contextPath: FireEyeHelixList.Item.Type
      description: Item type. Can be email, fqdn, ipv4, ipv6, md5, misc, or sha-1.
      type: String
    - contextPath: FireEyeHelixList.Item.Risk
      description: Risk of the item. Can be Low, Medium, High, or Critical.
      type: String
    - contextPath: FireEyeHelixList.Item.Notes
      description: Item notes.
      type: String
    - contextPath: FireEyeHelixList.Item.ListID
      description: List ID with which the item is associated.
      type: String
  - arguments:
    - description: ID of the list from which to remove an item.
      name: list_id
      required: true
    - description: Item ID.
      name: item_id
      required: true
    description: Removes an item from a list.
    name: fireeye-helix-remove-list-item
  - arguments:
    - default: true
      description: ID of the search for which to return archive results.
      name: search_id
      required: true
    - description: A comma-separated list of output values to display in the command
        result, e.g., ID,Type,SourceIPv4.
      isArray: true
      name: headers
    description: Fetches archive search results.
    name: fireeye-helix-archive-search-get-results
    outputs:
    - contextPath: FireEyeHelixSearch.Result.ID
      description: Event ID.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Type
      description: Event type.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Result
      description: Event result.
      type: String
    - contextPath: FireEyeHelixSearch.Result.MatchedAt
      description: Time that the event was matched.
      type: Date
    - contextPath: FireEyeHelixSearch.Result.Confidence
      description: Confidence of the event. Can be low, medium, or high.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Status
      description: Status of the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.EventTime
      description: Time that the event occurred.
      type: Date
    - contextPath: FireEyeHelixSearch.Result.DetectedRuleID
      description: ID of the detected rule.
      type: String
    - contextPath: FireEyeHelixSearch.Result.PID
      description: Process ID.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Process
      description: Process details.
      type: String
    - contextPath: FireEyeHelixSearch.Result.ProcessPath
      description: Process path.
      type: String
    - contextPath: FireEyeHelixSearch.Result.FileName
      description: Name of the file affected by the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.FilePath
      description: Path of the the file affected by the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.DeviceName
      description: Device name.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Size
      description: Size of the file (in bytes) that created the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Virus
      description: Virus that was detected in the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.MalwareType
      description: Malware type of the virus that was detected.
      type: String
    - contextPath: FireEyeHelixSearch.Result.CreatedTime
      description: Time that the event was created.
      type: Date
    - contextPath: FireEyeHelixSearch.Result.Class
      description: Event class.
      type: String
    - contextPath: FireEyeHelixSearch.Result.MD5
      description: MD5 hash of the affected file.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SHA1
      description: SHA1 hash of the affected file.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Protocol
      description: Protocol used in the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceIPv4
      description: IPv4 address of the event source.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceIPv6
      description: IPv6 address of the event source.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourcePort
      description: Port of the event source address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceLongitude
      description: Longitude of the event source address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceLatitude
      description: Latitude of the event source address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.DestinationIPv4
      description: IPv4 address of the event destination.
      type: String
    - contextPath: FireEyeHelixSearch.Result.DestinationIPv6
      description: IPv6 address of the event destination.
      type: String
    - contextPath: FireEyeHelixSearch.Result.DestinationPort
      description: Port of the event destination address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.ReportTime
      description: Time that the event was reported.
      type: Date
    - contextPath: FireEyeHelixSearch.Result.FalsePositive
      description: Whether the event is a false positive.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Domain
      description: Domain of the recepient.
      type: String
    - contextPath: FireEyeHelixSearch.Result.From
      description: Source email address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceDomain
      description: Domain of the host that created the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.SourceISP
      description: ISP of the source of the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.DestinationISP
      description: ISP of the destination of the event.
      type: String
    - contextPath: FireEyeHelixSearch.Result.To
      description: Destination email address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.Attachment
      description: Email attachment.
      type: Unknown
    - contextPath: FireEyeHelixSearch.MQL
      description: MQL query that created the result.
      type: String
    - contextPath: FireEyeHelixSearch.GroupBy
      description: Group by values.
      type: Unknown
    - contextPath: FireEyeHelixSearch.GroupBy.DocCount
      description: Number of matches for the group.
      type: Number
    - contextPath: FireEyeHelixSearch.Result.RcpTo
      description: Recipient email address.
      type: String
    - contextPath: FireEyeHelixSearch.Result.InReplyTo
      description: Reply email address.
      type: String
  - arguments:
    - description: Start time of the event in the format yyyy-mm-dd or yyyy-mm.
      name: start
    - description: End time of the event in the format yyyy-mm-dd or yyyy-mm.
      name: end
    - description: Offset of the result.
      name: offset
    - description: Returns the unique values for the specified field and groups them
        based on the specified frequency. For example groupby="srcipv4 5 100" will
        group the top five srcipv4 addresses that have at least 100 occurences. Supports
        comma-separated values.
      name: groupby
    - description: Sorts results by this field.
      name: sort_by
    - auto: PREDEFINED
      defaultValue: desc
      description: Controls the order of the results sorted by the sort_by argument.
        Can be "asc" for ascending or "desc" for descending. Default is "desc".
      name: sort_order
      predefined:
      - asc
      - desc
    - default: true
      description: The query to execute. This is the search clause in an MQL.
      name: query
      required: true
    - description: Number of events to search.
      name: limit
    description: Creates an archive search from a query.
    name: fireeye-helix-archive-search
    outputs:
    - contextPath: FireEyeHelixSearch.ID
      description: ID of an archive search.
      type: Number
    - contextPath: FireEyeHelixSearch.PercentComplete
      description: Percentage of the search that was completed.
      type: String
    - contextPath: FireEyeHelixSearch.Query
      description: The search query.
      type: String
    - contextPath: FireEyeHelixSearch.State
      description: State of the search.
      type: String
  - arguments:
    - default: true
      description: Archive search ID.
      isArray: true
      name: search_id
      required: true
    description: Gets the status of an archive search.
    name: fireeye-helix-archive-search-get-status
    outputs:
    - contextPath: FireEyeHelixSearch.ID
      description: ID of an archive search.
      type: Number
    - contextPath: FireEyeHelixSearch.PercentComplete
      description: Percentage of the search that was completed.
      type: String
    - contextPath: FireEyeHelixSearch.Query
      description: The search query.
      type: String
    - contextPath: FireEyeHelixSearch.State
      description: State of the search.
      type: String
  dockerimage: demisto/python3:3.7.5.4002
  isfetch: true
  runonce: false
  script: |
    import math





    ''' IMPORTS '''
    from typing import Dict, Tuple, List, Optional, Any, Union
    import urllib3

    # Disable insecure warnings
    urllib3.disable_warnings()

    """GLOBALS/PARAMS
    Attributes:
        INTEGRATION_NAME:
            Name of the integration as shown in the integration UI.

        INTEGRATION_COMMAND_NAME:
            Command names prefix used for all commands.

        INTEGRATION_CONTEXT_NAME:
            Context output name used in most outputs.

        ALERTS_TRANS
            Transformation map for alerts to be used with create_context_result

        ARCHIVE_SEARCH_TRANS
            Transformation map for archive search to be used with create_context_result

        CASES_TRANS
            Transformation map for cases to be used with create_context_result

        ENDPOINTS_TRANS
            Transformation map for endpoints to be used with build_transformation_dict

        EVENTS_TRANS
            Transformation map for events to be used with build_transformation_dict

        LISTS_TRANS
            Transformation map for lists to be used with create_context_result

        LIST_ITEM_TRANS
            Transformation map for list items to be used with create_context_result

        NOTES_TRANS
            Transformation map for notes to be used with create_context_result

        RULES_TRANS
            Transformation map for rules to be used with create_context_result
    """
    INTEGRATION_NAME = 'FireEye Helix'
    INTEGRATION_COMMAND_NAME = 'fireeye-helix'
    INTEGRATION_CONTEXT_NAME = 'FireEyeHelix'
    DEFAULT_PAGE_SIZE = 30
    ALERTS_TRANS = {
        'id': 'ID',
        'alert_type.id': 'AlertTypeID',
        'alert_type.name': 'Name',
        'assigned_to.id': 'AssigneeID',
        'assigned_to.name': 'AssigneeName',
        'created_by.id': 'CreatorID',
        'created_by.name': 'CreatorName',
        'updated_by.id': 'UpdaterID',
        'updated_by.name': 'UpdaterName',
        'created_at': 'CreatedTime',
        'updated_at': 'ModifiedTime',
        'alert_type_details.detail.processpath': 'ProcessPath',
        'alert_type_details.detail.process': 'Process',
        'alert_type_details.detail.pprocess': 'ParentProcess',
        'alert_type_details.detail.confidence': 'Confidence',
        'alert_type_details.detail.sha1': 'SHA1',
        'alert_type_details.detail.md5': 'MD5',
        'alert_type_details.detail.hostname': 'Hostname',
        'alert_type_details.detail.pid': 'PID',
        'alert_type_details.detail.byte': 'Size',
        'alert_type_details.detail.virus': 'Virus',
        'alert_type_details.detail.result': 'Result',
        'alert_type_details.detail.malwaretype': 'MalwareType',
        'alert_type_details.detail.filename': 'FileName',
        'alert_type_details.detail.regpath': 'RegPath',
        'alert_type_details.detail.eventtime': 'EventTime',
        'alert_type_details.detail.iocnames': 'IOCNames',
        'alert_type_details.detail.srcipv4': 'SourceIPv4',
        'alert_type_details.detail.srcipv6': 'SourceIPv6',
        'alert_type_details.detail.dstipv4': 'DestinationIPv4',
        'alert_type_details.detail.dstipv6': 'DestinationIPv6',
        'alert_type_details.detail.dstport': 'DestinationPort',
        'alert_type_details.detail.uri': 'URI',
        'alert_type_details.detail.domain': 'Domain',
        'alert_type_details.detail.useragent': 'UserAgent',
        'alert_type_details.detail.httpmethod': 'HttpMethod',
        'events_count': 'EventsCount',
        'notes_count': 'NotesCount',
        'closed_state': 'ClosedState',
        'closed_reason': 'ClosedReason',
        'description': 'Description',
        'first_event_at': 'FirstEventTime',
        'last_event_at': 'LastEventTime',
        'external_ips': 'ExternalIP',
        'internal_ips': 'InternalIP',
        'message': 'Message',
        'products': 'Products',
        'risk': 'Risk',
        'severity': 'Severity',
        'state': 'State',
        'tags': 'Tags',
        'type': 'Type',
    }
    ARCHIVE_SEARCH_TRANS = {
        'id': 'ID',
        'percentComplete': 'PercentComplete',
        'query': 'Query',
        'state': 'State',
    }
    CASES_TRANS = {
        'id': 'ID',
        'name': 'Name',
        'alerts_count': 'AlertsCount',
        'assigned_to.id': 'AssigneeID',
        'assigned_to.name': 'AssigneeName',
        'created_by.id': 'CreatorID',
        'created_by.name': 'CreatorName',
        'updated_by.id': 'UpdaterID',
        'updated_by.name': 'UpdaterName',
        'created_at': 'CreatedTime',
        'updated_at': 'ModifiedTime',
        'description': 'Description',
        'events_count': 'EventsCount',
        'info_links': 'InfoLinks',
        'notes_count': 'NotesCount',
        'priority': 'Priority',
        'priority_order': 'PriorityOrder',
        'severity': 'Severity',
        'state': 'State',
        'status': 'Status',
        'tags': 'Tags',
        'total_days_unresolved': 'TotalDaysUnresolved'
    }
    ENDPOINTS_TRANS = {
        'id': 'ID',
        'customer_id': 'CustomerID',
        'device_id': 'DeviceID',
        'domain': 'Domain',
        'hostname': 'Hostname',
        'mac_address': 'MACAddress',
        'operating_system': 'OS',
        'primary_ip_address': 'IP',
        'updated_at': 'UpdatedTime',
        'containment_state': 'ContainmentState'
    }
    EVENTS_TRANS = {
        'eventid': 'ID',
        'eventtype': 'Type',
        'result': 'Result',
        'matched_at': 'MatchedAt',
        'confidence': 'Confidence',
        'status': 'Status',
        'eventtime': 'EventTime',
        'detect_ruleids': 'DetectedRuleID',
        'pid': 'PID',
        'process': 'Process',
        'processpath': 'ProcessPath',
        'filename': 'FileName',
        'filepath': 'FilePath',
        'devicename': 'DeviceName',
        'bytes': 'Size',
        'virus': 'Virus',
        'malwaretype': 'MalwareType',
        'createdtime': 'CreatedTime',
        'class': 'Class',
        'md5': 'MD5',
        'sha1': 'SHA1',
        'protocol': 'Protocol',
        'srcipv4': 'SourceIPv4',
        'srcipv6': 'SourceIPv6',
        'srcport': 'SourcePort',
        'srclongitude': 'SourceLongitude',
        'dstipv4': 'DestinationIPv4',
        'srclatitude': 'SourceLatitude',
        'dstipv6': 'DestinationIPv6',
        'dstport': 'DestinationPort',
        'reported_at': 'ReportTime',
        'is_false_positive': 'FalsePositive',
        'domain': 'Domain',
        'mailfrom': 'From',
        'srcdomain': 'SourceDomain',
        'srcisp': 'SourceISP',
        'dstisp': 'DestinationISP',
        'rcptto': 'RcpTo',
        'to': 'To',
        'inreplyto': 'InReplyTo',
        'attachment': 'Attachment',
    }
    LISTS_TRANS = {
        'id': 'ID',
        'short_name': 'ShortName',
        'name': 'Name',
        'type': 'Type',
        'description': 'Description',
        'types': 'ContentTypes',
        'created_by.id': 'CreatorID',
        'created_by.name': 'CreatorName',
        'updated_by.id': 'UpdatedByID',
        'updated_by.name': 'UpdatedByName',
        'created_at': 'CreatedTime',
        'updated_at': 'UpdatedTime',
        'is_internal': 'Internal',
        'is_protected': 'Protected',
        'is_active': 'Active',
    }
    LIST_ITEM_TRANS = {
        'id': 'ID',
        'value': "Value",
        'type': "Type",
        'risk': "Risk",
        'notes': 'Notes',
        'list': 'ListID'
    }
    NOTES_TRANS = {
        'id': 'ID',
        'created_at': 'CreatedTime',
        'updated_at': 'UpdatedTime',
        'note': 'Message',
        'created_by.id': 'CreatorID',
        'created_by.name': 'CreatorName',
    }
    RULES_TRANS = {
        'id': 'ID',
        '_rulePack': 'RulePack',
        'description': 'Description',
        'internal': 'Internal',
        'deleted': 'Deleted',
        'enabled': 'Enabled',
        'supported': 'Supported',
        '_createdBy.id': 'CreatorID',
        '_createdBy.name': 'CreatorName',
        '_updatedBy.id': 'UpdatedByID',
        '_updatedBy.name': 'UpdatedByName',
        'risk': 'Risk',
        'confidence': 'Confidence',
        'severity': 'Severity',
        'tags': 'Tags',
        'type': 'Type',
    }


    class Client(BaseClient):
        def test_module(self):
            """Performs basic GET request to check if the API is reachable and authentication is successful.

            Returns:
                Response content
            """
            suffix = '/api/v3/alerts'
            self._http_request('GET', suffix, params={'limit': 1})

        def list_alerts(self, limit: int = None, offset: int = None, created_at__gte: str = None) -> Dict:
            """Returns all alerts by sending a GET request.

            Args:
                limit: The maximum number of alerts to return.
                offset: The initial index from which to return the results.
                created_at__gte: Date time string. Will fetch alerts with a create time greater or equal to this value

            Returns:
                Response from API.
            """
            suffix = '/api/v3/alerts'
            # Dictionary of params for the request
            params = assign_params(
                limit=limit,
                offset=offset,
                created_at__gte=created_at__gte
            )
            # Send a request using our http_request wrapper
            return self._http_request('GET', suffix, params=params)

        def get_alert_by_id(self, _id: Optional[Any]) -> Dict:
            """Return a single alert by sending a GET request.

            Args:
                _id: ID  of the alert to get.

            Returns:
                Response from API.
            """
            suffix = f'/api/v3/alerts/{_id}'
            return self._http_request('GET', suffix)

        def search(self, query: str = None):
            """Searches for alerts based on query

            Args:
                query: Search query written in mql

            Returns:
                Response from API.
            """
            suffix = f'/api/v1/search'
            params = assign_params(query=query)
            return self._http_request('GET', suffix, params=params, timeout=DEFAULT_PAGE_SIZE)

        def archive_search_alert(self, query: str = None):
            """Searches for alerts based on query

            Args:
                query: Search query written in mql

            Returns:
                Response from API.
            """
            suffix = f'/api/v1/search/archive'
            params = assign_params(query=query)
            return self._http_request('GET', suffix, params=params)

        def archive_search(self, query: str = None) -> Dict:
            """Searches for events using archive search

            Args:
                query: Search query written in mql

            Returns:
                Response from API.
            """
            suffix = f'/api/v1/search/archive'
            params = assign_params(query=query)
            return self._http_request('GET', suffix, params=params)

        def get_archive_search(self, search_id: int = None) -> Dict:
            """Gets archive search

            Args:
                search_id: Search id

            Returns:
                Response from API.
            """
            suffix = f'/api/v1/search/archive/{search_id}'
            return self._http_request('GET', suffix)

        def get_archive_search_results(self, search_id: int = None):
            """Searches for alerts based on query

            Args:
                search_id: Search ID to get

            Returns:
                Response from API.
            """
            suffix = f'/api/v1/search/archive/{search_id}/results'
            return self._http_request('GET', suffix, timeout=DEFAULT_PAGE_SIZE)

        def update_alert_by_id(self, body: Dict) -> Dict:
            """Updates a single alert by sending a POST request.

            Args:
                body: Request body to update dictionary.

            Returns:
                Response from API.
            """
            suffix = f'/api/v3/alerts'
            return self._http_request('POST', suffix, json_data=body)

        def get_alert_notes(self, alert_id):
            """Get all notes related to alert by sending a GET request.

            Args:
                alert_id: Alert ID.

            Returns:
                Response from API.
            """
            suffix = f'/api/v3/alerts/{alert_id}/notes'
            return self._http_request('GET', suffix)

        def create_alert_note(self, alert_id: Optional[Any], note: Optional[Any]) -> Dict:
            """Creates a single note for an alert by sending a POST request.

            Args:
                alert_id: Alert ID to create note for.
                note: Note to add to alert.

            Returns:
                Response from API.
            """
            suffix = f'/api/v3/alerts/{alert_id}/notes'
            body = assign_params(note=note)
            return self._http_request('POST', suffix, json_data=body)

        def delete_alert_note(self, alert_id: Optional[Any], note_id: Optional[Any]) -> Dict:
            """Deletes a single note for an alert by sending a DELETE request.

            Args:
                alert_id: Alert ID to delete note for.
                note_id: Note ID.

            Returns:
                Response from API.
            """
            suffix = f'/api/v3/alerts/{alert_id}/notes/{note_id}'
            return self._http_request('DELETE', suffix, resp_type='')

        def get_events_by_alert(self, alert_id: Optional[Any]) -> Dict:
            """Fetches events for an alert by sending a GET request.

            Args:
                alert_id: Alert ID to get events for.

            Returns:
                Response from API.
            """
            suffix = f'/api/v3/alerts/{alert_id}/events'
            return self._http_request('GET', suffix)

        def get_endpoints_by_alert(self, alert_id: Optional[Any], offset: Optional[Any] = None) -> Dict:
            """Fetches endpoints for an alert by sending a GET request.

            Args:
                alert_id: Alert ID to get endpoints for.
                offset: Offset to the result

            Returns:
                Response from API.
            """
            suffix = f'/api/v3/alerts/{alert_id}/endpoints'
            params = assign_params(
                offset=offset
            )
            return self._http_request('GET', suffix, params=params)

        def get_cases_by_alert(self, alert_id: Optional[Any], limit: Optional[Any] = None, offset: Optional[Any] = None,
                               order_by: Optional[Any] = None) -> Dict:
            """Fetches cases for an alert by sending a GET request.

            Args:
                alert_id: Alert ID to get endpoints for.
                limit: Number of results to return per page.
                offset: The initial index from which to return the results.
                order_by: Which field to use when ordering the results.

            Returns:
                Response from API.
            """
            suffix = f'/api/v3/alerts/{alert_id}/cases'
            body = assign_params(
                limit=limit,
                offset=offset,
                order_by=order_by
            )
            body = body if body else None
            return self._http_request('GET', suffix, json_data=body)

        def get_event_by_id(self, event_id: Optional[Any]) -> Dict:
            """Fetches an event by id via a GET request.

            Args:
                event_id: ID of an event.

            Returns:
                Response from API.
            """
            suffix = f'/api/v1/events/{event_id}'
            return self._http_request('GET', suffix)

        def get_lists(self, limit: int = None, offset: int = None, created_at: str = None, description: str = None,
                      is_active: bool = None, is_internal: bool = None, is_protected: bool = None, name: str = None,
                      short_name: str = None, type: str = None, updated_at: str = None, usage: str = None,
                      order_by: str = None, **kwargs) -> Dict:
            """Fetches lists by a GET request

            Args:
                limit: Number of results to return per page.
                offset: The initial index from which to return the results.
                created_at: Creation date of the list.
                description: Description of the list.
                is_active: Set to true if the list is active.
                is_internal: Set to true if the list is internal.
                is_protected: Set to true if list is protected.
                name: Name of the list.
                short_name: Short name of the list.
                type: Type of the list.
                updated_at: The time the list was last updated at.
                usage: Multiple values may be separated by commas.
                order_by: Which field to use when ordering the results.

            Returns:
                Response from API.
            """
            suffix = '/api/v3/lists'
            params = assign_params(
                limit=limit,
                offset=offset,
                created_at=created_at,
                description=description,
                is_active=is_active,
                is_internal=is_internal,
                is_protected=is_protected,
                name=name,
                short_name=short_name,
                type=type,
                updated_at=updated_at,
                usage=usage,
                order_by=order_by
            )
            return self._http_request('GET', suffix, params=params)

        def get_list_by_id(self, list_id: Optional[Any]) -> Dict:
            """Get a list by id via a GET request

            Args:
                list_id: ID of the list

            Returns:
                Response from API.
            """
            suffix = f'/api/v3/lists/{list_id}'
            return self._http_request('GET', suffix)

        def create_list(self, name: Optional[str], usage: str = None, short_name: str = None, is_internal: bool = None,
                        is_active: bool = None, is_protected: bool = None, is_hidden: bool = None, type: str = None,
                        description: str = None, **kwargs) -> Dict:
            """Creates a list using a POST request

            Args:
                name: Name of the list.
                short_name: Short name of the list.
                is_internal: Boolean flag for is internal.
                is_active: Boolean flag for is active.
                is_protected: Boolean flag for is protected.
                is_hidden: Boolean flag for is hiddden.
                usage: Usage of the list.
                type: Type of the list.
                description: Description of the list.

            Returns:
                Response from API.
            """
            suffix = '/api/v3/lists'
            body = assign_params(
                name=name,
                short_name=short_name,
                is_internal=is_internal,
                is_active=is_active,
                is_protected=is_protected,
                is_hidden=is_hidden,
                type=type,
                description=description
            )
            body['usage'] = argToList(usage)
            return self._http_request('POST', suffix, json_data=body)

        def update_list(self, list_id: int, name: str = None, usage: str = None, short_name: str = None,
                        is_internal: bool = None, is_active: bool = None, is_protected: bool = None, is_hidden: bool = None,
                        type: str = None, description: str = None, **kwargs) -> Dict:
            """Creates a list using a POST request

            Args:
                list_id: ID of the list.
                name: Name of the list.
                short_name: Short name of the list.
                is_internal: Boolean flag for is internal.
                is_active: Boolean flag for is active.
                is_protected: Boolean flag for is protected.
                is_hidden: Boolean flag for is hiddden.
                usage: Usage of the list.
                type: Type of the list.
                description: Description of the list.

            Returns:
                Response from API.
            """
            suffix = f'/api/v3/lists/{list_id}'
            body = assign_params(
                name=name,
                short_name=short_name,
                is_internal=is_internal != 'false' if is_internal else is_internal,
                is_active=is_active != 'false' if is_active else is_active,
                is_protected=is_protected != 'false' if is_protected else is_protected,
                is_hidden=is_hidden != 'false' if is_hidden else is_hidden,
                type=type,
                description=description
            )
            body['usage'] = argToList(usage)
            return self._http_request('PATCH', suffix, json_data=body)

        def delete_list(self, list_id: Optional[Any]) -> Dict:
            """Deletes a list using DELETE request

            Args:
                list_id: ID of a list.

            Returns:
                Response from API
            """
            suffix = f'/api/v3/lists/{list_id}'
            return self._http_request('DELETE', suffix, resp_type='content')

        def list_sensors(self, limit: int = None, offset: int = None, hostname: str = None, status: str = None) -> Dict:
            """Fetches sensors using GET request

            Args:
                limit: Number of results to return per page.
                offset: The initial index from which to return the results.
                hostname: Host name of the sensor.
                status: Status of the sensor.

            Returns:
                Response from API
            """
            suffix = '/api/v3/sensors'
            params = assign_params(
                limit=limit,
                offset=offset,
                hostname=hostname,
                status=status
            )
            return self._http_request('GET', suffix, params=params)

        def list_rules(self, limit: int = None, offset: int = None, sort: str = None, **kwargs) -> Dict:
            """Fetches rules using GET request

            Args:
                limit: Number of results to return per page.
                offset: The initial index from which to return the results.
                sort: Comma-separated list of field names to sort the results by.

            Returns:
                Response from API
            """
            suffix = '/api/v1/rules'
            params = assign_params(
                limit=limit,
                offset=offset,
                sort=sort
            )
            return self._http_request('GET', suffix, params=params)

        def edit_rule(self, rule_id: str, enabled: bool = None) -> Dict:
            """Edit a single rule using PATCH request

            Args:
                rule_id: ID of the rule.
                enabled: Is the rule enabled.

            Returns:
                Response from API
            """
            suffix = f'/api/v1/rules/{rule_id}'
            body = assign_params(enabled=enabled)
            return self._http_request('PATCH', suffix, json_data=body)

        def add_list_item(self, list_id: Optional[int], type: str, value: str, risk: str = None, notes: str = None) -> Dict:
            """Adds a single item list to a list

            Args:
                list_id: List id.
                type: Type of list item.
                value: Value of list item.
                risk: Risk of list item.
                notes: Notes for list item.

            Returns:
                Respone from API
            """
            suffix = f'/api/v3/lists/{list_id}/items'
            body = assign_params(
                type=type,
                value=value,
                risk=risk,
                notes=notes
            )
            return self._http_request('POST', suffix, json_data=body)

        def update_list_item(self, list_id: int, item_id: int, type: str = None, value: str = None, risk: str = None,
                             notes: str = None) -> Dict:
            """Updates a single item list

            Args:
                list_id: List id.
                item_id: Item id.
                type: Type of list item.
                value: Value of list item.
                risk: Risk of list item.
                notes: Notes for list item.

            Returns:
                Respone from API
            """
            suffix = f'/api/v3/lists/{list_id}/items/{item_id}'
            body = assign_params(
                type=type,
                value=value,
                risk=risk,
                notes=notes
            )
            return self._http_request('PATCH', suffix, json_data=body)

        def get_list_items(self, list_id: Optional[Any], offset: Optional[Any]) -> Dict:
            """Gets items of a list

            Args:
                list_id: List ID.
                offset: Offset in database.

            Returns:
                Response from API
            """
            suffix = f'/api/v3/lists/{list_id}/items'
            params = assign_params(offset=offset)
            return self._http_request('GET', suffix, params=params)

        def remove_list_item(self, list_id: Optional[Any], item_id: Optional[Any]) -> Dict:
            suffix = f'/api/v3/lists/{list_id}/items/{item_id}'
            return self._http_request('DELETE', suffix, resp_type='content')


    ''' HELPER FUNCTIONS '''


    def create_context_result(src: Union[Dict, List], trans_dict: Dict) -> Union[Dict, List]:
        """Builds a dictionary according to a transformation map

        Args:
            src (dict): original dictionary to build from
            trans_dict (dict): dict in the format { 'OldKey': 'NewKey', ...}

        Returns: src copy with changed keys
        """
        if isinstance(src, list):
            return [create_context_result(x, trans_dict) for x in src]
        res: Dict[str, Any] = {}
        for key, val in trans_dict.items():
            if isinstance(val, dict):
                # handle nested list
                sub_res = res
                item_val = [create_context_result(item, val) for item in (demisto.get(src, key) or [])]
                key = underscoreToCamelCase(key)
                for sub_key in key.split('.')[:-1]:
                    if sub_key not in sub_res:
                        sub_res[sub_key] = {}
                    sub_res = sub_res[sub_key]
                sub_res[key.split('.')[-1]] = item_val
            elif '.' in val:
                # handle nested vals
                update_nested_value(res, val, to_val=demisto.get(src, key))
            else:
                res[val] = demisto.get(src, key)
        return res


    def update_nested_value(src_dict: Dict[str, Any], to_key: str, to_val: Any) -> None:
        """
        Updates nested value according to transformation dict structure where 'a.b' key will create {'a': {'b': val}}
        Args:
            src_dict (dict): The original dict
            to_key (str): Key to transform to (expected to contain '.' to mark nested)
            to_val (any): The value that'll be put under the nested key
        """
        sub_res = src_dict
        to_key_lst = to_key.split('.')
        for sub_to_key in to_key_lst[:-1]:
            if sub_to_key not in sub_res:
                sub_res[sub_to_key] = {}
            sub_res = sub_res[sub_to_key]
        sub_res[to_key_lst[-1]] = to_val


    def alert_severity_to_dbot_score(severity_str):
        """Converts an severity string to DBot score representation
            alert severity. Can be one of:
            Low    ->  1
            Medium ->  2
            High   ->  3

        Args:
            severity_str: String representation of severity.

        Returns:
            Dbot representation of severity
        """
        severity_str = severity_str.lower()
        if severity_str == 'low':
            return 1
        if severity_str == 'medium':
            return 2
        elif severity_str == 'high':
            return 3
        return 0


    def build_mql_query(query: str, start: str = None, end: str = None, page_size: Union[int, str] = None,
                        limit: Union[str, int] = None, offset: Union[int, str] = None, groupby: str = None,
                        sort_by: str = None, sort_order: str = None) -> str:
        """Builds MQL query from given arguments

        Args:
            query: Query to execute. This is the search clause in an MQL.
            start: Start time of the event in date format yyyy-mm-dd or yyyy-mm.
            end: End time of the event in date format yyyy-mm-dd or yyyy-mm.
            page_size: Max amount of results to return.
            limit: Number of events to search.
            offset: Offset of the result.
            groupby: Returns the unique values for the specified field and groups them together.
            sort_by: Sorts results by this field.
            sort_order: Controls the order of the results sorted.

        Returns:
            MQL query
        """
        # Filter section
        if start:
            query += f' start="{start}"'
        if end:
            query += f' end="{end}"'
        if page_size or offset or limit:
            query += ' {'
            if page_size:
                query += f' page_size={page_size}'
            if offset:
                query += f' offset={offset}'
            if limit:
                query += f' limit={limit}'
            query += '}'
        # Transform section
        if groupby:
            query += f'| groupby [{groupby}]'
        if sort_by:
            sort_order = '>' if sort_order != 'asc' else '<'
            query += f'| sort {sort_order} {sort_by}'
        return query


    def build_search_groupby_result(aggregations: Dict, separator: str) -> List:
        """Builds groupby result from search aggregations

        Args:
            aggregations: Group object
            separator: Separator used in query and result

        Returns:
            Groupby result
        """
        res = []
        for key, aggregation in aggregations.items():
            if key.startswith('groupby'):
                groupby_fields = demisto.get(aggregation, 'meta.field') or demisto.get(aggregation, 'meta.fields')
                if groupby_fields:
                    if isinstance(groupby_fields, str):
                        groupby_fields = [groupby_fields]
                    for bucket in aggregation.get('buckets', []):
                        bucket_vals = bucket.get('key', '').split(separator)
                        group_set = {groupby_field: bucket_vals[idx] for idx, groupby_field in enumerate(groupby_fields)}
                        group_set['DocCount'] = bucket.get('doc_count')
                        res.append(group_set)
        return res


    def build_search_result(raw_response: dict, search_id: Union[str, int] = None, headers: List = None):
        """Builds search result from search raw_response

        Args:
            raw_response: Search raw response
            search_id: Search ID (relevant for archive search)
            headers: Headers to show in hr table

        Returns:
            Search result
        """
        results = raw_response.get('results')
        context = {'MQL': raw_response.get('mql')}
        if search_id:
            dt_query = 'val.ID && val.ID === obj.ID'
            context['ID'] = search_id
        else:
            dt_query = 'val.ID && val.ID === obj.ID' if search_id else 'val.MQL && val.MQL === obj.MQL'
        if results:
            # Search results
            hits = demisto.get(results, 'hits.hits')
            if hits:
                context['Result'] = []
                for hit in hits:
                    context['Result'].append(create_context_result(hit.get('_source'), EVENTS_TRANS))  # type: ignore
            # Human readable value is ok for both no result found and result found cases
            hr = tableToMarkdown(f'{INTEGRATION_NAME} - Search result for {context["MQL"]}', context.get('Result'),
                                 headers,
                                 headerTransform=pascalToSpace,
                                 removeNull=True)
            # Group by results
            aggregations = results.get('aggregations')
            if aggregations:
                separator = demisto.get(raw_response, 'options.groupby.separator') or '|%$,$%|'
                context['GroupBy'] = build_search_groupby_result(aggregations, separator)
                if context['GroupBy']:
                    group_by_keys = list(context['GroupBy'][0].keys())  # type: ignore
                    # move DocCount to tail
                    group_by_keys.remove('DocCount')
                    group_by_keys.append('DocCount')
                    hr += tableToMarkdown('Group By', context['GroupBy'], headers=group_by_keys)

            return hr, {f'{INTEGRATION_CONTEXT_NAME}Search({dt_query})': context}, raw_response
        else:
            # API should not return an empty result matching this case, this is a fail safe
            return f'{INTEGRATION_NAME} - Search did not find any result.', {}, {}


    def build_title_with_page_numbers(title: str, count: int, limit: int, offset: int) -> str:
        """Tries to build a title with page numbers from raw response and given title

        Args:
            title: Title without page numbers
            count: Total number of entries
            limit: Max amount of entries returned
            offset:

        Returns:

        """
        try:
            tot_pages = math.ceil(count / limit)
            page = math.floor((offset / count) * tot_pages) + 1
            # In case offset > count
            if page > tot_pages:
                page = tot_pages
            return f'{title}\n### Page {page}/{tot_pages}'
        except (TypeError, ValueError, ZeroDivisionError):
            return title


    def build_single_list_result(raw_response):
        """Builds a list result from API response

        Args:
            raw_response: API response to alert call

        Returns:
            List result
        """
        list_id = raw_response.get('id')
        title = f'{INTEGRATION_NAME} - List {list_id}:'
        context_entry = create_context_result(raw_response, LISTS_TRANS)
        context = {
            f'{INTEGRATION_CONTEXT_NAME}.List(val.ID && val.ID === obj.ID)': context_entry
        }
        # Creating human readable for War room
        human_readable = tableToMarkdown(title, context_entry, headerTransform=pascalToSpace)
        # Return data to Demisto
        return human_readable, context, raw_response


    ''' COMMANDS '''


    def test_module(client: Client, test_fetch: bool = False, fetch_time: Optional[str] = None, last_run: Dict = None,
                    *_) -> \
            Tuple[str, Dict, Dict]:
        """Performs a basic GET request to check if the API is reachable and authentication is successful.

        Args:
            client: Client object with request
            test_fetch: If set to true will test fetch_incidents
            fetch_time: If fetch is set, will pass to fetch_incidents to test
            last_run: Last fetch object.
            args: Usually demisto.args()

        Returns:
            'ok' if test successful.

        Raises:
            DemistoException: If test failed.
        """
        client.test_module()
        if test_fetch:
            fetch_incidents(client, fetch_time, last_run)  # type: ignore
        return 'ok', {}, {}


    def fetch_incidents(client: Client, fetch_time: Optional[str], last_run: Dict) -> Tuple[List, Dict]:
        """Uses to fetch incidents into Demisto
        Documentation: https://github.com/demisto/content/tree/master/docs/fetching_incidents

        Args:
            client: Client object with request
            fetch_time: From when to fetch if first time, e.g. `3 days`
            last_run: Last fetch object.

        Returns:
            incidents, new last_run
        """
        timestamp_format = '%Y-%m-%dT%H:%M:%S.%fZ'
        # Get incidents from API
        if not last_run:  # if first time running
            new_last_run = {'time': parse_date_range(fetch_time, date_format=timestamp_format)[0]}
        else:
            new_last_run = last_run
        incidents: List = list()
        raw_response = client.list_alerts(created_at__gte=new_last_run.get('time'))
        alerts = raw_response.get('results')
        if alerts:
            last_incident_id = last_run.get('id', 0)
            # Creates incident entry
            incidents = [{
                'name': f"{INTEGRATION_NAME}: {alert.get('id')}",
                'occurred': alert.get('created_at'),
                'severity': alert_severity_to_dbot_score(alert.get('severity')),
                'rawJSON': json.dumps(alert)
            } for alert in alerts if alert.get('id') > last_incident_id]
            # New incidents fetched
            if incidents:
                last_incident_timestamp = incidents[-1].get('occurred')
                last_incident_id = alerts[-1].get('id')
                new_last_run = {'time': last_incident_timestamp, 'id': last_incident_id}
        # Return results
        return incidents, new_last_run


    def list_alerts_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Lists all alerts and return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        limit = int(args.get('page_size') or DEFAULT_PAGE_SIZE)
        headers = argToList(args.get('headers'))
        # api response for limit=0 is equivalent to limit=30
        if limit == 0:
            limit = DEFAULT_PAGE_SIZE
        offset = int(args.get('offset') or 0)
        raw_response = client.list_alerts(limit=limit, offset=offset)
        alerts = raw_response.get('results')
        if alerts:
            count = demisto.get(raw_response, 'meta.count')
            title = f'{INTEGRATION_NAME} - List alerts:'
            try:
                count = int(count)
                title = build_title_with_page_numbers(title, count, limit, offset)
            except (TypeError, ValueError):
                # don't change title if count ins't an int
                pass
            context_entry = create_context_result(alerts, ALERTS_TRANS)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Alert(val.ID && val.ID === obj.ID)': context_entry,
                f'{INTEGRATION_CONTEXT_NAME}.Alert(val.Count).Count': count
            }
            if not headers:
                headers = ['ID', 'Name', 'Description', 'State', 'Severity']
            human_readable = tableToMarkdown(title, context_entry, headers)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any alerts.', {}, {}


    def get_alert_by_id_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Get alert by id and return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        _id = args.get('id')
        headers = argToList(args.get('headers'))
        raw_response = client.get_alert_by_id(_id=_id)
        if raw_response:
            title = f'{INTEGRATION_NAME} - Alert {_id}:'
            context_entry = create_context_result(raw_response, ALERTS_TRANS)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Alert(val.ID && val.ID === obj.ID)': context_entry
            }
            human_readable = tableToMarkdown(title, context_entry, headers=headers, removeNull=True)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any alerts.', {}, {}


    def get_alert_notes_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Get all notes related to alert

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        alert_id = args.get('alert_id')
        raw_response = client.get_alert_notes(alert_id=alert_id)
        raw_notes = raw_response.get('results')
        if raw_notes:
            title = f'{INTEGRATION_NAME} - Notes for Alert {alert_id}:'
            context_entry = create_context_result(raw_notes, NOTES_TRANS)
            if isinstance(context_entry, dict):
                context_entry['AlertID'] = alert_id
            else:
                for note in context_entry:
                    note['AlertID'] = alert_id
            count = demisto.get(raw_response, 'meta.count')
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Note(val.ID && val.ID === obj.ID)': context_entry,
                f'{INTEGRATION_CONTEXT_NAME}.Note(val.Count && val.AlertID === {alert_id}).Count': count
            }
            # Creating human readable for War room
            human_readable = tableToMarkdown(title, context_entry, ['ID', 'CreatorName', 'Message', 'CreatedTime'],
                                             headerTransform=pascalToSpace)
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - No notes were found for alert {alert_id}.', {}, {}


    def create_alert_note_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Create a note for an alert

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        alert_id = args.get('alert_id')
        note = args.get('note')
        raw_response = client.create_alert_note(alert_id=alert_id, note=note)
        if raw_response:
            title = f'{INTEGRATION_NAME} - Created Note for Alert {alert_id}:'
            context_entry = create_context_result(raw_response, NOTES_TRANS)
            if isinstance(context_entry, dict):
                context_entry['AlertID'] = alert_id
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Note(val.ID && val.ID === obj.ID)': context_entry
            }
            # Creating human readable for War room
            human_readable = tableToMarkdown(title, context_entry, ['ID', 'CreatorName', 'Message', 'CreatedTime'],
                                             headerTransform=pascalToSpace)
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not create a note.', {}, {}


    def delete_alert_note_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Delete a note for an alert

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        alert_id = args.get('alert_id')
        note_id = args.get('note_id')
        client.delete_alert_note(alert_id=alert_id, note_id=note_id)
        return f'{INTEGRATION_NAME} - Deleted note {note_id} for Alert {alert_id} successfully.', {}, {}


    def get_events_by_alert_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Get events for a specific alert

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        alert_id = args.get('alert_id')
        headers = argToList(args.get('headers'))
        raw_response = client.get_events_by_alert(alert_id=alert_id)
        events = raw_response.get('results')
        if events:
            title = f'{INTEGRATION_NAME} - Events for alert {alert_id}:'
            context_entry = create_context_result(events, EVENTS_TRANS)
            count = demisto.get(raw_response, 'meta.count')
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Event(val.ID && val.ID === obj.ID)': context_entry,
                f'{INTEGRATION_CONTEXT_NAME}.Event(val.Count).Count': count
            }
            # Creating human readable for War room
            human_readable = tableToMarkdown(title, context_entry,
                                             headers,
                                             headerTransform=pascalToSpace,
                                             removeNull=True)
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any events.', {}, {}


    def get_endpoints_by_alert_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Fetch endpoints of a specific alert

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        alert_id = args.get('alert_id')
        raw_response = client.get_endpoints_by_alert(alert_id=alert_id, offset=args.get('offset'))
        endpoints = demisto.get(raw_response, 'results.endpoints')
        if endpoints:
            title = f'{INTEGRATION_NAME} - Endpoints for alert {alert_id}:'
            context_entry = create_context_result(endpoints, ENDPOINTS_TRANS)
            count = demisto.get(raw_response, 'meta.count')
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Endpoint(val.ID && val.ID === obj.ID)': context_entry,
                f'{INTEGRATION_CONTEXT_NAME}.Endpoint(val.Count).Count': count
            }
            # Creating human readable for War room
            human_readable = tableToMarkdown(title, context_entry,
                                             ['ID', 'DeviceID', 'Hostname', 'IP', 'MACAddress', 'UpdatedTime'],
                                             headerTransform=pascalToSpace)
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any endpoints.', {}, {}


    def get_cases_by_alert_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Fetch cases of a specific alert

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        alert_id = args.get('alert_id')
        raw_response = client.get_cases_by_alert(alert_id=alert_id, limit=args.get('page_size'), offset=args.get('offset'),
                                                 order_by=args.get('order_by'))
        cases = raw_response.get('results')
        if cases:
            title = f'{INTEGRATION_NAME} - Cases for alert {alert_id}:'
            context_entry = create_context_result(cases, CASES_TRANS)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Case(val.ID && val.ID === obj.ID)': context_entry
            }
            # Creating human readable for War room
            human_readable = tableToMarkdown(title, context_entry,
                                             ['ID', 'Name', 'AssigneeName', 'Priority', 'Severity', 'State', 'Status',
                                              'ModifiedTime'], removeNull=True)
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any cases.', {}, {}


    def get_lists_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Get lists return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        is_active = args.get('is_active')
        is_internal = args.get('is_internal')
        is_protected = args.get('is_protected')
        raw_response = client.get_lists(
            limit=args.get('page_size'),
            offset=args.get('offset'),
            created_at=args.get('created_at'),
            description=args.get('description'),
            is_active=is_active and is_active != 'false',
            is_internal=is_internal and is_internal != 'false',
            is_protected=is_protected and is_protected != 'false',
            name=args.get('name'),
            short_name=args.get('short_name'),
            type=args.get('type'),
            updated_at=args.get('updated_at'),
            usage=args.get('usage'),
            order_by=args.get('order_by')
        )
        lists = raw_response.get('results')
        if lists:
            title = f'{INTEGRATION_NAME} - Lists:'
            context_entry = create_context_result(lists, LISTS_TRANS)
            count = demisto.get(raw_response, 'meta.count')
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.List(val.ID && val.ID === obj.ID)': context_entry,
                f'{INTEGRATION_CONTEXT_NAME}.List(val.Count).Count': count
            }
            # Creating human readable for War room
            human_readable = tableToMarkdown(title, context_entry, ['ID', 'Name', 'ContentTypes', 'UpdatedTime'],
                                             headerTransform=pascalToSpace)
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any lists.', {}, {}


    def get_list_by_id_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Get a list by ID return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        list_id = args.get('id')
        raw_response = client.get_list_by_id(list_id)
        if raw_response:
            return build_single_list_result(raw_response)
        else:
            return f'{INTEGRATION_NAME} - Could not find the list.', {}, raw_response


    def create_list_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Create a list. return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        is_internal = args.get('is_internal')
        is_active = args.get('is_active')
        is_protected = args.get('is_protected')
        is_hidden = args.get('is_hidden')
        raw_response = client.create_list(
            name=args.get('name'),
            short_name=args.get('short_name'),
            is_internal=is_internal != 'false' if is_internal else is_internal,
            is_active=is_active != 'false' if is_active else is_active,
            is_protected=is_protected != 'false' if is_protected else is_protected,
            is_hidden=is_hidden != 'false' if is_hidden else is_hidden,
            type=args.get('type'),
            description=args.get('description')
        )
        if raw_response:
            return build_single_list_result(raw_response)
        else:
            return f'{INTEGRATION_NAME} - Created list successfully.', {}, raw_response


    def update_list_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Update a list. return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        is_internal = args.get('is_internal')
        is_active = args.get('is_active')
        is_protected = args.get('is_protected')
        is_hidden = args.get('is_hidden')
        raw_response = client.update_list(
            list_id=int(args.get('list_id')),  # type: ignore
            name=args.get('name'),
            short_name=args.get('short_name'),
            is_internal=is_internal != 'false' if is_internal else is_internal,
            is_active=is_active != 'false' if is_active else is_active,
            is_protected=is_protected != 'false' if is_protected else is_protected,
            is_hidden=is_hidden != 'false' if is_hidden else is_hidden,
            type=args.get('type'),
            description=args.get('description')
        )
        if raw_response:
            return build_single_list_result(raw_response)
        else:
            return f'{INTEGRATION_NAME} - Updated list successfully.', {}, raw_response


    def delete_list_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Update a list. return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        list_id = args.get('list_id')
        raw_response = client.delete_list(list_id)
        return f'{INTEGRATION_NAME} - Deleted list successfully.', {}, raw_response


    def add_list_item_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Adds a list item. return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        list_id = args.get('list_id')
        raw_response = client.add_list_item(
            list_id=list_id,
            type=str(args.get('type')),
            value=str(args.get('value')),
            risk=args.get('risk'),
            notes=args.get('notes')
        )
        if raw_response:
            item_id = raw_response.get('id')
            title = f'{INTEGRATION_NAME} - List item {item_id} was added successfully to {list_id}'
            context_entry = create_context_result(raw_response, LIST_ITEM_TRANS)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}List(val.ID && val.ID === {list_id}).Item': context_entry
            }
            human_readable = tableToMarkdown(title, context_entry)
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not create list item.', {}, raw_response


    def update_list_item_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Updates a list item. return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        list_id = int(args.get('list_id'))  # type: ignore
        item_id = int(args.get('item_id'))  # type: ignore
        raw_response = client.update_list_item(
            list_id=list_id,
            item_id=item_id,
            type=args.get('type'),
            value=args.get('value'),
            risk=args.get('risk'),
            notes=args.get('notes')
        )
        if raw_response:
            title = f'{INTEGRATION_NAME} - List item {item_id} from list {list_id} was updated successfully'
            context_entry = create_context_result(raw_response, LIST_ITEM_TRANS)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}List(val.ID && val.ID === {list_id}).Item(val.ID === obj.ID)': context_entry
            }
            human_readable = tableToMarkdown(title, context_entry)
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not update list item.', {}, raw_response


    def remove_list_item_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Updates a list item. return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        list_id = args.get('list_id')
        item_id = args.get('item_id')
        raw_response = client.remove_list_item(list_id=list_id, item_id=item_id)
        return f'{INTEGRATION_NAME} - Removed item {item_id} from list {list_id} successfully', {}, raw_response


    def get_list_items_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Fetches list items

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        list_id = args.get('list_id')
        raw_response = client.get_list_items(list_id, args.get('offset'))
        results = raw_response.get('results')
        if results:
            title = f'{INTEGRATION_NAME} - List items for list {list_id}'
            context_entry = create_context_result(results, LIST_ITEM_TRANS)
            count = demisto.get(raw_response, 'meta.count')
            context = {
                f'{INTEGRATION_CONTEXT_NAME}List(val.ID && val.ID === {list_id}).Item(val.ID === obj.ID)': context_entry,
                f'{INTEGRATION_CONTEXT_NAME}List(val.ID && val.ID === {list_id}).Count(val.Count)': count
            }
            human_readable = tableToMarkdown(title, context_entry)
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - No items were found for list {list_id}.', {}, raw_response


    def list_sensors_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Lists all sensors and return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        raw_response = client.list_sensors(
            limit=int(args.get('page_size') or 0),
            offset=int(args.get('offset') or 0),
            hostname=args.get('hostname'),
            status=args.get('status')
        )
        sensors = raw_response.get('results')
        if sensors:
            title = f'{INTEGRATION_NAME} - List sensors:'
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Sensor(val.id && val.ID === obj.id)': sensors
            }
            # Creating human readable for War room
            human_readable = tableToMarkdown(title, sensors)
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any sensors.', {}, {}


    def list_rules_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Lists all rules and return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        limit = int(args.get('page_size') or DEFAULT_PAGE_SIZE)
        offset = int(args.get('offset') or 0)
        raw_response = client.list_rules(
            limit=limit,
            offset=offset,
            sort=args.get('sort')
        )
        rules = raw_response.get('rules')
        if rules:
            count = demisto.get(raw_response, 'meta.totalCount')
            title = f'{INTEGRATION_NAME} - List rules:'
            try:
                count = int(count)
                title = build_title_with_page_numbers(title, count, limit, offset)
            except (TypeError, ValueError):
                # don't change title if count ins't an int
                pass
            context_entry = create_context_result(rules, RULES_TRANS)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Rule(val.ID && val.ID === obj.ID)': context_entry,
                f'{INTEGRATION_CONTEXT_NAME}.Rule(val.Count)': count
            }
            # Creating human readable for War room
            human_readable = tableToMarkdown(title, context_entry,
                                             ['ID', 'Type', 'Description', 'Risk', 'Confidence', 'Severity', 'Enabled'])
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find any rules.', {}, {}


    def edit_rule_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Edit a single rule and return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        rule_id = str(args.get('rule_id'))
        enabled = args.get('enabled')
        raw_response = client.edit_rule(rule_id, enabled != 'false' if enabled else None)
        rules = raw_response.get('rules')
        if rules:
            title = f'{INTEGRATION_NAME} - Successfully updated rule {rule_id}:'
            context_entry = create_context_result(rules, RULES_TRANS)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}.Rule(val.ID && val.ID === obj.ID)': context_entry
            }
            # Creating human readable for War room
            human_readable = tableToMarkdown(title, context_entry,
                                             ['ID', 'Type', 'Description', 'Risk', 'Confidence', 'Severity'])
            # Return data to Demisto
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Could not find matching rule.', {}, {}


    def search_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Searches FireEye Helix database using MQL

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        query = build_mql_query(**args)
        raw_response = client.search(query)
        headers = argToList(args.get('headers'))
        return build_search_result(raw_response, headers=headers)


    def archive_search_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Searches FireEye Helix database using MQL

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        query = build_mql_query(**args)
        raw_response = client.archive_search(query)
        data = raw_response.get('data')
        if data:
            title = f'{INTEGRATION_NAME} - Successfully created archive search'
            context_entry = create_context_result(data, ARCHIVE_SEARCH_TRANS)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}Search(val.ID === obj.ID)': context_entry
            }
            human_readable = tableToMarkdown(title, context_entry, headerTransform=pascalToSpace)
            return human_readable, context, raw_response
        else:
            return f'{INTEGRATION_NAME} - Failed to create archive search', {}, raw_response


    def archive_search_status_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Fetches the status of an archive search

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        search_ids = argToList(args.get('search_id'))
        raw_res_lst = []
        context_entry = []
        for s_id in search_ids:
            i_s_id = int(s_id)
            raw_res = client.get_archive_search(i_s_id)
            if raw_res:
                data = raw_res.get('data')
                if isinstance(data, list):
                    context_entry.append(create_context_result(data[0], ARCHIVE_SEARCH_TRANS))
                raw_res_lst.append(raw_res)
        if raw_res_lst:
            title = f'{INTEGRATION_NAME} - Search status'
            human_readable = tableToMarkdown(title, context_entry, headerTransform=pascalToSpace)
            context = {
                f'{INTEGRATION_CONTEXT_NAME}Search(val.ID === obj.ID)': context_entry
            }
            return human_readable, context, raw_res_lst  # type: ignore
        else:
            return f'{INTEGRATION_NAME} - Failed to get archive search details', {}, {}


    def archive_search_results_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Fetches an archive search result

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs
        """
        search_id = int(args.get('search_id'))  # type: ignore
        raw_response = client.get_archive_search_results(search_id)
        return build_search_result(raw_response.get('results'), search_id)


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    def main():  # pragma: no cover
        params = demisto.params()
        base_url = f"{params.get('url', '').rstrip('/')}"
        if not base_url.endswith('/helix/id'):
            base_url += '/helix/id'
        base_url += f"/{params.get('h_id')}"
        verify_ssl = not params.get('insecure', False)
        proxy = params.get('proxy')
        headers = {
            'accept': 'application/json',
            'x-fireeye-api-key': params.get('token')
        }
        client = Client(base_url=base_url, verify=verify_ssl, proxy=proxy, headers=headers)
        command = demisto.command()
        demisto.info(f'Command being called is {command}')

        # Switch case
        commands = {
            f'{INTEGRATION_COMMAND_NAME}-list-alerts': list_alerts_command,
            f'{INTEGRATION_COMMAND_NAME}-get-alert-by-id': get_alert_by_id_command,
            f'{INTEGRATION_COMMAND_NAME}-alert-get-notes': get_alert_notes_command,
            f'{INTEGRATION_COMMAND_NAME}-alert-create-note': create_alert_note_command,
            f'{INTEGRATION_COMMAND_NAME}-alert-delete-note': delete_alert_note_command,
            f'{INTEGRATION_COMMAND_NAME}-get-events-by-alert': get_events_by_alert_command,
            f'{INTEGRATION_COMMAND_NAME}-get-endpoints-by-alert': get_endpoints_by_alert_command,
            f'{INTEGRATION_COMMAND_NAME}-get-cases-by-alert': get_cases_by_alert_command,
            f'{INTEGRATION_COMMAND_NAME}-get-lists': get_lists_command,
            f'{INTEGRATION_COMMAND_NAME}-get-list-by-id': get_list_by_id_command,
            f'{INTEGRATION_COMMAND_NAME}-create-list': create_list_command,
            f'{INTEGRATION_COMMAND_NAME}-update-list': update_list_command,
            f'{INTEGRATION_COMMAND_NAME}-delete-list': delete_list_command,
            f'{INTEGRATION_COMMAND_NAME}-get-list-items': get_list_items_command,
            f'{INTEGRATION_COMMAND_NAME}-add-list-item': add_list_item_command,
            f'{INTEGRATION_COMMAND_NAME}-update-list-item': update_list_item_command,
            f'{INTEGRATION_COMMAND_NAME}-remove-list-item': remove_list_item_command,
            f'{INTEGRATION_COMMAND_NAME}-list-sensors': list_sensors_command,
            f'{INTEGRATION_COMMAND_NAME}-list-rules': list_rules_command,
            f'{INTEGRATION_COMMAND_NAME}-edit-rule': edit_rule_command,
            f'{INTEGRATION_COMMAND_NAME}-search': search_command,
            f'{INTEGRATION_COMMAND_NAME}-archive-search': archive_search_command,
            f'{INTEGRATION_COMMAND_NAME}-archive-search-get-status': archive_search_status_command,
            f'{INTEGRATION_COMMAND_NAME}-archive-search-get-results': archive_search_results_command,
        }
        try:
            if command == 'test-module':
                fetch_time = params.get('fetch_time')
                is_fetch = params.get('isFetch')
                last_run = demisto.getLastRun()
                readable_output, outputs, raw_response = test_module(client, bool(is_fetch), fetch_time, last_run)
                return_outputs(readable_output, outputs, raw_response)
            elif command == 'fetch-incidents':
                fetch_time = params.get('fetch_time')
                incidents, last_run = fetch_incidents(client, fetch_time, last_run=demisto.getLastRun())  # type: ignore
                demisto.incidents(incidents)
                demisto.setLastRun(last_run)
            elif command in commands:
                readable_output, outputs, raw_response = commands[command](client, demisto.args())  # type: ignore
                return_outputs(readable_output, outputs, raw_response)
        # Log exceptions
        except Exception as e:
            err_msg = str(e)
            if '[401]' in err_msg:
                return_error('Encountered an issue accessing the API. Please make sure you entered the right Helix ID and '
                             'API Token.')
            elif 'requests.exceptions' in err_msg:
                return_error('Encountered an error reaching the endpoint, please verify that the server URL parameter'
                             ' is correct and that you have access to the server from your host.')
            else:
                return_error(f'Error in {INTEGRATION_NAME} Integration [{e}]', error=e)


    if __name__ == 'builtins':  # pragma: no cover
        main()
  subtype: python3
  type: python
system: true
