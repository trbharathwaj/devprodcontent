category: IT Services
commonfields:
  id: Microsoft Graph Groups
  version: -1
configuration:
- defaultvalue: https://graph.microsoft.com
  display: Server URL
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: ID (received from the admin consent - see Detailed Instructions (?)
  name: auth_id
  required: true
  type: 4
- defaultvalue: ""
  display: Token (received from the admin consent - see Detailed Instructions (?)
    section)
  name: tenant_id
  required: true
  type: 4
- defaultvalue: ""
  display: Key (received from the admin consent - see Detailed Instructions (?)
  name: enc_key
  required: true
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Microsoft Graph Groups enables you to create and manage different types
  of groups and group functionality according to your requirements.
detaileddescription: |
  To allow access to Microsoft Graph Groups, an administrator has to approve the Demisto app using an admin consent flow, by clicking on the following [link](https://oproxy.demisto.ninja/ms-graph-groups).
  After authorizing the Demisto app, you will get an ID, Token, and Key, which needs to be added to the integration instance configuration's corresponding fields.

  Required Permissions in the MS Graph Groups App:
  Directory.ReadWrite.All - Delegated
  Directory.ReadWrite.All - Application
  Group.ReadWrite.All - Application
display: Microsoft Graph Groups
image: data:image/png;base64,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
name: Microsoft Graph Groups
script:
  commands:
  - arguments:
    - description: Sorts groups in an organization by the field values. For example,
        displayName.
      name: order_by
    - description: The URL to the next results page.
      name: next_link
    - defaultValue: "100"
      description: Sets the page size of the results.
      name: top
    - description: Filters group results. For example, startswith(displayName,'J'),
        groupTypes/any(c:c+eq+'Unified').
      name: filter
    description: Provides a list of groups.
    name: msgraph-groups-list-groups
    outputs:
    - contextPath: MSGraphGroups.Classification
      description: A classification for the group (such as low, medium or high business
        impact).
      type: String
    - contextPath: MSGraphGroups.CreatedDateTime
      description: The timestamp when the group was created.
      type: String
    - contextPath: MSGraphGroups.DeletedDateTime
      description: The timestamp when the group was deleted.
      type: String
    - contextPath: MSGraphGroups.Description
      description: An optional description for the group.
      type: String
    - contextPath: MSGraphGroups.GroupTypes
      description: |-
        Specifies the group type and its membership.
        If the group collection contains a Unified value, the group is an Office 365 group; otherwise it's a security group.
        If the collection includes DynamicMembership, the group has dynamic membership; otherwise, membership is static.
      type: String
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.IsAssignableToRole
      description: Whether the group assigned to a specific role.
      type: String
    - contextPath: MSGraphGroup.Mail
      description: The SMTP address for the group. For example, "serviceadmins@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroup.MailEnabled
      description: Specifies whether the group is mail-enabled.
      type: Boolean
    - contextPath: MSGraphGroup.MailNickname
      description: The mail alias for the group, which is unique in the organization.
      type: String
    - contextPath: MSGraphGroup.OnPremisesDomainName
      description: Contains the on-premises domain FQDN. Also called dnsDomainName,
        which is synchronized from the on-premises directory.
      type: String
    - contextPath: MSGraphGroup.OnPremisesLastSyncDateTime
      description: Indicates the last time at which the group was synced with the
        on-premises directory. The Timestamp type represents date and time information
        using ISO 8601 format in UTC time. For example, midnight UTC on Jan 1, 2019
        is '2019-01-01T00:00:00Z'.
      type: String
    - contextPath: MSGraphGroup.OnPremisesSyncEnabled
      description: |
        Whether this group is synced from an on-premises directory (true). This group was originally synced from an on-premises directory but is no longer synced (false). Null if this object has never been synced from an on-premises directory (default).
      type: String
    - contextPath: MSGraphGroup.ProxyAddresses
      description: 'Email addresses for the group that directs to the same group mailbox.
        For example: ["SMTP: support@demisto.com", "smtp: support@demisto.com"].'
      type: String
    - contextPath: MSGraphGroup.RenewedDateTime
      description: Timestamp of when the group was last renewed, which represents
        the time and date information using ISO 8601 format. Always in UTC time. For
        example, midnight UTC on Jan 1, 2019 is '2019-01-01T00:00:00Z'.
      type: String
    - contextPath: MSGraphGroup.SecurityEnabled
      description: Specifies whether the group is a security group.
      type: Boolean
    - contextPath: MSGraphGroup.Visibility
      description: 'Specifies the visibility of an Office 365 group. Can be: "Private",
        "Public", or "Hiddenmembership". Blank values are treated as public.'
      type: String
    - contextPath: MSGraphGroup.NextLink
      description: The URL of the next results page.
      type: String
  - arguments:
    - description: The ID of the group.
      name: group_id
      required: true
    description: Returns details of a group.
    name: msgraph-groups-get-group
    outputs:
    - contextPath: MSGraphGroups.Classification
      description: A classification for the group (such as low, medium or high business
        impact).
      type: String
    - contextPath: MSGraphGroups.CreatedDateTime
      description: The timestamp when the group was created.
      type: String
    - contextPath: MSGraphGroups.DeletedDateTime
      description: The timestamp when the group was deleted.
      type: String
    - contextPath: MSGraphGroups.Description
      description: An optional description for the group.
      type: String
    - contextPath: MSGraphGroups.GroupTypes
      description: |-
        Specifies the group type and its membership.
        If the group collection contains a Unified value, the group is an Office 365 group; otherwise it's a security group.
        If the collection includes DynamicMembership, the group has dynamic membership; otherwise, membership is static.
      type: String
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.IsAssignableToRole
      description: Whether the group assigned to a specific role.
      type: String
    - contextPath: MSGraphGroup.Mail
      description: The SMTP address for the group. For example, "serviceadmins@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroup.MailEnabled
      description: Specifies whether the group is mail-enabled.
      type: Boolean
    - contextPath: MSGraphGroup.MailNickname
      description: The mail alias for the group, unique in the organization.
      type: String
    - contextPath: MSGraphGroup.OnPremisesDomainName
      description: Contains the on-premises domain FQDN. Also called dnsDomainName,
        which is synchronized from the on-premises directory.
      type: String
    - contextPath: MSGraphGroup.OnPremisesLastSyncDateTime
      description: Indicates the last time at which the group was synced with the
        on-premises directory.The Timestamp type represents date and time information
        using ISO 8601 format in UTC time. For example, midnight UTC on Jan 1, 2019
        is '2019-01-01T00:00:00Z'.
      type: String
    - contextPath: MSGraphGroup.OnPremisesSyncEnabled
      description: |
        Whether the group is synced from an on-premises directory (true). This group was originally synced from an on-premises directory but is no longer synced (false). Null if this object has never been synced from an on-premises directory (default).
      type: String
    - contextPath: MSGraphGroup.ProxyAddresses
      description: 'Email addresses for the group that directs to the same group mailbox.
        For example: ["SMTP: support@demisto.com", "smtp: support@demisto.com"].'
      type: String
    - contextPath: MSGraphGroup.RenewedDateTime
      description: The timestamp of when the group was last renewed. This cannot be
        modified directly and is only updated via the renew service action. The Timestamp
        type represents date and time information using ISO 8601 format in UTC time.
        For example, midnight UTC on Jan 1, 2019 is '2019-01-01T00:00:00Z'.
      type: String
    - contextPath: MSGraphGroup.SecurityEnabled
      description: Specifies whether the group is a security group.
      type: Boolean
    - contextPath: MSGraphGroup.Visibility
      description: 'Specifies the visibility of an Office 365 group. Possible values
        are: Private, Public, or Hiddenmembership. Blank values are treated as public.'
      type: String
  - arguments:
    - description: The display name of the group.
      name: display_name
      required: true
    - auto: PREDEFINED
      description: Set to true for mail-enabled groups. False for groups without an
        email.
      name: mail_enabled
      predefined:
      - "false"
      - "true"
    - description: The mail alias for the group.
      name: mail_nickname
      required: true
    - auto: PREDEFINED
      description: Set to true for security groups. False for non security groups
        (regular groups).
      name: security_enabled
      predefined:
      - "false"
      - "true"
      required: true
    description: Create a group.
    name: msgraph-groups-create-group
    outputs:
    - contextPath: MSGraphGroups.Classification
      description: A classification for the group (such as low, medium or high business
        impact).
      type: String
    - contextPath: MSGraphGroups.CreatedDateTime
      description: The timestamp when the group was created.
      type: String
    - contextPath: MSGraphGroups.DeletedDateTime
      description: The timestamp when the group was deleted.
      type: String
    - contextPath: MSGraphGroups.Description
      description: An optional description for the group.
      type: String
    - contextPath: MSGraphGroups.GroupTypes
      description: |-
        Specifies the group type and its membership.
        If the group collection contains a Unified value, the group is an Office 365 group; otherwise it's a security group.
        If the group collection includes DynamicMembership, the group has dynamic membership; otherwise, membership is static.
      type: String
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.IsAssignableToRole
      description: Whether the group is assigned to a specific role.
      type: String
    - contextPath: MSGraphGroup.Mail
      description: The SMTP address for the group. For example, "serviceadmins@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroup.MailEnabled
      description: Specifies whether the group is mail-enabled.
      type: Boolean
    - contextPath: MSGraphGroup.MailNickname
      description: The mail alias for the group, unique in the organization.
      type: String
    - contextPath: MSGraphGroup.OnPremisesDomainName
      description: Contains the on-premises domain FQDN. Also called dnsDomainName,
        which is synchronized from the on-premises directory.
      type: String
    - contextPath: MSGraphGroup.OnPremisesLastSyncDateTime
      description: Indicates the last time at which the group was synced with the
        on-premises directory.The Timestamp type represents date and time information
        using ISO 8601 format in UTC time. For example, midnight UTC on Jan 1, 2019
        is '2019-01-01T00:00:00Z'.
      type: String
    - contextPath: MSGraphGroup.OnPremisesSyncEnabled
      description: |
        Whether this group is synced from an on-premises directory (true). This group was originally synced from an on-premises directory but is no longer synced (false). Null if this object has never been synced from an on-premises directory (default).
      type: String
    - contextPath: MSGraphGroup.ProxyAddresses
      description: 'Email addresses for the group that directs to the same group mailbox.
        For example, ["SMTP: support@demisto.com", "smtp: support@demisto.com"].'
      type: String
    - contextPath: MSGraphGroup.RenewedDateTime
      description: 'Timestamp of when the group was last renewed. This cannot be modified
        directly and is only updated via the renew service action. The Timestamp type
        represents date and time information using ISO 8601 format and is always in
        UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: ''2014-01-01T00:00:00Z''.'
      type: String
    - contextPath: MSGraphGroup.SecurityEnabled
      description: Specifies whether the group is a security group.
      type: Boolean
    - contextPath: MSGraphGroup.Visibility
      description: 'Specifies the visibility of an Office 365 group. Possible values
        are: Private, Public, or Hiddenmembership; blank values are treated as public.'
      type: String
  - arguments:
    - description: The group ID.
      name: group_id
      required: true
    description: Deletes a group.
    name: msgraph-groups-delete-group
    outputs:
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.Deleted
      description: Specifies whether the group was deleted.
      type: Boolean
  - arguments:
    - description: The group ID.
      name: group_id
      required: true
    - description: The URL for the next results page.
      name: next_link
    - defaultValue: "100"
      description: Sets the page size of results.
      name: top
    - description: Filters members results. For example, startswith(displayName,'user').
      name: filter
    description: Lists group members.
    name: msgraph-groups-list-members
    outputs:
    - contextPath: MSGraphGroups.Members.BussinessPhones
      description: The telephone numbers for the user.
      type: String
    - contextPath: MSGraphGroups.Members.GivenName
      description: The given name (first name) of the user.
      type: String
    - contextPath: MSGraphGroups.Members.MobilePhone
      description: The primary mobile telephone number for the user.
      type: String
    - contextPath: MSGraphGroups.Members.DisplayName
      description: |-
        The name displayed in the address book for the user.
        Usually the combination of the user's first name, middle initial and last name.
      type: String
    - contextPath: MSGraphGroups.Members.UserPrincipalName
      description: |-
        The user principal name (UPN) of the user.
        The UPN is an Internet-style login name for the user based on the Internet standard RFC 822.
        By convention, this should map to the user's email name.
        The general format is alias@domain, where the domain must be present in the tenant’s collection of verified domains.
      type: Unknown
    - contextPath: MSGraphGroups.Members.OfficeLocation
      description: The office location in the user's place of business.
      type: String
    - contextPath: MSGraphGroups.Members.Mail
      description: The SMTP address for the user. For example, "jeff@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroups.Members.PreferredLanguage
      description: The preferred language for the user. Should follow ISO 639-1 Code.
        For example, "en-US".
      type: String
    - contextPath: MSGraphGroups.Members.Surname
      description: The user's surname (family name or last name).
      type: String
    - contextPath: MSGraphGroups.Members.JobTitle
      description: The user’s job title.
      type: String
    - contextPath: MSGraphGroups.Members.ID
      description: The unique identifier for the user.
      type: String
  - arguments:
    - description: The group ID.
      name: group_id
      required: true
    - description: The user ID.
      name: user_id
      required: true
    description: Add a member to a group.
    name: msgraph-groups-add-member
  - arguments:
    - description: The group ID.
      name: group_id
      required: true
    - description: The user ID.
      name: user_id
      required: true
    description: Removes a member from a group.
    name: msgraph-groups-remove-member
  dockerimage: demisto/crypto:1.0.0.4187
  runonce: false
  script: |
    from typing import Dict, Tuple, Optional, Any
    from datetime import datetime
    import base64
    import urllib3
    import requests
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM


    # Disable insecure warnings
    urllib3.disable_warnings()

    INTEGRATION_CONTEXT_NAME = 'MSGraphGroups'
    NO_OUTPUTS: dict = {}
    APP_NAME = 'ms-graph-groups'


    def camel_case_to_readable(text: str) -> str:
        """'camelCase' -> 'Camel Case'

        Args:
            text: the text to transform

        Returns:
            A Camel Cased string.
        """
        if text == 'id':
            return 'ID'
        return ''.join(' ' + char if char.isupper() else char.strip() for char in text).strip().title()


    def parse_outputs(groups_data: Dict[str, str]) -> Tuple[dict, dict]:
        """Parse group data as received from Microsoft Graph API into Demisto's conventions

        Args:
            groups_data: a dictionary containing the group data

        Returns:
            A Camel Cased dictionary with the relevant fields.
            groups_readable: for the human readable
            groups_outputs: for the entry context
        """
        # Unnecessary fields, dropping as to not load the incident context.
        fields_to_drop = ['@odata.context', '@odata.nextLink', '@odata.deltaLink', '@odata.type', '@removed',
                          'resourceProvisioningOptions', 'securityIdentifier', 'onPremisesSecurityIdentifier',
                          'onPremisesNetBiosName', 'onPremisesProvisioningErrors', 'onPremisesSamAccountName',
                          'resourceBehaviorOptions', 'creationOptions', 'preferredDataLocation']
        if isinstance(groups_data, list):
            groups_readable, groups_outputs = [], []
            for group_data in groups_data:
                group_readable = {camel_case_to_readable(i): j for i, j in group_data.items() if i not in fields_to_drop}
                if '@removed' in group_data:
                    group_readable['Status'] = 'deleted'
                groups_readable.append(group_readable)
                groups_outputs.append({k.replace(' ', ''): v for k, v in group_readable.copy().items()})

            return groups_readable, groups_outputs

        group_readable = {camel_case_to_readable(i): j for i, j in groups_data.items() if i not in fields_to_drop}
        if '@removed' in groups_data:
            group_readable['Status'] = 'deleted'
        group_outputs = {k.replace(' ', ''): v for k, v in group_readable.copy().items()}

        return group_readable, group_outputs


    def epoch_seconds() -> int:
        """
        Return the number of seconds for return current date.
        """
        return int((datetime.utcnow() - datetime.utcfromtimestamp(0)).total_seconds())


    def get_encrypted(content: str, key: str) -> str:
        """

        Args:
            content (str): content to encrypt. For a request to Demistobot for a new access token, content should be
                the tenant id
            key (str): encryption key from Demistobot

        Returns:
            encrypted timestamp:content
        """

        def create_nonce() -> bytes:
            return os.urandom(12)

        def encrypt(string: str, enc_key: str) -> bytes:
            """

            Args:
                enc_key (str):
                string (str):

            Returns:
                bytes:
            """
            # String to bytes
            enc_key = base64.b64decode(enc_key)
            # Create key
            aes_gcm = AESGCM(enc_key)
            # Create nonce
            nonce = create_nonce()
            # Create ciphered data
            data = string.encode()
            ct_ = aes_gcm.encrypt(nonce, data, None)
            return base64.b64encode(nonce + ct_)

        now = epoch_seconds()
        encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
        return encrypted


    class Client(BaseClient):
        """
        Client to use in the MS Graph Groups integration. Overrides BaseClient
        """
        def __init__(self, base_url: str, tenant: str, auth_and_token_url: str, auth_id: str, token_retrieval_url: str,
                     enc_key: str, verify: bool, proxy: bool):
            super().__init__(base_url, verify, proxy)
            self.tenant = tenant
            self.auth_and_token_url = auth_and_token_url
            self.auth_id = auth_id
            self.token_retrieval_url = token_retrieval_url
            self.enc_key = enc_key

        def get_access_token(self):
            """Get the Microsoft Graph Access token from the instance token or generates a new one if needed.

            Returns:
                The access token.
            """
            integration_context = demisto.getIntegrationContext()
            access_token = integration_context.get('access_token')
            valid_until = integration_context.get('valid_until')
            calling_context = demisto.callingContext.get('context', {})  # type: ignore[attr-defined]
            brand_name = calling_context.get('IntegrationBrand', '')
            instance_name = calling_context.get('IntegrationInstance', '')
            if access_token and valid_until:
                if epoch_seconds() < valid_until:
                    return access_token

            headers = {'Accept': 'application/json'}
            headers['X-Content-Version'] = CONTENT_RELEASE_VERSION
            headers['X-Branch-Name'] = CONTENT_BRANCH_NAME
            headers['X-Content-Name'] = brand_name or instance_name or 'Name not found'
            try:
                dbot_response = requests.post(
                    self.token_retrieval_url,
                    headers=headers,
                    data=json.dumps({
                        'app_name': APP_NAME,
                        'registration_id': self.auth_id,
                        'encrypted_token': get_encrypted(self.tenant, self.enc_key)
                    }),
                    verify=self._verify
                )
            except requests.exceptions.SSLError as err:
                demisto.debug(str(err))
                raise Exception(f'Connection error in the API call to Microsoft Graph.\n'
                                f'Check your not secure parameter.\n\n{err}')
            except requests.ConnectionError as err:
                demisto.debug(str(err))
                raise Exception(f'Connection error in the API call to Microsoft Graph.\n'
                                f'Check your Server URL parameter.\n\n{err}')
            if dbot_response.status_code not in {200, 201}:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info(f'Authentication failure from server: {dbot_response.status_code}'
                                 f' {dbot_response.reason} {dbot_response.text}')
                    err_response = dbot_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                    if server_msg:
                        msg += f' Server message: {server_msg}'
                except Exception as err:
                    demisto.error(f'Failed parsing error response - Exception: {err}')
                raise Exception(msg)
            try:
                gcloud_function_exec_id = dbot_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = dbot_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Demistobot server did not contain the expected content.'
                )
            access_token = parsed_response.get('access_token')
            expires_in = parsed_response.get('expires_in', 3595)
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer

            demisto.setIntegrationContext({
                'access_token': access_token,
                'valid_until': epoch_seconds() + expires_in
            })
            return access_token

        def http_request(self, method: str, url_suffix: str = None, params: Dict = None, body: Optional[str] = None,
                         next_link: str = None):
            """
            Generic request to Microsoft Graph
            """
            token = self.get_access_token()
            if next_link:
                url = next_link
            else:
                url = f'{self._base_url}{url_suffix}'

            try:
                response = requests.request(
                    method,
                    url,
                    headers={
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    params=params,
                    data=body,
                    verify=self._verify,
                )
            except requests.exceptions.SSLError as err:
                demisto.debug(str(err))
                raise Exception(f'Connection error in the API call to Microsoft Graph.\n'
                                f'Check your not secure parameter.\n\n{err}')
            except requests.ConnectionError as err:
                demisto.debug(str(err))
                raise Exception(f'Connection error in the API call to Microsoft Graph.\n'
                                f'Check your Server URL parameter.\n\n{err}')
            try:
                data = response.json() if response.text else {}
                if not response.ok:
                    raise Exception(f'API call to MS Graph failed [{response.status_code}]'
                                    f' - {demisto.get(data, "error.message")}')
                elif response.status_code == 206:  # 206 indicates Partial Content, reason will be in the warning header
                    demisto.debug(str(response.headers))

                return data

            except TypeError as exc:
                demisto.debug(str(exc))
                raise Exception(f'Error in API call to Microsoft Graph, could not parse result [{response.status_code}]')

        def test_function(self):
            """Performs basic GET request to check if the API is reachable and authentication is successful.

            Returns:
                ok if successful.
            """
            self.http_request('GET', 'groups', params={'$orderby': 'displayName'})
            demisto.results('ok')

        def list_groups(self, order_by: str = None, next_link: str = None, top: int = None, filter_: str = None) -> Dict:
            """Returns all groups by sending a GET request.

            Args:
                order_by: the group fields to order by the response.
                next_link: the link for the next page of results, if exists. see Microsoft documentation for more details.
                    docs.microsoft.com/en-us/graph/api/group-list?view=graph-rest-1.0
                top: sets the page size of results.
                filter_: filters results.
            Returns:
                Response from API.
            """
            params = {'$orderby': order_by} if order_by else {}
            if next_link:  # pagination
                groups = self.http_request('GET', next_link=next_link)
            elif filter_:
                groups = self.http_request('GET', f'groups?$filter={filter_}&$top={top}', params=params)
            else:
                groups = self.http_request('GET', f'groups?$top={top}', params=params)

            return groups

        def get_group(self, group_id: str) -> Dict:
            """Returns a single group by sending a GET request.

            Args:
                group_id: the group id.

            Returns:
                Response from API.
            """
            group = self.http_request('GET', f'groups/{group_id}')
            return group

        def create_group(self, properties: Dict[str, Optional[Any]]) -> Dict:
            """Create a single group by sending a POST request.

            Args:
                properties: the group properties.

            Returns:
                Response from API.
            """
            group = self.http_request('POST', 'groups', body=json.dumps(properties))
            return group

        def delete_group(self, group_id: str):
            """Delete a single group by sending a DELETE request.

            Args:
                group_id: the group id to delete.
            """
            #  If successful, this method returns 204 No Content response code.
            #  It does not return anything in the response body.
            self.http_request('DELETE ', f'groups/{group_id}')

        def list_members(self, group_id: str, next_link: str = None, top: int = None, filter_: str = None) -> Dict:
            """List all group members by sending a GET request.

            Args:
                group_id: the group id to list its members.
                next_link: the link for the next page of results, if exists. see Microsoft documentation for more details.
                    docs.microsoft.com/en-us/graph/api/group-list-members?view=graph-rest-1.0
                top: sets the page size of results.
                filter_: filters results.
            Returns:
                Response from API.
            """
            if next_link:  # pagination
                members = self.http_request('GET', next_link)
            elif filter_:
                members = self.http_request('GET', f'groups/{group_id}/members?$filter={filter_}&$top={top}')
            else:
                members = self.http_request('GET', f'groups/{group_id}/members?$top={top}')

            return members

        def add_member(self, group_id: str, properties: Dict[str, str]):
            """Add a single member to a group by sending a POST request.
            Args:
                group_id: the group id to add the member to.
                properties: the member properties.
            """
            #  If successful, this method returns 204 No Content response code.
            #  It does not return anything in the response body.
            self.http_request('POST', f'groups/{group_id}/members/$ref', body=json.dumps(properties))

        def remove_member(self, group_id: str, user_id: str):
            """Remove a single member to a group by sending a DELETE request.
            Args:
                group_id: the group id to add the member to.
                user_id: the user id to remove.
            """
            #  If successful, this method returns 204 No Content response code.
            #  It does not return anything in the response body.
            self.http_request('DELETE', f'groups/{group_id}/members/{user_id}/$ref')


    def test_function_command(client: Client, args: Dict):
        """Performs a basic GET request to check if the API is reachable and authentication is successful.

        Args:
            client: Client object with request
            args: Usually demisto.args()
        """
        client.test_function()


    def list_groups_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Lists all groups and return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        order_by = args.get('order_by')
        next_link = args.get('next_link')
        top = args.get('top')
        filter_ = args.get('filter')
        groups = client.list_groups(order_by, next_link, top, filter_)

        groups_readable, groups_outputs = parse_outputs(groups['value'])

        next_link_response = ''
        if '@odata.nextLink' in groups:
            next_link_response = groups['@odata.nextLink']

        if next_link_response:
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID).NextLink': next_link_response,
                             f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': groups_outputs}
            title = 'Groups (Note that there are more results. Please use the next_link argument to see them.):'
        else:
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': groups_outputs}
            title = 'Groups:'

        human_readable = tableToMarkdown(name=title, t=groups_readable,
                                         headers=['ID', 'Display Name', 'Description', 'Created Date Time', 'Mail'],
                                         removeNull=True)

        return human_readable, entry_context, groups


    def get_group_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Get a group by group id and return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        group = client.get_group(group_id)

        group_readable, group_outputs = parse_outputs(group)
        human_readable = tableToMarkdown(name="Groups:", t=group_readable,
                                         headers=['ID', 'Display Name', 'Description', 'Created Date Time', 'Mail',
                                                  'Security Enabled', 'Visibility'],
                                         removeNull=True)
        entry_context = {f'{INTEGRATION_CONTEXT_NAME}(obj.ID === {group_id})': group_outputs}
        return human_readable, entry_context, group


    def create_group_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Create a group and return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        required_properties = {
            'displayName': str(args.get('display_name')),
            'mailNickname': str(args.get('mail_nickname')),
            'mailEnabled': args.get('mail_enabled') == 'true',
            'securityEnabled': args.get('security_enabled')
        }

        # create the group
        group = client.create_group(required_properties)

        # display the new group and it's properties
        group_readable, group_outputs = parse_outputs(group)
        human_readable = tableToMarkdown(name=f"{required_properties['displayName']} was created successfully:",
                                         t=group_readable,
                                         headers=['ID', 'Display Name', 'Description', 'Created Date Time', 'Mail',
                                                  'Security Enabled', 'Mail Enabled'],
                                         removeNull=True)
        entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_outputs}
        return human_readable, entry_context, group


    def delete_group_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Delete a group by group id and return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        client.delete_group(group_id)

        # get the group data from the context
        group_data = demisto.dt(demisto.context(), f'{INTEGRATION_CONTEXT_NAME}(val.ID === "{group_id}")')
        if isinstance(group_data, list):
            group_data = group_data[0]

        # add a field that indicates that the group was deleted
        group_data['Deleted'] = True  # add a field with the members to the group
        entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_data}

        human_readable = f'Group: "{group_id}" was deleted successfully.'
        return human_readable, entry_context, NO_OUTPUTS


    def list_members_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """List a group members by group id. return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        next_link = args.get('next_link')
        top = args.get('top')
        filter_ = args.get('filter')
        members = client.list_members(group_id, next_link, top, filter_)

        if not members['value']:
            human_readable = f'The group {group_id} has no members.'
            return human_readable, NO_OUTPUTS, NO_OUTPUTS

        members_readable, members_outputs = parse_outputs(members['value'])

        # get the group data from the context
        group_data = demisto.dt(demisto.context(), f'{INTEGRATION_CONTEXT_NAME}(val.ID === "{group_id}")')
        if isinstance(group_data, list):
            group_data = group_data[0]

        if '@odata.nextLink' in members:
            next_link_response = members['@odata.nextLink']
            group_data['Members'] = members_outputs  # add a field with the members to the group
            group_data['Members']['NextLink'] = next_link_response
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_data}
            title = f'Group {group_id} members ' \
                    f'(Note that there are more results. Please use the next_link argument to see them.):'
        else:
            group_data['Members'] = members_outputs  # add a field with the members to the group
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_data}
            title = f'Group {group_id} members:'

        human_readable = tableToMarkdown(name=title, t=members_readable,
                                         headers=['ID', 'Display Name', 'Job Title', 'Mail'],
                                         removeNull=True)

        return human_readable, entry_context, members


    def add_member_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Add a member to a group by group id and user id. return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        user_id = str(args.get('user_id'))
        required_properties = {
            "@odata.id": f'https://graph.microsoft.com/v1.0/users/{user_id}'}
        client.add_member(group_id, required_properties)

        human_readable = f'User {user_id} was added to the Group {group_id} successfully.'
        return human_readable, NO_OUTPUTS, NO_OUTPUTS


    def remove_member_command(client: Client, args: Dict) -> Tuple[str, Dict, Dict]:
        """Remove a member from a group by group id and user id. return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        user_id = str(args.get('user_id'))
        client.remove_member(group_id, user_id)

        human_readable = f'User {user_id} was removed from the Group "{group_id}" successfully.'
        return human_readable, NO_OUTPUTS, NO_OUTPUTS


    def main():
        """
        PARSE AND VALIDATE INTEGRATION PARAMS
        """
        base_url = demisto.params().get('url').rstrip('/') + '/v1.0/'
        tenant = demisto.params().get('tenant_id')
        auth_and_token_url = demisto.params().get('auth_id').split('@')
        auth_id = auth_and_token_url[0]
        enc_key = demisto.params().get('enc_key')
        verify = not demisto.params().get('insecure', False)
        proxy = demisto.params().get('proxy') == 'true'
        if len(auth_and_token_url) != 2:
            token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
        else:
            token_retrieval_url = auth_and_token_url[1]

        commands = {
            'test-module': test_function_command,
            'msgraph-groups-list-groups': list_groups_command,
            'msgraph-groups-get-group': get_group_command,
            'msgraph-groups-create-group': create_group_command,
            'msgraph-groups-delete-group': delete_group_command,
            'msgraph-groups-list-members': list_members_command,
            'msgraph-groups-add-member': add_member_command,
            'msgraph-groups-remove-member': remove_member_command
        }
        command = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            client = Client(base_url, tenant, auth_and_token_url, auth_id, token_retrieval_url, enc_key, verify, proxy)
            # Run the command
            human_readable, entry_context, raw_response = commands[command](client, demisto.args())
            # create a war room entry
            return_outputs(readable_output=human_readable, outputs=entry_context, raw_response=raw_response)

        except Exception as err:
            return_error(str(err))


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
