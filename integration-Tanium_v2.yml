category: Endpoint
commonfields:
  id: Tanium v2
  version: -1
configuration:
- defaultvalue: ""
  display: Hostname, IP address, or server URL.
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: Domain
  name: domain
  required: false
  type: 0
- defaultvalue: ""
  display: Credentials
  name: credentials
  required: true
  type: 9
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
description: Tanium endpoint security and systems management
detaileddescription: "Integration with Tanium REST API. Available from Tanium version
  7.3.0. You can manage questions, actions, saved questions, packages and sensor information.\n\n##
  Configuration Parameters\n\n**Hostname**  \nThe network address of the Tanium server
  host.\n\n**Domain**  \nThe Tanium user domain. Relevant when there is more than
  one domain inside Tanium.\n\n**Credentials**  \nThe credentials should be the same
  as the Tanium client.\n\n"
display: Tanium v2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAiCAYAAACUcR1DAAAEMElEQVR4Ae3aQ5QkaReA4b/Ltusf27Zt27aNzdi2bds227Ztu++8i7u4556KmMyOPFP6Fk/jU0bFW878n4h0YIEbaDVBCByEwEEIHAIHIfDoNdZcAyfgHjyNW3Aw6t3aVhakG7YWN2EQxFmEP3E2cnRPKwvSiXsMJkBS0BWbhhvc+lKNeyEkTbOxW7jJrSuVuPtDltMUrBRudOv5t7ilGAlJ4B1/bkXDyhWoT0OxP8PN19k5t64w7jy3tsisqdKxXDNWiyx0Qa0Zz4s4L8uty9HxGtQbtXEdmK/yby+yEwUmTB7OgyS0bMwaa27iLvg9zEnDtW7/mW5+Ng6LuDmn+vMwAE0trD3brPlWxzY3Y+NQjUIMMeO7xoQZZdZtgGwMctczE7tFnLEGJrv107FG0sA74ldIBjzsLvonSBpuM3vLMRbiDEBBCzfoLAi875Dl1l4IUX/o2FYQNRs1GngiRO0ZEadaY4jaWAOPgzi/I6uFM16AOEuxVtLA12AGxJmAd9N0o7voi/CUehLvQdRCvKzjT6kDzN7rIWoCpkLUebrOf7SLWgYxbnFrL4Co33RsS4iaYQLbSHvEBJ4CURtp4DEQeIe7/ZtiCcRZlInAj2MZxPnQrU2Mi10HoqahKGJdM2ZC1DG4GKKGoyQm8J94H2Ic0YqB5+ELiOqKbLP/E/cZZ1wmAz8J+Y8CbwFR01Efse5eiBqKHFRhBkRdGhP4V1RjuIu2RisFXoJ93FlH6N4dIWqu/n9sJgPfiLkQpweOc3Zze/d083smDcxYkwm5DEebuSsgaiJqIgJ3M483H6L+1PFzljPw7jHfZE2OCqxWde9YfZCLzyHqLuRjWiYDH4BekBT86vZ2dfMvZyDwIxC1GI/iLvUUltobEhG4qxk/DWLcipPTCDw+hcAVusd/kzXGRc/FEIh6AwvMY1ajItOBy3EjJAVfu70/ufndkwTWr9ELISmah9XjAuvc8+4bsK4pBK5FDkZB1KtoRqVRi0vdN3brIccF3lQf5ygIvBt0vi6jgTVUM2YmDPwbshIGftN9E/Z9hBkQ9UwKgQtdVBUbuF7HP4N/p5pmzHLzU1CCwojAXfALxBiNsowHdrEuShB4CbbW8Sj+Z81FaDBzO0CMU2POuRBirIZTIapfC3vWxkyI00Pnt3ZfGhp1fDuNKim6VPeVmlCCzc217A8xzjZz9e6z2BqoxQ5YN+mTDU+mGfgPCM5L8bvo1fGeehkVZu5cvK9zzyAv5pxSvKhrP8Dx2N6cfU/Evv3xnnOHzq1hxl5x17YBHsYP+BPeL3gBe5s9BXjGnLmq/0lBx59Cnhkvx8s69zbqUYYDsWvSwF1wZ1xgszYLn+MsHQva0RP+2+EzLIIYv7nApeHmtu+X7KyNk3ErHsCpOhe078BBCByEwEEIHITAQQgctOvAQQgc/AOlTKJJMlW1twAAAABJRU5ErkJggg==
name: Tanium v2
script:
  commands:
  - arguments:
    - description: The name of the package.
      name: name
    - description: The package ID. Package ID or package name is required. When both
        exist, ID is used.
      name: id
    description: Returns a package object based on name or ID.
    name: tn-get-package
    outputs:
    - contextPath: TaniumPackage.Command
      description: The command to run.
      type: String
    - contextPath: TaniumPackage.CommandTimeout
      description: Timeout in seconds for the command execution.
      type: Number
    - contextPath: TaniumPackage.ContentSet.Id
      description: The ID of the content set to associate with the package.
      type: Number
    - contextPath: TaniumPackage.ContentSet.Name
      description: The name of the content set to associate with the package.
      type: String
    - contextPath: TaniumPackage.CreationTime
      description: The time and date when this object was created in the database.
      type: String
    - contextPath: TaniumPackage.DisplayName
      description: The name of the package that displays in the user interface.
      type: String
    - contextPath: TaniumPackage.ExpireSeconds
      description: Timeout in seconds for the action.
      type: Number
    - contextPath: TaniumPackage.Files.Hash
      description: The SHA-256 hash of the contents of the file.
      type: String
    - contextPath: TaniumPackage.Files.Id
      description: The unique ID of the package_file object.
      type: Number
    - contextPath: TaniumPackage.Files.Name
      description: The unique name of the package_file object.
      type: String
    - contextPath: TaniumPackage.ID
      description: The unique ID of the package_spec object.
      type: Number
    - contextPath: TaniumPackage.LastModifiedBy
      description: The user who most recently modified this object.
      type: String
    - contextPath: TaniumPackage.LastUpdate
      description: The most recent time and date when this object was modified.
      type: String
    - contextPath: TaniumPackage.ModUser.Domain
      description: The domain of the user who most recently modified this object
      type: String
    - contextPath: TaniumPackage.ModUser.Id
      description: The ID of the user who most recently modified this object
      type: Number
    - contextPath: TaniumPackage.ModUser.Name
      description: The name of the user who most recently modified this object
      type: String
    - contextPath: TaniumPackage.ModificationTime
      description: The most recent time and date when this object was modified.
      type: String
    - contextPath: TaniumPackage.Name
      description: The unique name of the package_spec object.
      type: String
    - contextPath: TaniumPackage.Parameters.Values
      description: The parameter values.
      type: String
    - contextPath: TaniumPackage.Parameters.Label
      description: Parameter description.
      type: String
    - contextPath: TaniumPackage.Parameters.Key
      description: The attribute name of the parameter.
      type: String
    - contextPath: TaniumPackage.Parameters.ParameterType
      description: The type of parameter.
      type: String
    - contextPath: TaniumPackage.SourceId
      description: The ID of the package into which the parameters are substituted.
      type: Number
    - contextPath: TaniumPackage.VerifyExpireSeconds
      description: A verification failure timeout. The time begins with the start
        of the action. If the action cannot be verified by the timeout, the action
        status is reported as failed.
      type: Number
  - arguments:
    - description: The question text.
      name: question-text
      required: true
    - description: The question parameters. For example, sensor1{key1=val1,key2=val2},sensor2{key1=val1}.
      name: parameters
    description: Asks the server to parse the question text and choose the first parsed
      result as the question to run.
    name: tn-ask-question
    outputs:
    - contextPath: Tanium.Question.ID
      description: The unique ID of the question object.
      type: Number
  - arguments:
    - description: The question ID.
      name: question-id
      required: true
    description: Returns the question result based on question ID.
    name: tn-get-question-result
    outputs:
    - contextPath: Tanium.QuestionResult.QuestionID
      description: The unique ID of the question object.
      type: Number
    - contextPath: Tanium.QuestionResult.Results
      description: The question results.
      type: Unknown
    - contextPath: Tanium.QuestionResult.Status
      description: 'The status of the question request. Can be: "Completed" or "Pending".'
      type: String
  - arguments:
    - defaultValue: "5"
      description: The maximum number of sensors to return.
      name: limit
    description: Returns a list of all sensors.
    name: tn-list-sensors
    outputs:
    - contextPath: TaniumSensor.Category
      description: The category that includes this sensor.
      type: String
    - contextPath: TaniumSensor.ContentSetId
      description: The ID of the content set to associate with the sensor.
      type: Number
    - contextPath: TaniumSensor.ContentSetName
      description: The name of the content set to associate with the sensor.
      type: String
    - contextPath: TaniumSensor.CreationTime
      description: The time and date when this object was created in the database.
      type: String
    - contextPath: TaniumSensor.Description
      description: A description for the sensor.
      type: String
    - contextPath: TaniumSensor.Hash
      description: The hash ID of the sensor.
      type: String
    - contextPath: TaniumSensor.ID
      description: The unique ID of the sensor object.
      type: Number
    - contextPath: TaniumSensor.IgnoreCaseFlag
      description: Whether to ignore the case flag of the sensor. Default is 1, which
        means the case flag is ignored.
      type: Boolean
    - contextPath: TaniumSensor.KeepDuplicatesFlag
      description: Whether to keep duplicate values in the sensor results. Default
        is 1 which keeps duplicate values instead of returning each unique value once.
      type: Boolean
    - contextPath: TaniumSensor.LastModifiedBy
      description: The name of the user who last modified this object.
      type: String
    - contextPath: TaniumSensor.MaxAgeSeconds
      description: The maximum age in seconds a sensor result is invalid. When results
        are half this value, the sensor is re-evaluated.
      type: Number
    - contextPath: TaniumSensor.ModUserDomain
      description: The domain of the user who most recently modified this object.
      type: String
    - contextPath: TaniumSensor.ModUserId
      description: The ID of the user who most recently modified this object.
      type: Number
    - contextPath: TaniumSensor.ModUserName
      description: The name of user who most recently modified this object.
      type: String
    - contextPath: TaniumSensor.ModificationTime
      description: The most recent time and date when this object was modified.
      type: String
    - contextPath: TaniumSensor.Name
      description: The name of the sensor.
      type: String
    - contextPath: TaniumSensor.SourceId
      description: The ID of the sensor into which the parameters are substituted.
        If specified, source_hash may be omitted.
      type: Number
  - arguments:
    - description: The sensor ID.
      name: id
    - description: The name of the sensor.
      name: name
    description: Returns detailed information about a sensor object based on name
      or ID.
    name: tn-get-sensor
    outputs:
    - contextPath: TaniumSensor.Category
      description: The category that includes this sensor.
      type: String
    - contextPath: TaniumSensor.ContentSetId
      description: The ID of the content_set to associate with the sensor.
      type: Number
    - contextPath: TaniumSensor.ContentSetName
      description: The name of the content_set to associate with the sensor.
      type: String
    - contextPath: TaniumSensor.CreationTime
      description: The date and time when this object was created in the database.
      type: String
    - contextPath: TaniumSensor.Description
      description: A description for the sensor.
      type: String
    - contextPath: TaniumSensor.Hash
      description: The hash id of the sensor
      type: String
    - contextPath: TaniumSensor.ID
      description: The unique ID of the sensor object.
      type: Number
    - contextPath: TaniumSensor.IgnoreCaseFlag
      description: Ignore the case flag. Default is 1, which means the case flag is
        ignored.
      type: Boolean
    - contextPath: TaniumSensor.KeepDuplicatesFlag
      description: Keep duplicates flag in the sensor results. Default is 1, which
        preserves duplicate values in sensor results instead of only returning each
        unique value once.
      type: Boolean
    - contextPath: TaniumSensor.LastModifiedBy
      description: The name of the user who last modified this object.
      type: String
    - contextPath: TaniumSensor.MaxAgeSeconds
      description: The maximum age in seconds of a sensor result before it is invalid.
        When results are half this value, the sensor is re-evaluated.
      type: Number
    - contextPath: TaniumSensor.ModUserDomain
      description: The domain of the user who most recently modified this object.
      type: String
    - contextPath: TaniumSensor.ModUserId
      description: The ID of the user who most recently modified this object.
      type: Number
    - contextPath: TaniumSensor.ModUserName
      description: The name of the user who most recently modified this object.
      type: String
    - contextPath: TaniumSensor.ModificationTime
      description: The most recent time and date when this object was modified.
      type: String
    - contextPath: TaniumSensor.Name
      description: The name of the sensor.
      type: String
    - contextPath: TaniumSensor.Parameters.Key
      description: The attribute name of the parameter.
      type: String
    - contextPath: TaniumSensor.Parameters.Label
      description: The description of the parameter.
      type: String
    - contextPath: TaniumSensor.Parameters.Values
      description: The values of the parameter.
      type: String
    - contextPath: TaniumSensor.Parameters.ParameterType
      description: The type of parameter.
      type: String
    - contextPath: TaniumSensor.SourceId
      description: The ID of the sensor into which the parameters are substituted.
        If specified, source_hash may be omitted.
      type: Number
  - arguments:
    - description: The question ID.
      name: question-id
      required: true
    - description: Name of the saved question to create.
      name: name
      required: true
    description: Creates a saved question object.
    name: tn-create-saved-question
    outputs:
    - contextPath: Tanium.SavedQuestion.ID
      description: The ID of the saved question.
      type: Number
    - contextPath: Tanium.SavedQuestion.Name
      description: The name of the saved question.
      type: String
  - arguments:
    - defaultValue: "5"
      description: The maximum number of saved questions to return.
      name: limit
    description: Returns all saved questions.
    name: tn-list-saved-questions
    outputs:
    - contextPath: Tanium.SavedQuestion.ArchiveEnabledFlag
      description: Whether archiving is enabled for the saved question.
      type: Boolean
    - contextPath: Tanium.SavedQuestion.ArchiveOwner
      description: The name of the user that owns the archive. Archives can be shared
        between users with identical management rights groups.
      type: String
    - contextPath: Tanium.SavedQuestion.ExpireSeconds
      description: The duration in seconds before each question expires. Default value
        is 600.
      type: Number
    - contextPath: Tanium.SavedQuestion.ID
      description: The unique ID of the question object.
      type: Number
    - contextPath: Tanium.SavedQuestion.IssueSeconds
      description: The time in seconds to reissue the question when active. Default
        value is 120.
      type: Number
    - contextPath: Tanium.SavedQuestion.IssueSecondsNeverFlag
      description: Whether the question is not reissued automatically. Default is
        1 (not reissued).
      type: Boolean
    - contextPath: Tanium.SavedQuestion.KeepSeconds
      description: The number of seconds to save the data results in the archive.
      type: Number
    - contextPath: Tanium.SavedQuestion.ModTime
      description: The most recent time and date when this object was modified.
      type: String
    - contextPath: Tanium.SavedQuestion.ModUserDomain
      description: The domain of the user who most recently modified this object.
      type: String
    - contextPath: Tanium.SavedQuestion.ModUserId
      description: The ID of the user who most recently modified this object.
      type: Number
    - contextPath: Tanium.SavedQuestion.ModUserName
      description: The name of user who most recently modified this object.
      type: String
    - contextPath: Tanium.SavedQuestion.MostRecentQuestionId
      description: The ID of the most recently issued question object generated by
        the saved question.
      type: Number
    - contextPath: Tanium.SavedQuestion.Name
      description: The name of the saved question object.
      type: String
    - contextPath: Tanium.SavedQuestion.QueryText
      description: The textual representation of the question.
      type: String
    - contextPath: Tanium.SavedQuestion.QuestionId
      description: The ID of the question from which to create the saved question.
      type: Number
    - contextPath: Tanium.SavedQuestion.RowCountFlag
      description: If the value is true, only the row count data is saved when archiving
        this question.
      type: Boolean
    - contextPath: Tanium.SavedQuestion.SortColumn
      description: The default sort column, if no sort order is specified.
      type: Number
    - contextPath: Tanium.SavedQuestion.UserId
      description: The ID of the user who owns this object.
      type: Number
    - contextPath: Tanium.SavedQuestion.UserName
      description: The name of the user who owns this object.
      type: String
  - arguments:
    - description: The saved question ID.
      name: question-id
      required: true
    description: Returns the saved question result based on the saved question ID.
    name: tn-get-saved-question-result
    outputs:
    - contextPath: Tanium.SavedQuestionResult.SavedQuestionID
      description: The ID of the saved question.
      type: Number
    - contextPath: Tanium.SavedQuestionResult.Results
      description: The saved question results.
      type: Unknown
    - contextPath: Tanium.SavedQuestionResult.Status
      description: 'Status of the question request. Can be: "Completed" or "Pending".'
      type: String
  - arguments: []
    description: Returns all client details.
    name: tn-get-system-status
    outputs:
    - contextPath: Tanium.Client.ComputerId
      description: The computer ID of the client.
      type: Number
    - contextPath: Tanium.Client.FullVersion
      description: The Tanium Client version.
      type: String
    - contextPath: Tanium.Client.HostName
      description: The computer hostname.
      type: String
    - contextPath: Tanium.Client.IpAddressClient
      description: The IP address of the client returned from a sensor on the client.
      type: String
    - contextPath: Tanium.Client.IpAddressServer
      description: The IP address of the client that was recorded on the server during
        the last registration.
      type: String
    - contextPath: Tanium.Client.LastRegistration
      description: The most recent time that the client registered with the server.
      type: Date
    - contextPath: Tanium.Client.Status
      description: 'The status of the client. Can be: "Blocked", "Leader" "Normal",
        "Slow link".'
      type: String
  - arguments:
    - description: The command to execute.
      name: command
      required: true
    - description: The name of the package to create.
      name: name
      required: true
    description: Creates a package object.
    name: tn-create-package
    outputs:
    - contextPath: TaniumPackage.Command
      description: The command to run.
      type: String
    - contextPath: TaniumPackage.CommandTimeout
      description: Timeout in seconds for the command execution.
      type: Number
    - contextPath: TaniumPackage.ContentSet.Id
      description: The ID of the content set to associate with the package.
      type: Number
    - contextPath: TaniumPackage.ContentSet.Name
      description: The name of the content set to associate with the package.
      type: String
    - contextPath: TaniumPackage.CreationTime
      description: The time and date when this object was created in the database.
      type: String
    - contextPath: TaniumPackage.DisplayName
      description: The name of the package that displays in the user interface.
      type: String
    - contextPath: TaniumPackage.ExpireSeconds
      description: Timeout in seconds for the action expiry.
      type: Number
    - contextPath: TaniumPackage.ID
      description: The unique ID of the package_spec object.
      type: Number
    - contextPath: TaniumPackage.LastModifiedBy
      description: The user who most recently modified this object.
      type: String
    - contextPath: TaniumPackage.LastUpdate
      description: The most recent time and date when this object was modified.
      type: String
    - contextPath: TaniumPackage.ModUser.Domain
      description: The domain of the user who most recently modified this object.
      type: String
    - contextPath: TaniumPackage.ModUser.Id
      description: The ID of the user who most recently modified this object
      type: Number
    - contextPath: TaniumPackage.ModUser.Name
      description: The name of the user who most recently modified this object
      type: String
    - contextPath: TaniumPackage.ModificationTime
      description: The most recent time and date when this object was modified.
      type: String
    - contextPath: TaniumPackage.Name
      description: The unique name of the package_spec object.
      type: String
    - contextPath: TaniumPackage.SourceId
      description: The ID of the package into which the parameters are substituted.
      type: Number
    - contextPath: TaniumPackage.VerifyExpireSeconds
      description: A verification failure timeout. The time begins with the start
        of the action. If the action cannot be verified by the timeout, the action
        status is reported as failed.
      type: Number
  - arguments:
    - defaultValue: "5"
      description: The maximum number of packages to return.
      name: limit
    description: Returns all package information.
    name: tn-list-packages
    outputs:
    - contextPath: TaniumPackage.Command
      description: The command to run.
      type: String
    - contextPath: TaniumPackage.CommandTimeout
      description: Timeout in seconds for the command execution.
      type: Number
    - contextPath: TaniumPackage.ContentSet.Id
      description: The ID of the content set to associate with the package.
      type: Number
    - contextPath: TaniumPackage.ContentSet.Name
      description: The name of the content set to associate with the package.
      type: String
    - contextPath: TaniumPackage.CreationTime
      description: The time and date when this object was created in the database.
      type: String
    - contextPath: TaniumPackage.DisplayName
      description: The name of the package that displays in the user interface.
      type: String
    - contextPath: TaniumPackage.ExpireSeconds
      description: Timeout in seconds for the action expiry.
      type: Number
    - contextPath: TaniumPackage.ID
      description: The unique ID of the package_spec object.
      type: Number
    - contextPath: TaniumPackage.LastModifiedBy
      description: The user who most recently modified this object.
      type: String
    - contextPath: TaniumPackage.LastUpdate
      description: The most recent time and date when this object was modified.
      type: String
    - contextPath: TaniumPackage.ModUser.Domain
      description: The domain of the user who most recently modified this object.
      type: String
    - contextPath: TaniumPackage.ModUser.Id
      description: The ID of the user who most recently modified this object.
      type: Number
    - contextPath: TaniumPackage.ModUser.Name
      description: The name of the user who most recently modified this object.
      type: String
    - contextPath: TaniumPackage.ModificationTime
      description: The most recent time and date when this object was modified.
      type: String
    - contextPath: TaniumPackage.Name
      description: The unique name of the package_spec object.
      type: String
    - contextPath: TaniumPackage.SourceId
      description: The ID of the package into which the parameters are substituted.
      type: Number
    - contextPath: TaniumPackage.VerifyExpireSeconds
      description: A verification failure timeout. The time begins with the start
        of the action. If the action cannot be verified by the timeout, the action
        status is reported as failed.
      type: Number
  - arguments:
    - description: The question ID.
      name: question-id
      required: true
    description: Returns a question object based on question ID.
    name: tn-get-question-metadata
    outputs:
    - contextPath: Tanium.Question.ID
      description: The unique ID of the question object.
      type: Number
    - contextPath: Tanium.Question.Expiration
      description: The date the question expires.
      type: Date
    - contextPath: Tanium.Question.ExpireSeconds
      description: The number of seconds before the question expires. Default is 600.
      type: Number
    - contextPath: Tanium.Question.ForceComputerIdFlag
      description: Whether to force the question to be a counting question if only
        one selection is present. Default is not to force. If the question object
        is an instance of a saved question, this field is derived from the saved question
      type: Boolean
    - contextPath: Tanium.Question.IsExpired
      description: Whether the question has expired.
      type: Boolean
    - contextPath: Tanium.Question.QueryText
      description: The textual representation of the question.
      type: String
    - contextPath: Tanium.Question.SavedQuestionId
      description: The ID of the saved question derived from this question.
      type: Number
    - contextPath: Tanium.Question.UserId
      description: The ID of the user who created / issued this question.
      type: Number
    - contextPath: Tanium.Question.UserName
      description: The name of the user who created / issued this question.
      type: String
  - arguments:
    - defaultValue: "5"
      description: The maximin number of saved actions to return.
      name: limit
    description: Returns all saved actions.
    name: tn-list-saved-actions
    outputs:
    - contextPath: Tanium.SavedAction.ActionGroupId
      description: The ID of the group of clients to target.
      type: Number
    - contextPath: Tanium.SavedAction.ApprovedFlag
      description: Whether the saved action is approved. True is approved.
      type: Boolean
    - contextPath: Tanium.SavedAction.ApproverId
      description: The ID of the user to approve the saved action.
      type: Number
    - contextPath: Tanium.SavedAction.ApproverName
      description: The name of the user to approve the saved action.
      type: String
    - contextPath: Tanium.SavedAction.CreationTime
      description: The time and date when this object was created in the database.
      type: Date
    - contextPath: Tanium.SavedAction.EndTime
      description: The time and date to stop issuing actions.
      type: Date
    - contextPath: Tanium.SavedAction.ExpireSeconds
      description: The duration from the start time before the action expires.
      type: Number
    - contextPath: Tanium.SavedAction.ID
      description: The unique ID of the saved action object.
      type: Number
    - contextPath: Tanium.SavedAction.LastActionId
      description: The ID of the action object that was issued last.
      type: Number
    - contextPath: Tanium.SavedAction.LastActionStartTime
      description: The start time and date of the action object that was issued last.
      type: Date
    - contextPath: Tanium.SavedAction.LastAaction.TargetGroupId
      description: The target group of the action object that was issued last.
      type: Number
    - contextPath: Tanium.SavedAction.LastStartTime
      description: The most recent date and time that the action started.
      type: Date
    - contextPath: Tanium.SavedAction.Name
      description: The name of the saved_action object.
      type: String
    - contextPath: Tanium.SavedAction.NextStartTime
      description: The next time and date when the action will start.
      type: Date
    - contextPath: Tanium.SavedAction.PackageId
      description: The ID of the package deployed by the saved action.
      type: Number
    - contextPath: Tanium.SavedAction.PackageName
      description: The name of the package deployed by the saved action.
      type: String
    - contextPath: Tanium.SavedAction.PackageSourceHash
      description: The source hash of the package deployed by the saved action.
      type: String
    - contextPath: Tanium.SavedAction.StartTime
      description: The time and date when the action became active. An empty string
        or null starts immediately.
      type: Date
    - contextPath: Tanium.SavedAction.Status
      description: 'The status of the saved action. Can be: "0" for Enabled, "1" for
        Disabled, or "2" for Deleted.'
      type: Number
    - contextPath: Tanium.SavedAction.TargetGroupId
      description: The group of machines to target.
      type: Number
    - contextPath: Tanium.SavedAction.UserId
      description: The ID of the user who created the saved action.
      type: Number
    - contextPath: Tanium.SavedAction.UserName
      description: The ID of the user who created the saved action.
      type: String
  - arguments:
    - description: The saved action ID.
      name: id
    - description: The saved action name.
      name: name
    description: Returns a saved action object based on name or ID.
    name: tn-get-saved-action
    outputs:
    - contextPath: Tanium.SavedAction.ActionGroupId
      description: The ID of the group of clients to target.
      type: Number
    - contextPath: Tanium.SavedAction.ApprovedFlag
      description: Whether the saved action is approved. True is approved.
      type: Boolean
    - contextPath: Tanium.SavedAction.ApproverId
      description: The ID of the user to approve the saved action.
      type: Number
    - contextPath: Tanium.SavedAction.ApproverName
      description: The name of the user to approve the saved action.
      type: String
    - contextPath: Tanium.SavedAction.CreationTime
      description: The time and date when this object was created in the database.
      type: Date
    - contextPath: Tanium.SavedAction.EndTime
      description: The time and date to stop issuing actions.
      type: Date
    - contextPath: Tanium.SavedAction.ExpireSeconds
      description: The duration from the start time before the action expires.
      type: Number
    - contextPath: Tanium.SavedAction.ID
      description: The unique ID of the saved_action object.
      type: Number
    - contextPath: Tanium.SavedAction.LastActionId
      description: The ID of the action object that was issued last.
      type: Number
    - contextPath: Tanium.SavedAction.LastActionStartTime
      description: The start time and date of the action object that was issued last.
      type: Date
    - contextPath: Tanium.SavedAction.LastAaction.TargetGroupId
      description: The target group of the action object that was issued last.
      type: Number
    - contextPath: Tanium.SavedAction.LastStartTime
      description: The most recent date and time that the action started.
      type: Date
    - contextPath: Tanium.SavedAction.Name
      description: The name of the saved action object.
      type: String
    - contextPath: Tanium.SavedAction.NextStartTime
      description: The next time and date when the action will start.
      type: Date
    - contextPath: Tanium.SavedAction.PackageId
      description: The ID of the package deployed by the saved action.
      type: Number
    - contextPath: Tanium.SavedAction.PackageName
      description: The name of the package deployed by the saved action.
      type: String
    - contextPath: Tanium.SavedAction.PackageSourceHash
      description: The source hash of the package deployed by the saved action.
      type: String
    - contextPath: Tanium.SavedAction.StartTime
      description: The time amd date when the action became active. An empty string
        or null starts immediately.
      type: Date
    - contextPath: Tanium.SavedAction.Status
      description: 'The status of the saved action. Can be: "0" for Enabled, "1" for
        Disabled, or "2" for Deleted.'
      type: Number
    - contextPath: Tanium.SavedAction.TargetGroupId
      description: The group of machines to target.
      type: Number
    - contextPath: Tanium.SavedAction.UserId
      description: The ID of the user who created the saved action.
      type: Number
    - contextPath: Tanium.SavedAction.UserName
      description: The ID of the user who created the saved action.
      type: String
  - arguments:
    - description: The saved question ID.
      name: question-id
    - description: The saved question name.
      name: question-name
    description: Returns a saved question object based on name or ID.
    name: tn-get-saved-question-metadata
    outputs:
    - contextPath: Tanium.SavedQuestion.ArchiveEnabledFlag
      description: Whether to enable archiving.
      type: Boolean
    - contextPath: Tanium.SavedQuestion.ArchiveOwner
      description: The name of the user that owns the archive. Archives can be shared
        between users with identical management rights groups.
      type: String
    - contextPath: Tanium.SavedQuestion.ExpireSeconds
      description: The duration in seconds before each question expires. Default value
        is 600.
      type: Number
    - contextPath: Tanium.SavedQuestion.ID
      description: The unique ID of the saved_question object.
      type: Number
    - contextPath: Tanium.SavedQuestion.IssueSeconds
      description: The number of seconds to reissue the question when active. Default
        value is 120.
      type: Number
    - contextPath: Tanium.SavedQuestion.IssueSecondsNeverFlag
      description: Whether the question is reissued automatically. If value is 1,
        the question is not reissued automatically.
      type: Boolean
    - contextPath: Tanium.SavedQuestion.KeepSeconds
      description: The number of seconds to save the data results in the archive.
      type: Number
    - contextPath: Tanium.SavedQuestion.ModTime
      description: The most recent time and date when the object was modified.
      type: String
    - contextPath: Tanium.SavedQuestion.ModUserDomain
      description: The domain of the user who most recently modified this object.
      type: String
    - contextPath: Tanium.SavedQuestion.ModUserId
      description: The ID of the user who most recently modified this object.
      type: Number
    - contextPath: Tanium.SavedQuestion.ModUserName
      description: The name of user who most recently modified this object.
      type: String
    - contextPath: Tanium.SavedQuestion.MostRecentQuestionId
      description: The ID of the most recently issued question object generated by
        this saved_question.
      type: Number
    - contextPath: Tanium.SavedQuestion.Name
      description: The name of the saved_question object.
      type: String
    - contextPath: Tanium.SavedQuestion.QueryText
      description: The textual representation of the question.
      type: String
    - contextPath: Tanium.SavedQuestion.QuestionId
      description: The ID of the question from which to create the saved question.
      type: Number
    - contextPath: Tanium.SavedQuestion.RowCountFlag
      description: Whether the row count data is saved when archiving this question.
      type: Boolean
    - contextPath: Tanium.SavedQuestion.SortColumn
      description: The column to use as the default sort column, if no sort order
        is specified.
      type: Number
    - contextPath: Tanium.SavedQuestion.UserId
      description: The ID of the user who owns this object.
      type: Number
    - contextPath: Tanium.SavedQuestion.UserName
      description: The name of the user who owns this object.
      type: String
  - arguments:
    - description: The action group ID.
      name: action-group-id
      required: true
    - description: The package ID.
      name: package-id
      required: true
    - description: The name of the action.
      name: name
    description: Creates a saved action object.
    name: tn-create-saved-action
    outputs:
    - contextPath: Tanium.SavedAction.ActionGroupId
      description: The ID of the group of clients to target.
      type: Number
    - contextPath: Tanium.SavedAction.ApprovedFlag
      description: Whether the saved action is approved. True is approved.
      type: Boolean
    - contextPath: Tanium.SavedAction.ApproverId
      description: The ID of the user to approve the saved action.
      type: Number
    - contextPath: Tanium.SavedAction.ApproverName
      description: The name of the user to approve the saved action.
      type: String
    - contextPath: Tanium.SavedAction.CreationTime
      description: The date and time when this object was created in the database.
      type: Date
    - contextPath: Tanium.SavedAction.EndTime
      description: The date and time to stop issuing actions.
      type: Date
    - contextPath: Tanium.SavedAction.ExpireSeconds
      description: The duration from the start time before the action expires.
      type: Number
    - contextPath: Tanium.SavedAction.ID
      description: The unique ID of the saved_action object.
      type: Number
    - contextPath: Tanium.SavedAction.LastActionId
      description: The ID of the action object that was issued last.
      type: Number
    - contextPath: Tanium.SavedAction.LastActionStartTime
      description: The start time of the action object that was issued last.
      type: Date
    - contextPath: Tanium.SavedAction.LastAaction.TargetGroupId
      description: The target group of the action object that was issued last.
      type: Number
    - contextPath: Tanium.SavedAction.LastStartTime
      description: The most recent date and time that the action started.
      type: Date
    - contextPath: Tanium.SavedAction.Name
      description: The name of the saved action object.
      type: String
    - contextPath: Tanium.SavedAction.NextStartTime
      description: The next date and time when the action will start.
      type: Date
    - contextPath: Tanium.SavedAction.PackageId
      description: The ID of the package deployed by the saved action.
      type: Number
    - contextPath: Tanium.SavedAction.PackageName
      description: The name of the package deployed by the saved action.
      type: String
    - contextPath: Tanium.SavedAction.PackageSourceHash
      description: The source hash of the package deployed by the saved action.
      type: String
    - contextPath: Tanium.SavedAction.StartTime
      description: The date and time when the action became active. An empty string
        or null starts immediately.
      type: Date
    - contextPath: Tanium.SavedAction.Status
      description: 'The status of the saved action. Can be: "0" for Enabled, "1" for
        Disabled, or "2" for Deleted.'
      type: Number
    - contextPath: Tanium.SavedAction.TargetGroupId
      description: The group of machines to target.
      type: Number
    - contextPath: Tanium.SavedAction.UserId
      description: The ID of the user who created the saved action.
      type: Number
    - contextPath: Tanium.SavedAction.UserName
      description: The ID of the user who created the saved action.
      type: String
  - arguments:
    - description: The package ID.
      name: package-id
    - description: The package name.
      name: package-name
    - description: The package parameters. For example, $1=Value1;$2=Value2;$3=Value3.
      name: parameters
    - description: The target group ID to deploy the package.
      name: target-group-id
    - description: The target group name to deploy the package. Target group and action
        group ID are required. Target group can passed by name or ID. Note - the target
        group should be different than "All Computers" or "Default".
      name: target-group-name
    - description: The action group ID to deploy the package.
      name: action-group-id
      required: true
    - defaultValue: via Demisto API
      description: The action name.
      name: action-name
    description: Creates an action object based on the package name or the package
      ID.
    name: tn-create-action
    outputs:
    - contextPath: Tanium.Action.ActionGroupId
      description: The id of the parent group of machines to target.
      type: Number
    - contextPath: Tanium.Action.ActionGroupName
      description: The name of the parent group of machines to target.
      type: String
    - contextPath: Tanium.Action.ApproverId
      description: The id of the approver of this action.
      type: Number
    - contextPath: Tanium.Action.ApproverName
      description: The name of the approver of this action.
      type: String
    - contextPath: Tanium.Action.CreationTime
      description: The date and time when this object was created in the database.
      type: Date
    - contextPath: Tanium.Action.ExpirationTime
      description: The date and time when the action expires.
      type: Date
    - contextPath: Tanium.Action.ExpireSeconds
      description: The timeout in seconds for the action expiry.
      type: Number
    - contextPath: Tanium.Action.HistorySavedQuestionId
      description: The ID of the saved question that tracks the results of the action.
      type: Number
    - contextPath: Tanium.Action.ID
      description: The unique ID of the action object.
      type: Number
    - contextPath: Tanium.Action.Name
      description: The action name.
      type: String
    - contextPath: Tanium.Action.PackageId
      description: The ID of the package deployed by this action.
      type: Number
    - contextPath: Tanium.Action.PackageName
      description: The name of the package deployed by this action.
      type: String
    - contextPath: Tanium.Action.SavedActionId
      description: The ID of the saved action that this action was issued from, if
        any.
      type: Number
    - contextPath: Tanium.Action.StartTime
      description: The date and time when the action became active.
      type: String
    - contextPath: Tanium.Action.Status
      description: 'The status of the action. Can be: "Pending", "Active", "Stopped",
        or "Expired".'
      type: String
    - contextPath: Tanium.Action.StoppedFlag
      description: Whether an action stop has been issued for this action. A value
        of true indicates an action stop was issued.
      type: Boolean
    - contextPath: Tanium.Action.TargetGroupId
      description: The ID of the group of machines to target.
      type: Number
    - contextPath: Tanium.Action.TargetGroupName
      description: The name of the group of machines to target.
      type: String
    - contextPath: Tanium.Action.UserDomain
      description: The domain of the user who issued this action.
      type: String
    - contextPath: Tanium.Action.UserId
      description: The ID of the user who issued this action.
      type: Number
    - contextPath: Tanium.Action.UserName
      description: The name of the user who issued this action.
      type: String
  - arguments:
    - defaultValue: "5"
      description: The maximum number of actions to return.
      name: limit
    description: Returns all actions.
    name: tn-list-actions
    outputs:
    - contextPath: Tanium.Action.ActionGroupId
      description: The ID of the parent group of machines to target.
      type: Number
    - contextPath: Tanium.Action.ActionGroupName
      description: The name of the parent group of machines to target.
      type: String
    - contextPath: Tanium.Action.ApproverId
      description: The ID of the approver of this action.
      type: Number
    - contextPath: Tanium.Action.ApproverName
      description: The name of the approver of this action.
      type: String
    - contextPath: Tanium.Action.CreationTime
      description: The date and time when this object was created in the database.
      type: Date
    - contextPath: Tanium.Action.ExpirationTime
      description: The date and time when the action expires.
      type: Date
    - contextPath: Tanium.Action.ExpireSeconds
      description: The timeout in seconds for the action expiry.
      type: Number
    - contextPath: Tanium.Action.HistorySavedQuestionId
      description: The ID of the saved question that tracks the results of the action.
      type: Number
    - contextPath: Tanium.Action.ID
      description: The unique ID of the action object.
      type: Number
    - contextPath: Tanium.Action.Name
      description: The action name.
      type: String
    - contextPath: Tanium.Action.PackageId
      description: The ID of the package deployed by this action.
      type: Number
    - contextPath: Tanium.Action.PackageName
      description: The name of the package deployed by this action.
      type: String
    - contextPath: Tanium.Action.SavedActionId
      description: The ID of the saved action that this action was issued from, if
        any.
      type: Number
    - contextPath: Tanium.Action.StartTime
      description: The date and time when the action became active.
      type: String
    - contextPath: Tanium.Action.Status
      description: 'The status of the action. Can be: "Pending", "Active", "Stopped",
        or "Expired".'
      type: String
    - contextPath: Tanium.Action.StoppedFlag
      description: Whether an action stop has been issued for this action. A value
        of true indicates an action stop was issued.
      type: Boolean
    - contextPath: Tanium.Action.TargetGroupId
      description: The ID of the group of machines to target.
      type: Number
    - contextPath: Tanium.Action.TargetGroupName
      description: The name of the group of machines to target.
      type: String
    - contextPath: Tanium.Action.UserDomain
      description: The domain of the user who issued this action.
      type: String
    - contextPath: Tanium.Action.UserId
      description: The ID of the user who issued this action.
      type: Number
    - contextPath: Tanium.Action.UserName
      description: The name of the user who issued this action.
      type: String
  - arguments:
    - description: The action ID.
      name: id
      required: true
    description: Returns an action object based on ID.
    name: tn-get-action
    outputs:
    - contextPath: Tanium.Action.ActionGroupId
      description: The ID of the parent group of machines to target.
      type: Number
    - contextPath: Tanium.Action.ActionGroupName
      description: The name of the parent group of machines to target.
      type: String
    - contextPath: Tanium.Action.ApproverId
      description: The ID of the approver of this action.
      type: Number
    - contextPath: Tanium.Action.ApproverName
      description: The name of the approver of this action.
      type: String
    - contextPath: Tanium.Action.CreationTime
      description: The date and time when this object was created in the database.
      type: Date
    - contextPath: Tanium.Action.ExpirationTime
      description: The date and time when the action expires.
      type: Date
    - contextPath: Tanium.Action.ExpireSeconds
      description: The timeout in seconds for the action expiry.
      type: Number
    - contextPath: Tanium.Action.HistorySavedQuestionId
      description: The ID of the saved question that tracks the results of the action.
      type: Number
    - contextPath: Tanium.Action.ID
      description: The unique ID of the action object.
      type: Number
    - contextPath: Tanium.Action.Name
      description: The action name.
      type: String
    - contextPath: Tanium.Action.PackageId
      description: The ID of the package deployed by this action.
      type: Number
    - contextPath: Tanium.Action.PackageName
      description: The name of the package deployed by this action.
      type: String
    - contextPath: Tanium.Action.SavedActionId
      description: The ID of the saved action that this action was issued from, if
        any.
      type: Number
    - contextPath: Tanium.Action.StartTime
      description: The date and time when the action became active.
      type: String
    - contextPath: Tanium.Action.Status
      description: 'The status of the action. Can be: "Pending", "Active", "Stopped",
        or "Expired".'
      type: String
    - contextPath: Tanium.Action.StoppedFlag
      description: Whether an action stop has been issued for this action. A value
        of true indicates an action stop was issued.
      type: Boolean
    - contextPath: Tanium.Action.TargetGroupId
      description: The ID of the group of machines to target.
      type: Number
    - contextPath: Tanium.Action.TargetGroupName
      description: The name of the group of machines to target.
      type: String
    - contextPath: Tanium.Action.UserDomain
      description: The domain of the user who issued this action.
      type: String
    - contextPath: Tanium.Action.UserId
      description: The ID of the user who issued this action.
      type: Number
    - contextPath: Tanium.Action.UserName
      description: The name of the user who issued this action.
      type: String
  - arguments:
    - defaultValue: "5"
      description: The maximum number of saved actions to return.
      name: limit
    description: Retrieves all saved action approval definitions on the server.
    name: tn-list-saved-actions-pending-approval
    outputs:
    - contextPath: Tanium.PendingSavedAction.ApprovedFlag
      description: Whether the saved action is approved. True is approved.
      type: Boolean
    - contextPath: Tanium.PendingSavedAction.ID
      description: The unique ID of the saved action object.
      type: Number
    - contextPath: Tanium.PendingSavedAction.Name
      description: The name of the saved action object.
      type: String
    - contextPath: Tanium.PendingSavedAction.OwnerUserId
      description: The ID of the user who owns this object.
      type: Number
  - arguments:
    - description: The group ID.
      name: id
    - description: Name of group.
      name: name
    description: Returns a group object based on ID or name.
    name: tn-get-group
    outputs:
    - contextPath: Tanium.Group.ID
      description: The unique ID of the group object.
      type: Unknown
    - contextPath: Tanium.Group.Name
      description: The name of the group.
      type: String
    - contextPath: Tanium.Group.Text
      description: A description of the clients that this group represents.
      type: String
    - contextPath: Tanium.Group.Type
      description: The type of the group.
      type: String
    - contextPath: Tanium.Group.Deleted
      description: Whether the group is deleted. True if deleted.
      type: Boolean
  - arguments:
    - description: The name of the group to create.
      name: group-name
      required: true
    - description: Comma separated list of hosts. For example, Host1,Host2.
      name: computer-names
    - description: Comma separated list of IP addresses. For example, 12.12.12.12,10.1.1.1.
      name: ip-addresses
    description: Creates a group object based on computers or IP addresses list.
    name: tn-create-manual-group
    outputs:
    - contextPath: Tanium.Group.ID
      description: The unique ID of the group object.
      type: Number
  - arguments:
    - description: The text filter-based computer group. For example, operating system
        contains windows.
      name: text-filter
      required: true
    - description: Name of the group to create.
      name: group-name
      required: true
    description: Creates a group object based on text filter.
    name: tn-create-filter-based-group
    outputs:
    - contextPath: Tanium.Group.ID
      description: The unique ID of the group object.
      type: Number
  - arguments:
    - defaultValue: "5"
      description: The maximum number of groups to return.
      name: limit
    description: Returns all groups.
    name: tn-list-groups
    outputs:
    - contextPath: Tanium.Group.ID
      description: The unique ID of the group object.
      type: Number
    - contextPath: Tanium.Group.Name
      description: The name of the group.
      type: String
    - contextPath: Tanium.Group.Text
      description: A description of the clients that this group represents.
      type: String
    - contextPath: Tanium.Group.Type
      description: The type of the group.
      type: String
    - contextPath: Tanium.Group.Deleted
      description: whether the group is deleted. True if deleted.
      type: Boolean
  - arguments:
    - description: The group ID.
      name: id
      required: true
    description: Deletes a group object.
    name: tn-delete-group
  - arguments:
    - description: The package ID.
      name: package-id
    - description: The package name. Target group is required and can passed by name
        or ID. When both exist, the ID is used. Note the target group should be different
        than "All Computers" or "Default".
      name: package-name
    - description: Package parameters. For example, $1=Value1;$2=Value2;$3=Value3.
      name: parameters
    - description: The action group ID to deploy the package.
      name: action-group-id
      required: true
    - description: The hostname to deploy the package. Hostname or IP address is required.
      name: hostname
    - description: The IP address of the host to deploy the package.
      name: ip-address
    - defaultValue: via Demisto API
      description: The action name.
      name: action-name
    description: Creates an action object, based on a package name or package ID.
    name: tn-create-action-by-host
    outputs:
    - contextPath: Tanium.Action.ActionGroupId
      description: The id of the parent group of machines to target.
      type: Number
    - contextPath: Tanium.Action.ActionGroupName
      description: The name of the parent group of machines to target.
      type: String
    - contextPath: Tanium.Action.ApproverId
      description: The id of the approver of this action.
      type: Number
    - contextPath: Tanium.Action.ApproverName
      description: The name of the approver of this action.
      type: String
    - contextPath: Tanium.Action.CreationTime
      description: The date and time when this object was created in the database.
      type: Date
    - contextPath: Tanium.Action.ExpirationTime
      description: The date and time when the action expires.
      type: Date
    - contextPath: Tanium.Action.ExpireSeconds
      description: The timeout in seconds for the action expiry.
      type: Number
    - contextPath: Tanium.Action.HistorySavedQuestionId
      description: The ID of the saved question that tracks the results of the action.
      type: Number
    - contextPath: Tanium.Action.ID
      description: The unique ID of the action object.
      type: Number
    - contextPath: Tanium.Action.Name
      description: The action name.
      type: String
    - contextPath: Tanium.Action.PackageId
      description: The ID of the package deployed by this action.
      type: Number
    - contextPath: Tanium.Action.PackageName
      description: The name of the package deployed by this action.
      type: String
    - contextPath: Tanium.Action.SavedActionId
      description: The ID of the saved action that this action was issued from, if
        any.
      type: Number
    - contextPath: Tanium.Action.StartTime
      description: The date and time when the action became active.
      type: String
    - contextPath: Tanium.Action.Status
      description: 'The status of the action. Can be: "Pending", "Active", "Stopped",
        or "Expired".'
      type: String
    - contextPath: Tanium.Action.StoppedFlag
      description: Whether an action stop has been issued for this action. A value
        of true indicates an action stop was issued.
      type: Boolean
    - contextPath: Tanium.Action.TargetGroupId
      description: The ID of the group of machines to target.
      type: Number
    - contextPath: Tanium.Action.TargetGroupName
      description: The name of the group of machines to target.
      type: String
    - contextPath: Tanium.Action.UserDomain
      description: The domain of the user who issued this action.
      type: String
    - contextPath: Tanium.Action.UserId
      description: The ID of the user who issued this action.
      type: Number
    - contextPath: Tanium.Action.UserName
      description: The name of the user who issued this action.
      type: String
  dockerimage: demisto/python3:3.7.4.977
  runonce: false
  script: |2





    ''' IMPORTS '''
    import json
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

    ''' GLOBALS/PARAMS '''
    GROUP_TYPES = {0: 'Filter-based group', 1: 'Action group', 2: 'Action policy pair group', 3: 'Ad hoc group',
                   4: 'Manual group'}
    DEMISTO_API_ACTION_NAME = 'via Demisto API'


    class Client(BaseClient):
        def __init__(self, base_url, username, password, domain, **kwargs):
            self.username = username
            self.password = password
            self.domain = domain
            self.session = ''
            super(Client, self).__init__(base_url, **kwargs)

        def do_request(self, method, url_suffix, data=None):
            if not self.session:
                self.update_session()

            res = self._http_request(method, url_suffix, headers={'session': self.session}, json_data=data,
                                     resp_type='response', ok_codes=[200, 400, 403, 404])

            if res.status_code == 403:
                self.update_session()
                res = self._http_request(method, url_suffix, headers={'session': self.session}, json_data=data,
                                         ok_codes=[200, 400, 404])
                return res

            if res.status_code == 404 or res.status_code == 400:
                raise requests.HTTPError(res.json().get('text'))

            return res.json()

        def update_session(self):
            body = {
                'username': self.username,
                'domain': self.domain,
                'password': self.password
            }

            res = self._http_request('GET', 'session/login', json_data=body, ok_codes=[200])

            self.session = res.get('data').get('session')
            return self.session

        def login(self):
            return self.update_session()

        def parse_sensor_parameters(self, parameters):
            sensors = parameters.split(';')
            parameter_conditions = []

            for sensor in sensors:
                sensor_name = sensor.split('{')[0]
                tmp_item = {'sensor': sensor_name, 'parameters': []}

                parameters_txt = sensor.split('{')[1][:-1]
                params = parameters_txt.split(',')
                for param in params:
                    tmp_item['parameters'].append({
                        'key': '||' + param.split('=')[0] + '||',
                        'value': param.split('=')[1]
                    })
                parameter_conditions.append(tmp_item)

            return parameter_conditions

        def parse_action_parameters(self, parameters):
            parameters = parameters.split(';')
            parameter_conditions = []
            for param in parameters:
                parameter_conditions.append({
                    'key': param.split('=')[0],
                    'value': param.split('=')[1]})

            return parameter_conditions

        def add_parameters_to_question(self, question_response, parameters):
            if not parameters:
                return question_response

            for item in question_response.get('selects'):
                sensor = item.get('sensor').get('name')

                for parameter in parameters:
                    if parameter['sensor'] == sensor:
                        item['sensor']['parameters'] = parameter['parameters']
                        item['sensor']['source_hash'] = item['sensor']['hash']
                        del item['sensor']['hash']

            return question_response

        def parse_question(self, text, parameters):
            parameters_condition = []  # type: ignore

            if parameters:
                try:
                    parameters_condition = self.parse_sensor_parameters(parameters)
                except Exception:
                    raise ValueError('Failed to parse question parameters.')

            res = self.do_request('POST', 'parse_question', {'text': text}).get('data')[0]

            res = self.add_parameters_to_question(res, parameters_condition)
            return res

        def create_question(self, question_body):
            res = self.do_request('POST', 'questions', question_body)
            return res.get('data').get('id'), res

        def parse_question_results(self, result):
            results_sets = result.get('data').get('result_sets')[0]
            estimated_total = results_sets.get('estimated_total')
            mr_tested = results_sets.get('mr_tested')

            if not estimated_total and not mr_tested:
                return None

            percantage = mr_tested / estimated_total * 100

            if percantage < 95:
                return None
            if results_sets.get('row_count') == 0:
                return []

            rows = []
            columns = []
            for column in results_sets.get('columns'):
                columns.append(column.get('name').replace(' ', ''))

            for row in results_sets.get('rows'):
                tmp_row = {}
                for item, column in zip(row.get('data', []), columns):
                    item_value = item[0].get('text')
                    if item_value != '[no results]':
                        tmp_row[column] = item_value
                rows.append(tmp_row)

            return rows

        def update_id(self, obj):
            if 'id' in obj:
                obj['ID'] = obj['id']
                del obj['id']
                return obj
            return obj

        def build_create_action_body(self, by_host, action_name,
                                     parameters, package_id='', package_name='', action_group_id='', action_group_name='',
                                     target_group_id='', target_group_name='', hostname='', ip_address=''):
            """
            This method used to build create_action request body by host or by target group
            """

            # package and action group are mandatory and can be pass by name or id
            if not package_id and not package_name:
                raise ValueError('package id and package name are missing, Please specify one of them.')
            if not action_group_id and not action_group_name:
                raise ValueError('action group id and action group name are missing, Please specify one of them.')

            if action_name:
                action_name = f'{action_name} {DEMISTO_API_ACTION_NAME}'
            else:
                action_name = DEMISTO_API_ACTION_NAME

            # get package expire_seconds value
            if package_id:
                get_package_res = self.do_request('GET', 'packages/' + str(package_id))
            elif package_name:
                get_package_res = self.do_request('GET', 'packages/by-name/' + package_name)
                package_id = get_package_res.get('data').get('id')

            expire_seconds = get_package_res.get('data').get('expire_seconds', 0)

            target_group = {}  # type: ignore

            if by_host:
                # use Tanium parse question request to set target group by hostname or ip address
                if not ip_address and not hostname:
                    raise ValueError('hostname and ip address are missing, Please specify one of them.')

                if ip_address:
                    group_question = f'Get Computer Name from all machines with ip address equals {ip_address}'
                if hostname:
                    group_question = f'Get Computer Name from all machines with Computer Name equals {hostname}'

                group_res = self.parse_question(group_question, None)
                target_group = group_res.get('group')

                if not target_group:
                    raise ValueError('Failed to parse target group question')
            else:
                # set target group by id or name
                if not target_group_id and not target_group_name:
                    raise ValueError('target group id and target group name are missing, Please specify one of them.')

                if target_group_id:
                    target_group = {'id': target_group_id}
                if target_group_name:
                    target_group = {'name': target_group_name}

            action_group = {}  # type: ignore
            if action_group_id:
                action_group = {'id': action_group_id}
            if action_group_name:
                action_group = {'name': action_group_name}

            parameters_condition = []  # type: ignore
            if parameters:
                # build action parameters object
                try:
                    parameters_condition = self.parse_action_parameters(parameters)
                except Exception:
                    raise ValueError('Failed to parse action parameters.')

            # crete the body of the response
            body = {'package_spec': {'source_id': package_id}}

            if parameters_condition:
                # set the parameters value to request body
                body['package_spec']['parameters'] = []
                for param in parameters_condition:
                    body['package_spec']['parameters'].append(param)

            body['name'] = action_name
            body['target_group'] = target_group
            body['action_group'] = action_group
            body['expire_seconds'] = expire_seconds

            return body

        def get_package_item(self, package):
            item = {
                'ContentSet': {},
                'ModUser': {},
                'Command': package.get('command'),
                'CommandTimeout': package.get('command_timeout'),
                'CreationTime': package.get('creation_time'),
                'DisplayName': package.get('display_name'),
                'ExpireSeconds': package.get('expire_seconds'),
                'ID': package.get('id'),
                'LastModifiedBy': package.get('last_modified_by'),
                'LastUpdate': package.get('last_update'),
                'ModificationTime': package.get('modification_time'),
                'Name': package.get('name'),
                'SourceId': package.get('source_id'),
                'VerifyExpireSeconds': package.get('verify_expire_seconds'),
                'Parameters': self.get_parameter_item(package)
            }

            content_set = package.get('content_set')
            if content_set:
                item['ContentSet']['Id'] = content_set.get('id')
                item['ContentSet']['Name'] = content_set.get('name')

            mod_user = package.get('ModUser')
            if mod_user:
                item['ModUser']['Domain'] = mod_user.get('domain')
                item['ModUser']['Id'] = mod_user.get('id')
                item['ModUser']['Name'] = mod_user.get('name')

            files = package.get('files')
            files_list = []
            if files:
                for file in files:
                    files_list.append({
                        'ID': file.get('id'),
                        'Hash': file.get('hash'),
                        'Name': file.get('name')
                    })

            item['Files'] = files_list
            return item

        def get_question_item(self, question):
            item = {
                'ID': question.get('id'),
                'Expiration': question.get('expiration'),
                'ExpireSeconds': question.get('expire_seconds'),
                'ForceComputerIdFlag': question.get('force_computer_id_flag'),
                'IsExpired': question.get('is_expired'),
                'QueryText': question.get('query_text')
            }

            saved_question_id = question.get('saved_question').get('id')
            if saved_question_id:
                item['SavedQuestionId'] = saved_question_id

            user = question.get('user')
            if user:
                item['UserId'] = user.get('id')
                item['UserName'] = user.get('name')
            return item

        def get_saved_question_item(self, question):
            item = {
                'ArchiveEnabledFlag': question.get('archive_enabled_flag'),
                'ArchiveOwner': question.get('archive_owner'),
                'ExpireSeconds': question.get('expire_seconds'),
                'ID': question.get('id'),
                'IssueSeconds': question.get('issue_seconds'),
                'IssueSecondsNeverFlag': question.get('issue_seconds_never_flag'),
                'KeepSeconds': question.get('keep_seconds'),
                'ModTime': question.get('mod_time'),
                'MostRecentQuestionId': question.get('most_recent_question_id'),
                'Name': question.get('name'),
                'QueryText': question.get('query_text'),
                'QuestionId': question.get('question').get('id'),
                'RowCountFlag': question.get('row_count_flag'),
                'SortColumn': question.get('sort_column'),
            }

            mod_user = question.get('ModUser')
            if mod_user:
                item['ModUserDomain'] = mod_user.get('domain')
                item['ModUserId'] = mod_user.get('id')
                item['ModUserName'] = mod_user.get('name')

            user = question.get('user')
            if user:
                item['UserId'] = user.get('id')
                item['UserName'] = user.get('name')
            return item

        def get_sensor_item(self, sensor):
            item = {
                'Category': sensor.get('category'),
                'CreationTime': sensor.get('creation_time'),
                'Description': sensor.get('description'),
                'Hash': sensor.get('hash'),
                'ID': sensor.get('id'),
                'IgnoreCaseFlag': sensor.get('ignore_case_flag'),
                'KeepDuplicatesFlag': sensor.get('keep_duplicates_flag'),
                'LastModifiedBy': sensor.get('last_modified_by'),
                'MaxAgeSeconds': sensor.get('max_age_seconds'),
                'ModificationTime': sensor.get('modification_time'),
                'Name': sensor.get('name'),
                'SourceId': sensor.get('source_id'),
                'Parameters': self.get_parameter_item(sensor)
            }

            content_set = sensor.get('content_set')
            if content_set:
                item['ContentSetId'] = content_set.get('id')
                item['ContentSetName'] = content_set.get('name')

            mod_user = sensor.get('mod_user')
            if mod_user:
                item['ModUserDomain'] = mod_user.get('domain')
                item['ModUserId'] = mod_user.get('id')
                item['ModUserName'] = mod_user.get('name')

            return item

        def get_parameter_item(self, sensor):
            parameters = sensor.get('parameter_definition')
            params_list = []
            if parameters:
                try:
                    parameters = json.loads(parameters).get('parameters')
                except ValueError:
                    return {'Value': parameters}
                for param in parameters:
                    params_list.append({
                        'Key': param.get('key'),
                        'Label': param.get('label'),
                        'Values': param.get('values'),
                        'ParameterType': param.get('parameterType')
                    })

            return params_list

        def get_action_item(self, action):
            item = {
                'ActionGroupId': action.get('action_group').get('id'),
                'ActionGroupName': action.get('action_group').get('name'),
                'CreationTime': action.get('creation_time'),
                'ExpirationTime': action.get('expiration_time'),
                'ExpireSeconds': action.get('expire_seconds'),
                'HistorySavedQuestionId': action.get('history_saved_question').get('id'),
                'ID': action.get('id'),
                'Name': action.get('name'),
                'PackageId': action.get('package_spec').get('id'),
                'PackageName': action.get('package_spec').get('name'),
                'SavedActionId': action.get('saved_action').get('id'),
                'StartTime': action.get('start_time'),
                'Status': action.get('status'),
                'StoppedFlag': action.get('stopped_flag'),
                'TargetGroupId': action.get('target_group').get('id'),
                'TargetGroupName': action.get('target_group').get('name')
            }

            user = action.get('user')
            if user:
                item['UserDomain'] = user.get('domain')
                item['UserId'] = user.get('id')
                item['UserName'] = user.get('name')

            approver = action.get('approver')
            if approver:
                item['ApproverId'] = approver.get('id')
                item['ApproverName'] = approver.get('name')

            return item

        def get_saved_action_item(self, action):
            item = {
                'ActionGroupId': action.get('action_group_id'),
                'ApprovedFlag': action.get('approved_flag'),
                'ApproverId': action.get('approver').get('id'),
                'ApproverName': action.get('approver').get('name'),
                'CreationTime': action.get('creation_time'),
                'EndTime': action.get('end_time'),
                'ExpireSeconds': action.get('expire_seconds'),
                'ID': action.get('id'),
                'LastActionId': action.get('last_action').get('id'),
                'LastActionStartTime': action.get('last_action').get('start_time'),
                'TargetGroupId': action.get('target_group').get('id'),
                'LastStartTime': action.get('last_start_time'),
                'Name': action.get('name'),
                'NextStartTime': action.get('next_start_time'),
                'StartTime': action.get('start_time'),
                'Status': action.get('status'),
                'UserId': action.get('user').get('id'),
                'UserName': action.get('user').get('name')
            }

            package_spec = action.get('package_spec')
            if package_spec:
                item['PackageId'] = package_spec.get('id')
                item['PackageName'] = package_spec.get('name')
                item['PackageSourceHash'] = package_spec.get('source_hash')

            return item

        def get_saved_action_pending_item(self, action):
            return {
                'ApprovedFlag': action.get('approved_flag'),
                'ID': action.get('id'),
                'Name': action.get('name'),
                'OwnerUserId': action.get('owner_user_id')
            }

        def get_host_item(self, client):
            return {
                'ComputerId': client.get('computer_id'),
                'FullVersion': client.get('full_version'),
                'HostName': client.get('host_name'),
                'IpAddressClient': client.get('ipaddress_client'),
                'IpAddressServer': client.get('ipaddress_server'),
                'LastRegistration': client.get('last_registration'),
                'Status': client.get('status')
            }

        def get_group_item(self, group):
            item = {
                'ID': group.get('id'),
                'Name': group.get('name'),
                'Deleted': group.get('deleted_flag'),
                'Text': group.get('text')
            }
            group_type = group.get('type')

            if group_type:
                item['Type'] = GROUP_TYPES[group_type]
            else:
                item['Type'] = 'Manual group'

            return item


    ''' COMMANDS + REQUESTS FUNCTIONS '''


    def test_module(client, data_args):
        if client.login():
            return demisto.results('ok')
        raise ValueError('Test Tanium integration failed - please check your username and password')


    def get_system_status(client, data_args):
        raw_response = client.do_request('GET', 'system_status')
        response = raw_response.get('data')

        context = []
        for item in response:
            if item.get('computer_id'):
                context.append(client.get_host_item(item))

        context = createContext(context, removeNull=True)
        outputs = {'Tanium.Client(val.ComputerId && val.ComputerId === obj.ComputerId)': context}
        human_readable = tableToMarkdown('System status', context)
        return human_readable, outputs, raw_response


    def get_package(client, data_args):
        id_ = data_args.get('id')
        name = data_args.get('name')
        endpoint_url = ''
        if not id_ and not name:
            raise ValueError('id and name arguments are missing, Please specify one of them.')
        if name:
            endpoint_url = 'packages/by-name/' + name
        if id_:
            endpoint_url = 'packages/' + str(id_)

        raw_response = client.do_request('GET', endpoint_url)
        package = client.get_package_item(raw_response.get('data'))
        params = package.get('Parameters')
        files = package.get('Files')

        context = createContext(package, removeNull=True)
        outputs = {'TaniumPackage(val.ID && val.ID === obj.ID)': context}

        del package['Parameters']
        del package['Files']

        human_readable = tableToMarkdown('Package information', package)
        human_readable += tableToMarkdown('Parameters information', params)
        human_readable += tableToMarkdown('Files information', files)
        return human_readable, outputs, raw_response


    def create_package(client, data_args):
        name = data_args.get('name')
        command = data_args.get('command')
        body = {'name': name, 'command': command}

        raw_response = client.do_request('POST', 'packages', body)
        package = client.get_package_item(raw_response.get('data'))

        params = package.get('Parameters')
        files = package.get('Files')

        context = createContext(package, removeNull=True)
        outputs = {'TaniumPackage(val.ID && val.ID === obj.ID)': context}

        human_readable = tableToMarkdown('Package information', package)
        human_readable += tableToMarkdown('Parameters information', params)
        human_readable += tableToMarkdown('Files information', files)
        return human_readable, outputs, raw_response


    def get_packages(client, data_args):
        count = int(data_args.get('limit'))
        raw_response = client.do_request('GET', 'packages')
        packages = []

        # ignoring the last item because its not a package object
        for package in raw_response.get('data', [])[:-1][:count]:
            package = client.get_package_item(package)

            del package['Files']
            del package['Parameters']
            packages.append(package)

        context = createContext(packages, removeNull=True)
        outputs = {'TaniumPackage(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Packages', packages)
        return human_readable, outputs, raw_response


    def get_sensor(client, data_args):
        id_ = data_args.get('id')
        name = data_args.get('name')
        endpoint_url = ''
        if not id_ and not name:
            raise ValueError('id and name arguments are missing, Please specify one of them.')
        if name:
            endpoint_url = 'sensors/by-name/' + name
        if id_:
            endpoint_url = 'sensors/' + str(id_)

        raw_response = client.do_request('GET', endpoint_url)
        sensor = client.get_sensor_item(raw_response.get('data'))

        context = createContext(sensor, removeNull=True)
        outputs = {'TaniumSensor(val.ID && val.ID === obj.ID)': context}

        params = sensor['Parameters']
        del sensor['Parameters']

        human_readable = tableToMarkdown('Sensor information', sensor)
        human_readable += tableToMarkdown('Parameter information', params)
        return human_readable, outputs, raw_response


    def get_sensors(client, data_args):
        count = int(data_args.get('limit'))
        res = client.do_request('GET', 'sensors/')

        sensors = []
        # ignoring the last item because its not a sensor object
        for sensor in res.get('data', [])[:-1][:count]:
            sensor = client.get_sensor_item(sensor)
            del sensor['Parameters']
            sensors.append(sensor)

        context = createContext(sensors, removeNull=True)
        outputs = {'TaniumSensor(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Sensors', sensors)
        return human_readable, outputs, res


    def ask_question(client, data_args):
        question_text = data_args.get('question-text')
        parameters = data_args.get('parameters')

        body = client.parse_question(question_text, parameters)
        id_, res = client.create_question(body)
        context = {'ID': id_}
        context = createContext(context, removeNull=True)
        outputs = {'Tanium.Question(val.ID && val.ID === obj.ID)': context}
        return f'New question created. ID = {str(id_)}', outputs, res


    def get_question_metadata(client, data_args):
        id_ = data_args.get('question-id')
        raw_response = client.do_request('GET', 'questions/' + str(id_))
        question_data = raw_response.get('data')
        question_data = client.get_question_item(question_data)

        context = createContext(question_data, removeNull=True)
        outputs = {'Tanium.Question(val.Tanium.ID && val.Tanium.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Question results', question_data)
        return human_readable, outputs, raw_response


    def get_question_result(client, data_args):
        id_ = data_args.get('question-id')
        res = client.do_request('GET', 'result_data/question/' + str(id_))

        rows = client.parse_question_results(res)

        if rows is None:
            context = {'QuestionID': id_, 'Status': 'Pending'}
            return f'Question is still executing, Question id: {str(id_)}',\
                {f'Tanium.QuestionResult(val.QuestionID == {id_})': context}, res

        context = {'QuestionID': id_, 'Status': 'Completed', 'Results': rows}
        context = createContext(context, removeNull=True)
        outputs = {f'Tanium.QuestionResult(val.QuestionID == {id_})': context}
        human_readable = tableToMarkdown('Question results', rows)
        return human_readable, outputs, res


    def create_saved_question(client, data_args):
        id_ = data_args.get('question-id')
        name = data_args.get('name')
        body = {'name': name, 'question': {'id': id_}}
        raw_response = client.do_request('POST', 'saved_questions', body)

        response = raw_response.get('data')
        response = client.update_id(response)

        context = createContext(response, removeNull=True)
        outputs = {'Tanium.SavedQuestion(val.ID && val.ID === obj.ID)': context}
        saved_question_id = str(response['ID'])
        return f'Question saved. ID = {saved_question_id}', outputs, raw_response


    def get_saved_question_metadata(client, data_args):
        id_ = data_args.get('question-id')
        name = data_args.get('question-name')
        endpoint_url = ''
        if not id_ and not name:
            raise ValueError('question id and question name arguments are missing, Please specify one of them.')
        if name:
            endpoint_url = 'saved_questions/by-name/' + name
        if id_:
            endpoint_url = 'saved_questions/' + str(id_)

        raw_response = client.do_request('GET', endpoint_url)
        response = client.get_saved_question_item(raw_response.get('data'))

        context = createContext(response, removeNull=True)
        outputs = {'Tanium.SavedQuestion(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Saved question information', context)
        return human_readable, outputs, raw_response


    def get_saved_question_result(client, data_args):
        id_ = data_args.get('question-id')

        res = client.do_request('GET', 'result_data/saved_question/' + str(id_))

        rows = client.parse_question_results(res)
        if rows is None:
            context = {'SavedQuestionID': id_, 'Status': 'Pending'}
            return f'Question is still executing, Question id: {str(id_)}',\
                {f'Tanium.SavedQuestionResult(val.SavedQuestionID == {id_})': context}, res

        context = {'SavedQuestionID': id_, 'Status': 'Completed', 'Results': rows}
        context = createContext(context, removeNull=True)
        outputs = {f'Tanium.SavedQuestionResult(val.SavedQuestionID == {id_})': context}
        human_readable = tableToMarkdown('question results:', rows)
        return human_readable, outputs, res


    def get_saved_questions(client, data_args):
        count = int(data_args.get('limit'))
        raw_response = client.do_request('GET', 'saved_questions')

        questions = []
        # ignoring the last item because its not a saved question object
        for question in raw_response.get('data', [])[:-1][:count]:
            question = client.get_saved_question_item(question)
            questions.append(question)

        context = createContext(questions, removeNull=True)
        outputs = {'Tanium.SavedQuestion(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Saved questions', questions)
        return human_readable, outputs, raw_response


    def create_action(client, data_args):
        action_name = data_args.get('action-name')
        package_id = data_args.get('package-id')
        package_name = data_args.get('package-name')
        target_group_id = data_args.get('target-group-id')
        target_group_name = data_args.get('target-group-name')
        action_group_id = data_args.get('action-group-id')
        action_group_name = data_args.get('action-group-name')
        parameters = data_args.get('parameters')

        body = client.build_create_action_body(False, action_name, parameters, package_id=package_id,
                                               package_name=package_name, action_group_id=action_group_id,
                                               action_group_name=action_group_name, target_group_id=target_group_id,
                                               target_group_name=target_group_name)

        raw_response = client.do_request('POST', 'actions', body)
        action = client.get_action_item(raw_response.get('data'))

        context = createContext(action, removeNull=True)
        outputs = {'Tanium.Action(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Action created', action)
        return human_readable, outputs, raw_response


    def create_action_by_host(client, data_args):
        action_name = data_args.get('action-name')
        package_id = data_args.get('package-id')
        package_name = data_args.get('package-name')
        action_group_id = data_args.get('action-group-id')
        action_group_name = data_args.get('action-group-name')
        parameters = data_args.get('parameters')
        ip_address = data_args.get('ip-address')
        hostname = data_args.get('hostname')

        body = client.build_create_action_body(True, action_name, parameters, package_id=package_id,
                                               package_name=package_name, action_group_id=action_group_id,
                                               action_group_name=action_group_name,
                                               hostname=hostname, ip_address=ip_address)

        raw_response = client.do_request('POST', 'actions', body)
        action = client.get_action_item(raw_response.get('data'))

        context = createContext(action, removeNull=True)
        outputs = {'Tanium.Action(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Action created', action)
        return human_readable, outputs, raw_response


    def get_action(client, data_args):
        id_ = data_args.get('id')
        raw_response = client.do_request('GET', 'actions/' + str(id_))
        action = raw_response.get('data')
        action = client.get_action_item(action)

        context = createContext(action, removeNull=True)
        outputs = {'Tanium.Action(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Action information', action)
        return human_readable, outputs, raw_response


    def get_actions(client, data_args):
        count = int(data_args.get('limit'))
        raw_response = client.do_request('GET', 'actions')

        actions = []
        # ignoring the last item because its not action object
        for action in raw_response.get('data', [])[:-1][:count]:
            action = client.get_action_item(action)
            actions.append(action)

        context = createContext(actions, removeNull=True)
        outputs = {'Tanium.Action(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Actions', actions)
        return human_readable, outputs, raw_response


    def create_saved_action(client, data_args):
        action_group_id = data_args.get('action-group-id')
        package_id = data_args.get('package-id')
        name = data_args.get('name')

        body = {'name': name, 'action_group': {'id': action_group_id}, 'package_spec': {'id': package_id}}
        raw_response = client.do_request('POST', 'saved_actions', body)
        response = client.get_saved_action_item(raw_response.get('data'))

        context = createContext(response, removeNull=True)
        outputs = {'Tanium.SavedAction(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Saved action created', context)
        return human_readable, outputs, raw_response


    def get_saved_action(client, data_args):
        id_ = data_args.get('id')
        name = data_args.get('name')
        endpoint_url = ''
        if not id_ and not name:
            raise ValueError('id and name arguments are missing, Please specify one of them.')
        if name:
            endpoint_url = 'saved_actions/by-name/' + name
        if id_:
            endpoint_url = 'saved_actions/' + str(id_)

        raw_response = client.do_request('GET', endpoint_url)
        response = client.get_saved_action_item(raw_response.get('data'))

        context = createContext(response, removeNull=True)
        outputs = {'Tanium.SavedAction(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Saved action information', context)
        return human_readable, outputs, raw_response


    def get_saved_actions(client, data_args):
        count = int(data_args.get('limit'))
        raw_response = client.do_request('GET', 'saved_actions')

        actions = []
        # ignoring the last item because its not a saved action object
        for action in raw_response.get('data', [])[:-1][:count]:
            action = client.get_saved_action_item(action)
            actions.append(action)

        context = createContext(actions, removeNull=True)
        outputs = {'Tanium.SavedAction(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Saved actions', actions)
        return human_readable, outputs, raw_response


    def get_saved_actions_pending(client, data_args):
        count = int(data_args.get('limit'))
        raw_response = client.do_request('GET', 'saved_action_approvals')

        actions = []
        for action in raw_response.get('data', [])[:count]:
            action = client.get_saved_action_pending_item(action)
            actions.append(action)

        context = createContext(actions, removeNull=True)
        outputs = {'Tanium.PendingSavedAction(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Saved actions pending approval', actions)
        return human_readable, outputs, raw_response


    def create_manual_group(client, data_args):
        group_name = data_args.get('group-name')
        hosts = data_args.get('computer-names')
        ip_addresses = data_args.get('ip-addresses')

        if not ip_addresses and not hosts:
            raise ValueError('computer-names and ip-addresses arguments are missing, Please specify one of them.')

        body = {'name': group_name}

        hosts_list = []
        ips_list = []

        if hosts:
            hosts = hosts.split(',')
            for host in hosts:
                hosts_list.append({'computer_name': host})

        if ip_addresses:
            ip_addresses = ip_addresses.split(',')
            for ip in ip_addresses:
                ips_list.append({'ip_address': ip})

        body['computer_specs'] = hosts_list
        body['computer_specs'].extend(ips_list)

        raw_response = client.do_request('POST', 'computer_groups', body)
        group = raw_response.get('data')
        group = client.get_group_item(group)

        context = createContext(group, removeNull=True)
        outputs = {'Tanium.Group(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Group created', context)
        return human_readable, outputs, raw_response


    def create_filter_based_group(client, data_args):
        group_name = data_args.get('group-name')
        text_filter = data_args.get('text-filter')

        body = {'name': group_name, 'text': text_filter}

        raw_response = client.do_request('POST', 'groups', body)
        group = raw_response.get('data')
        group = client.get_group_item(group)

        context = createContext(group, removeNull=True)
        outputs = {'Tanium.Group(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Group created', context)
        return human_readable, outputs, raw_response


    def get_group(client, data_args):
        id_ = data_args.get('id')
        name = data_args.get('name')
        endpoint_url = ''
        if not id_ and not name:
            raise ValueError('id and name arguments are missing, Please specify one of them.')
        if name:
            endpoint_url = 'groups/by-name/' + name
        if id_:
            endpoint_url = 'groups/' + str(id_)

        raw_response = client.do_request('GET', endpoint_url)
        group = raw_response.get('data')
        group = client.get_group_item(group)

        context = createContext(group, removeNull=True)
        outputs = {'Tanium.Group(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Group information', group)
        return human_readable, outputs, raw_response


    def get_groups(client, data_args):
        count = int(data_args.get('limit'))
        groups = []

        raw_response = client.do_request('GET', 'groups')
        # ignoring the last item because its not a group object
        for group in raw_response.get('data', [])[:-1][:count]:
            groups.append(client.get_group_item(group))

        context = createContext(groups, removeNull=True)
        outputs = {'Tanium.Group(val.ID && val.ID === obj.ID)': context}
        human_readable = tableToMarkdown('Groups', groups)
        return human_readable, outputs, raw_response


    def delete_group(client, data_args):
        id_ = data_args.get('id')
        raw_response = client.do_request('DELETE', f'groups/{id_}')
        group = {'ID': int(id_), 'Deleted': True}
        human_readable = f'Group has been deleted. ID = {id_}'
        context = createContext(group, removeNull=True)
        outputs = {'Tanium.Group(val.ID && val.ID === obj.ID)': context}
        return human_readable, outputs, raw_response


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    def main():
        params = demisto.params()
        username = params.get('credentials').get('identifier')
        password = params.get('credentials').get('password')
        domain = params.get('domain')
        # Remove trailing slash to prevent wrong URL path to service
        server = params['url'].strip('/')
        # Service base URL
        base_url = server + '/api/v2/'
        # Should we use SSL
        use_ssl = not params.get('insecure', False)

        # Remove proxy if not set to true in params
        handle_proxy()
        command = demisto.command()
        client = Client(base_url, username, password, domain, verify=use_ssl)
        demisto.info(f'Command being called is {command}')

        commands = {
            'test-module': test_module,
            f'tn-get-system-status': get_system_status,
            f'tn-get-package': get_package,
            f'tn-create-package': create_package,
            f'tn-list-packages': get_packages,
            f'tn-get-sensor': get_sensor,
            f'tn-list-sensors': get_sensors,
            f'tn-ask-question': ask_question,
            f'tn-get-question-metadata': get_question_metadata,
            f'tn-get-question-result': get_question_result,
            f'tn-create-saved-question': create_saved_question,
            f'tn-get-saved-question-metadata': get_saved_question_metadata,
            f'tn-get-saved-question-result': get_saved_question_result,
            f'tn-list-saved-questions': get_saved_questions,
            f'tn-create-action': create_action,
            f'tn-create-action-by-host': create_action_by_host,
            f'tn-get-action': get_action,
            f'tn-list-actions': get_actions,
            f'tn-create-saved-action': create_saved_action,
            f'tn-get-saved-action': get_saved_action,
            f'tn-list-saved-actions': get_saved_actions,
            f'tn-list-saved-actions-pending-approval': get_saved_actions_pending,
            f'tn-create-filter-based-group': create_filter_based_group,
            f'tn-create-manual-group': create_manual_group,
            f'tn-get-group': get_group,
            f'tn-list-groups': get_groups,
            f'tn-delete-group': delete_group
        }

        try:
            if command in commands:
                human_readable, outputs, raw_response = commands[command](client, demisto.args())
                return_outputs(readable_output=human_readable, outputs=outputs, raw_response=raw_response)
            # Log exceptions
        except Exception as e:
            err_msg = f'Error in Tanium v2 Integration [{e}]'
            return_error(err_msg, error=e)


    if __name__ == 'builtins':
        main()
  subtype: python3
  type: python
system: true
