category: Vulnerability Management
commonfields:
  id: Kennav2
  version: -1
configuration:
- defaultvalue: https://api.kennasecurity.com
  display: Server URL (e.g.  https://api.kennasecurity.com)
  name: url
  required: false
  type: 0
- defaultvalue: ""
  display: Kenna API key
  name: key
  required: true
  type: 4
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
description: Use the Kenna v2 integration to search and update vulnerabilities, schedule
  a run connector, and manage tags and attributes.
detaileddescription: "# Access Your Kenna API Key\n1. Log in to your (Kenna account)[https://app.kennasecurity.com].
  \n2. Click the **API Keys** tab.\n3. Copy your API key.\n"
display: Kenna v2
image: data:image/png;base64,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
name: Kennav2
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: Whether to return vulnerabilities that Kenna deems a top priority
        to fix. Can be "true" or "false".
      isArray: true
      name: top-priority
      predefined:
      - "true"
      - "false"
    - description: The minimum vulnerability score for which to return vulnerabilities.
      name: min-score
    - auto: PREDEFINED
      description: The status of the vulnerability. Can be "open", "closed", "risk_accepted",
        or "false_positive".
      isArray: true
      name: status
      predefined:
      - open
      - closed
      - risk_accepted
      - false_positive
    - defaultValue: "500"
      description: The maximum number of vulnerabilities to return. The default value
        is 500.
      name: limit
    - auto: PREDEFINED
      default: true
      defaultValue: "True"
      description: Whether to flush to context. Can be "True" or "False". The default
        value is "True".
      name: to_context
      predefined:
      - "True"
      - "False"
    - description: The vulnerability ID for which to search.
      isArray: true
      name: id
    description: Searches for vulnerabilities in Kenna.
    name: kenna-search-vulnerabilities
    outputs:
    - contextPath: Kenna.Vulnerabilities.AssetID
      description: The asset ID related to the vulnerability.
      type: Number
    - contextPath: Kenna.Vulnerabilities.Connectors.DefinitionName
      description: The connector definition name related to the vulnerability.
      type: String
    - contextPath: Kenna.Vulnerabilities.Connectors.ID
      description: The connector ID related to the vulnerability.
      type: Number
    - contextPath: Kenna.Vulnerabilities.Connectors.Name
      description: The connector name related to the vulnerability.
      type: String
    - contextPath: Kenna.Vulnerabilities.Connectors.Vendor
      description: The connector vendor related to the vulnerability.
      type: String
    - contextPath: Kenna.Vulnerabilities.CveID
      description: The CVE ID related to the vulnerability.
      type: String
    - contextPath: Kenna.Vulnerabilities.FixID
      description: The fix ID related to the vulnerability.
      type: String
    - contextPath: Kenna.Vulnerabilities.Patch
      description: Whether there is a patch related to the vulnerability.
      type: Boolean
    - contextPath: Kenna.Vulnerabilities.ScannerVulnerabilities.ExternalID
      description: The vulnerability scanner external ID.
      type: String
    - contextPath: Kenna.Vulnerabilities.ScannerVulnerabilities.Open
      description: Whether the vulnerability scanner is open.
      type: Boolean
    - contextPath: Kenna.Vulnerabilities.ScannerVulnerabilities.Port
      description: The vulnerability scanner port.
      type: Number
    - contextPath: Kenna.Vulnerabilities.Score
      description: The vulnerability score.
      type: Number
    - contextPath: Kenna.Vulnerabilities.ServiceTicket.DueDate
      description: The service ticket due date.
      type: Date
    - contextPath: Kenna.Vulnerabilities.ServiceTicket.ExternalIdentifier
      description: The service ticket external identifier.
      type: String
    - contextPath: Kenna.Vulnerabilities.ServiceTicket.Status
      description: The service ticket status.
      type: String
    - contextPath: Kenna.Vulnerabilities.ServiceTicket.TicketType
      description: The service ticket type.
      type: String
    - contextPath: Kenna.Vulnerabilities.Severity
      description: The vulnerability severity.
      type: Number
    - contextPath: Kenna.Vulnerabilities.Status
      description: The vulnerability status.
      type: String
    - contextPath: Kenna.Vulnerabilities.Threat
      description: The vulnerability threat.
      type: Number
    - contextPath: Kenna.Vulnerabilities.TopPriority
      description: The vulnerability priority.
      type: Number
    - contextPath: Kenna.Vulnerabilities.ID
      description: The vulnerability ID.
      type: Number
  - arguments:
    - description: The connector ID to run.
      name: id
      required: true
    description: Executes a run of the specified connector. If file based, it will
      use the most recently uploaded data file.
    execution: true
    name: kenna-run-connector
  - arguments:
    - description: The vulnerability ID for which to search.
      isArray: true
      name: id
    - auto: PREDEFINED
      description: Whether to return vulnerabilities that Kenna deems a top priority
        to fix. Can be "true" or "false".
      isArray: true
      name: top-priority
      predefined:
      - "true"
      - "false"
    - description: The minimum vulnerability score for which to return vulnerabilities.
      name: min-score
    - auto: PREDEFINED
      description: The status of the vulnerability. Can be "open", "closed", "risk_accepted",
        or "false_positive".
      isArray: true
      name: status
      predefined:
      - open
      - closed
      - risk_accepted
      - false_positive
    - description: vulnerabilities for search.
      name: vulnerabilities
    - defaultValue: "500"
      description: The maximum number of vulnerabilities to return. The default value
        is 500.
      name: limit
    - auto: PREDEFINED
      defaultValue: "True"
      description: Whether to flush to context. Can be "True" or "False". The default
        value is "True".
      name: to_context
      predefined:
      - "True"
      - "False"
    description: Filters fixes by a given set of vulnerability and asset parameters
      and returns the filtered fixes.
    name: kenna-search-fixes
    outputs:
    - contextPath: Kenna.Fixes.ID
      description: The fix ID.
      type: Number
    - contextPath: Kenna.Fixes.Title
      description: The fix title.
      type: String
    - contextPath: Kenna.Fixes.Assets.ID
      description: The asset ID related to the current fix.
      type: Number
    - contextPath: Kenna.Fixes.Assets.Locator
      description: The asset locator related to the current fix.
      type: String
    - contextPath: Kenna.Fixes.Assets.PrimaryLocator
      description: The asset primary locator related to the current fix.
      type: String
    - contextPath: Kenna.Fixes.Assets.DisplayLocator
      description: The asset display locator related to the current fix.
      type: String
    - contextPath: Kenna.Fixes.Vulnerabilities.ID
      description: The vulnerability ID related to the current fix.
      type: Number
    - contextPath: Kenna.Fixes.Vulnerabilities.ServiceTicketStatus
      description: The vulnerability service ticket status related to the current
        fix.
      type: String
    - contextPath: Kenna.Fixes.Vulnerabilities.ScannerIDs
      description: The vulnerability scanner IDs related to the current fix.
      type: Number
    - contextPath: Kenna.Fixes.CveID
      description: The CVE-ID list related to the current fix.
      type: String
    - contextPath: Kenna.Fixes.LastUpdatedAt
      description: The timestamp when the current fix was last updated.
      type: String
    - contextPath: Kenna.Fixes.Category
      description: The category of fix.
      type: String
    - contextPath: Kenna.Fixes.VulnerabilityCount
      description: The vulnerability count of the fix.
      type: Number
    - contextPath: Kenna.Fixes.MaxScore
      description: The maximum score of the fix.
      type: Number
  - arguments:
    - description: The ID of the asset to update.
      name: id
      required: true
    - description: Notes about the asset.
      name: notes
      required: true
    description: Updates the attributes of a single asset.
    name: kenna-update-asset
  - arguments:
    - description: The ID of the vulnerability to update.
      name: id
      required: true
    - auto: PREDEFINED
      description: The status of the vulnerability. Can be "open", "closed", "risk_accepted",
        or "false_positive".
      name: status
      predefined:
      - open
      - closed
      - risk_accepted
      - false_positive
    - description: Notes about the vulnerability.
      name: notes
    description: Updates the attributes of a single vulnerability.
    name: kenna-update-vulnerability
  - arguments: []
    description: Returns all connectors.
    name: kenna-get-connectors
    outputs:
    - contextPath: Kenna.ConnectorsList.ID
      description: The connector ID.
      type: Number
    - contextPath: Kenna.ConnectorsList.Name
      description: The connector name.
      type: String
    - contextPath: Kenna.ConnectorsList.Running
      description: The running connector.
      type: Boolean
    - contextPath: Kenna.ConnectorsList.Host
      description: The connector host.
      type: String
  - arguments:
    - description: The asset ID to search for.
      isArray: true
      name: id
    - description: The hostname of the asset to search for.
      isArray: true
      name: hostname
    - description: The minimum vulnerability score for which to return vulnerabilities.
      name: min-score
    - description: The tags by which to search.
      isArray: true
      name: tags
    - defaultValue: "500"
      description: The maximum number of vulnerabilities to return. The default value
        is 500.
      name: limit
    - auto: PREDEFINED
      defaultValue: "True"
      description: Whether to print output to context. Can be "True" or "False". The
        default value is "True".
      name: to_context
      predefined:
      - "True"
      - "False"
    description: Searches for assets.
    name: kenna-search-assets
    outputs:
    - contextPath: Kenna.Assets.ID
      description: The asset ID.
      type: Number
    - contextPath: Kenna.Assets.Hostname
      description: The hostname of the asset.
      type: String
    - contextPath: Kenna.Assets.IpAddress
      description: The asset IP address.
      type: String
    - contextPath: Kenna.Assets.Score
      description: The asset risk score.
      type: Number
    - contextPath: Kenna.Assets.VulnerabilitiesCount
      description: The number of vulnerabilities associated with the asset.
      type: Number
    - contextPath: Kenna.Assets.OperatingSystem
      description: The asset operating system.
      type: String
    - contextPath: Kenna.Assets.Tags
      description: A list of the asset's tags.
      type: String
    - contextPath: Kenna.Assets.Fqdn
      description: The asset FQDN.
      type: String
    - contextPath: Kenna.Assets.Status
      description: The asset status.
      type: String
    - contextPath: Kenna.Assets.Owner
      description: The asset owner.
      type: String
    - contextPath: Kenna.Assets.Priority
      description: The asset priority.
      type: Number
    - contextPath: Kenna.Assets.Notes
      description: Notes of current asset.
      type: String
    - contextPath: Kenna.Assets.OperatingSystem
      description: Operating system of asset
      type: String
  - arguments:
    - description: The asset ID for which to get vulnerabilities.
      isArray: true
      name: id
      required: true
    - defaultValue: "500"
      description: The maximum number of vulnerabilities to return. The default value
        is 500.
      name: limit
    - auto: PREDEFINED
      defaultValue: "True"
      description: Whether to print output to context. Can be "True" or "False". The
        default value is "True".
      name: to_context
      predefined:
      - "True"
      - "False"
    description: Gets vulnerabilities of the specified asset.
    name: kenna-get-asset-vulnerabilities
    outputs:
    - contextPath: Kenna.VulnerabilitiesOfAsset.AssetID
      description: The ID of the asset that this vulnerability is associated with.
      type: Number
    - contextPath: Kenna.VulnerabilitiesOfAsset.CveID
      description: 'The CVE ID of the vulnerability associated with the asset. '
      type: String
    - contextPath: Kenna.VulnerabilitiesOfAsset.ID
      description: 'The ID of the vulnerability associated withe the asset '
      type: Number
    - contextPath: Kenna.VulnerabilitiesOfAsset.Patch
      description: 'Whether there is a patch for the vulnerability associated with
        the asset. '
      type: Boolean
    - contextPath: Kenna.VulnerabilitiesOfAsset.Status
      description: 'The status of the vulnerability associated with the asset. '
      type: String
    - contextPath: Kenna.VulnerabilitiesOfAsset.TopPriority
      description: 'Whether the vulnerability associated with the asset is a top priority. '
      type: Boolean
    - contextPath: Kenna.VulnerabilitiesOfAsset.Score
      description: 'The score of the vulnerability associated with the asset. '
      type: Number
  - arguments:
    - description: A comma-separated list of tags to add to the asset.
      isArray: true
      name: tag
      required: true
    - description: 'The asset ID to which to add the tag. '
      name: id
      required: true
    description: Adds a tag to the specified asset.
    name: kenna-add-tag
  - arguments:
    - description: The asset ID from which to delete the tag.
      name: id
      predefined:
      - ""
      required: true
    - description: The tag to delete.
      name: tag
      required: true
    description: Deletes tags from the specified asset.
    name: kenna-delete-tag
  dockerimage: demisto/python3:3.7.5.4002
  runonce: false
  script: |
    from typing import List, Tuple, Dict, Any, Optional, Callable

    import urllib3



    # Disable insecure warnings
    urllib3.disable_warnings()


    def parse_response(raw_data: List[Dict[str, Any]], wanted_keys: List[Any], actual_keys: List[Any]) -> \
            List[Dict[str, Any]]:
        """Lists all raw data and return outputs in Demisto's format.
        Args:
            raw_data: raw response from the api.
            wanted_keys: The keys as we would like them to be.
            actual_keys :The keys as they are in raw response.
        Returns:
            Specific Keys from the raw data.
        """

        context_list = []
        for raw in raw_data:
            context = {}
            for wanted_key, actual_key in zip(wanted_keys, actual_keys):
                if isinstance(wanted_key, list):
                    inner_raw = raw.get(actual_key[0])
                    if inner_raw:
                        lst_inner = []
                        for in_raw in inner_raw:
                            inner_dict = {}
                            for inner_wanted_key, inner_actual_key in zip(wanted_key[1:], actual_key[1:]):
                                inner_dict.update({inner_wanted_key: in_raw.get(inner_actual_key)})
                            lst_inner.append(inner_dict)
                        context.update({wanted_key[0]: lst_inner})
                else:
                    context.update({wanted_key: raw.get(actual_key)})
            context_list.append(context)
        return context_list


    class Client(BaseClient):
        def __init__(self, base_url: str, api_key: str, verify: bool, proxy: bool):
            header = {
                'X-Risk-Token': api_key,
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            super().__init__(base_url=base_url, verify=verify, proxy=proxy, headers=header)

        def http_request(self, message: str, suffix: str, params: Optional[dict] = None,
                         data: Optional[dict] = None) -> Dict[str, Any]:

            """Connects to api and Returns response.
               Args:
                   message: The HTTP message, for example: GET, POST, and so on
                   suffix :The API endpoint.
                   params: URL parameters to specify the query.
                   data:The data to send in a specific request.
               Returns:
                   response from the api.
               """
            url = f'{self._base_url}{suffix}'
            try:
                response = requests.request(
                    message,
                    url,
                    headers=self._headers,
                    params=params,
                    json=data,
                    verify=self._verify,
                )
            except requests.exceptions.SSLError as err:
                raise DemistoException(f'Connection error in the API call to Kenna.\n'
                                       f'Check your not secure parameter.\n\n{err}')
            except requests.ConnectionError as err:
                raise DemistoException(f'Connection error in the API call to Kenna.\n'
                                       f'Check your Server URL parameter.\n\n{err}')
            try:
                response_list = response.json() if response.text else {}
                if not response.ok:
                    if response_list.get('error') == "unauthorized":
                        raise DemistoException(f'Connection error in the API call to Kenna.\n'
                                               f'Check your Api Key parameter.\n\n{demisto.get(response_list, "error.message")}')
                    else:
                        raise DemistoException(f'API call to Kenna failed ,Error code [{response.status_code}]'
                                               f' - {demisto.get(response_list, "error.message")}')
                elif response.status_code == 204:
                    return {'status': 'success'}
                return response_list
            except TypeError:
                raise Exception(f'Error in API call to Kenna, could not parse result [{response.status_code}]')


    def test_module(client: Client, *_):
        """
        Performs basic get request from Kenna v2
        """
        res_vulnerabilities = client.http_request('GET', '/vulnerabilities')
        res_assets = client.http_request('GET', '/assets')

        if isinstance(res_vulnerabilities.get('vulnerabilities'), list) and isinstance(res_assets.get('assets'), list):
            return 'ok', None, None
        raise Exception('Error occurred while trying to query the api.')


    def search_vulnerabilities(client: Client, args: dict) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """Search vulnerability command.
        Args:
            client: Client which connects to api
            args: arguments for the request
        Returns:
            Human Readable
            Entry Context
            Raw Data
        """
        url_suffix = '/vulnerabilities/search'
        limit: int = int(args.get('limit', 500))
        to_context = args.get('to_context')
        human_readable = []
        context: Dict[str, Any] = {}
        params = {
            f'id[]': argToList(args.get('id')),
            f'top_priority[]': argToList(args.get('top-priority')),
            f'min_risk_meter_score': args.get('min-score'),
            f'status[]': argToList(args.get('status')),
        }
        response = client.http_request(message='GET', suffix=url_suffix,
                                       params=params).get('vulnerabilities')

        if response:
            vulnerability_list = response[:limit]
            wanted_keys = ['AssetID', ['Connectors', 'DefinitionName', 'ID', 'Name', 'Vendor'], 'CveID', 'FixID',
                           'ID', 'Patch',
                           'Score', ['ScannerVulnerabilities', 'ExternalID', 'Open', 'Port'],
                           'Severity',
                           'Status', 'Threat', 'TopPriority',
                           ['ServiceTicket', 'DueDate', 'ExternalIdentifier', 'Status', 'TicketType']]
            actual_keys = ['asset_id', ['connectors', 'connector_definition_name', 'id', 'name', 'vendor'], 'cve_id',
                           'fix_id',
                           'id', 'patch', 'risk_meter_score',
                           ['scanner_vulnerabilities', 'external_unique_id', 'open', 'port'],
                           'severity', 'status', 'threat', 'top_priority',
                           ['service_ticket', 'due_date', 'external_identifier', 'status', 'ticket_type']]

            context_list = parse_response(vulnerability_list, wanted_keys, actual_keys)
            for lst in vulnerability_list:
                human_readable.append({
                    'id': lst.get('id'),
                    'Name': lst.get('cve_id'),
                    'Score': lst.get('risk_meter_score')
                })
            context = {
                'Kenna.Vulnerabilities(val.ID === obj.ID)': context_list
            }
            human_readable_markdown = tableToMarkdown('Kenna Vulnerabilities', human_readable, removeNull=True)
        else:
            human_readable_markdown = "no vulnerabilities found."

        if to_context == "False":
            return human_readable_markdown, {}, response
        return human_readable_markdown, context, response


    def get_connectors(client: Client, *_) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """Get Connectors command.
        Args:
            client:  Client which connects to api
        Returns:
            Human Readable
            Entry Context
            Raw Data
        """
        url_suffix = '/connectors'
        human_readable = []
        context: Dict[str, Any] = {}
        connectors = client.http_request(message='GET', suffix=url_suffix).get('connectors')
        if connectors:
            wanted_keys = ['Host', 'Name', 'Running', 'ID']
            actual_keys = ['host', 'name', 'running', 'id']
            context_list = parse_response(connectors, wanted_keys, actual_keys)

            for connector in connectors:
                curr_dict = {
                    'Host': connector.get('host'),
                    'Name': connector.get('name'),
                    'Running': connector.get('running'),
                    'ID': connector.get('id')
                }
                human_readable.append(curr_dict)
            context = {
                'Kenna.ConnectorsList(val.ID === obj.ID)': context_list
            }
            human_readable_markdown = tableToMarkdown('Kenna Connectors', human_readable, removeNull=True)
        else:
            human_readable_markdown = "no connectors in get response."

        return human_readable_markdown, context, connectors


    def run_connector(client: Client, args: dict) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """Run Connector command.
        Args:
            client:  Client which connects to api
            args: arguments for the request
        Returns:
            Success/ Failure , according to the response
        """
        args_id: str = str(args.get('id'))
        url_suffix = f'/connectors/{args_id}/run'
        run_response = client.http_request(message='GET', suffix=url_suffix)
        if run_response and run_response.get('success') == 'true':
            return f'Connector {args_id} ran successfully.', {}, []
        return f'Connector {args_id} did not ran successfully.', {}, []


    def search_fixes(client: Client, args: dict) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """Search Fixes command.
        Args:
            client:  Client which connects to api
            args: arguments for the request
        Returns:
            Human Readable
            Entry Context
            Raw Data
        """
        human_readable_markdown = ''
        url_suffix = '/fixes/search'
        limit: int = int(args.get('limit', 500))
        to_context = args.get('to_context')
        context: Dict[str, Any] = {}
        params = {
            f'id[]': argToList(args.get('id')),
            f'top_priority[]': argToList(args.get('top-priority')),
            f'min_risk_meter_score': args.get('min-score'),
            f'status[]': argToList(args.get('status')),
        }
        response = client.http_request(message='GET', suffix=url_suffix, params=params).get('fixes')
        if response:
            fixes_list = response[:limit]

            wanted_keys = ['ID', 'Title', ['Assets', 'ID', 'Locator', 'PrimaryLocator', 'DisplayLocator'],
                           ['Vulnerabilities', 'ID', 'ServiceTicketStatus', 'ScannerIDs'], 'CveID', 'LastUpdatedAt',
                           'Category', 'VulnerabilityCount', 'MaxScore']
            actual_keys = ['id', 'title', ['assets', 'id', 'locator', 'primary_locator', 'display_locator'],
                           ['vulnerabilities', 'id', 'service_ticket_status', 'scanner_ids'], 'cves', 'updated_at',
                           'category',
                           'vuln_count', 'max_vuln_score']
            context_list = parse_response(fixes_list, wanted_keys, actual_keys)

            remove_html = re.compile(r'<[^>]+>')
            for fix in fixes_list:
                if fix:
                    human_readable_markdown += str(fix.get('title')) + '\n'
                    human_readable_markdown += '#### ID: ' + str(fix.get('id')) + '\n'
                    human_readable_markdown += str(fix.get('vuln_count')) + ' vulnerabilities affected\n'
                    human_readable_markdown += '#### Diagnosis:\n'
                    human_readable_markdown += remove_html.sub(' ', str(fix.get('diagnosis'))) + '\n' + '&nbsp;' + '\n'
            context = {
                'Kenna.Fixes(val.ID === obj.ID)': context_list
            }
        else:
            human_readable_markdown = "no fixes in response."
        if to_context == "False":
            return human_readable_markdown, {}, response
        return human_readable_markdown, context, response


    def update_asset(client: Client, args: dict) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """Update Asset command.
        Args:
            client:  Client which connects to api
            args: arguments for the request
        Returns:
            Success/ Failure , according to the response
        """

        args_id = str(args.get('id'))
        url_suffix = f'/assets/{args_id}'
        asset = {
            'asset': {
                'notes': args.get('notes')
            }
        }
        result = client.http_request(message='PUT', suffix=url_suffix, data=asset)
        try:
            if result.get('status') != "success":
                return 'Could not update asset.', {}, []
            return f'Asset {args_id} was updated', {}, []
        except DemistoException as err:
            return f'Error occurred while preforming update-asset command {err}', {}, []


    def update_vulnerability(client: Client, args: dict) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """Update Vulnerabilities command.
        Args:
            client:  Client which connects to api
            args: arguments for the request
        Returns:
            Success/ Failure , according to the response
        """
        params_to_update: dict = {
            'vulnerability': {}
        }
        args_id = str(args.get('id'))
        status = str(args.get('status'))
        notes = str(args.get('notes'))
        if notes:
            params_to_update['vulnerability'].update({'notes': notes})
        if status:
            params_to_update['vulnerability'].update({'status': status})
        url_suffix = f'/vulnerabilities/{args_id}'
        result = client.http_request(message='PUT', suffix=url_suffix, data=params_to_update)
        try:
            if result.get('status') != "success":
                return 'Could not update asset.', {}, []
            return f'Asset {args_id} was updated', {}, []
        except DemistoException as err:
            return f'Error occurred while preforming update-vulenrability command {err}', {}, []


    def search_assets(client: Client, args: dict) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """Search Asset command.
        Args:
            client:  Client which connects to api
            args: arguments for the request
        Returns:
            Human Readable
            Entry Context
            Raw Data
        """
        url_suffix = '/assets/search'
        human_readable = []
        limit: int = int(args.get('limit', 500))
        to_context = args.get('to_context')
        context: Dict[str, Any] = {}
        if args.get('tags'):
            tags = argToList(args.get('tags'))
        else:
            tags = args.get('tags')
        params = {
            f'id[]': argToList(args.get('id')),
            f'hostname[]': argToList(args.get('hostname')),
            f'min_risk_meter_score': args.get('min-score'),
            f'tags[]': tags
        }
        response = client.http_request(message='GET', suffix=url_suffix, params=params).get(
            'assets')
        if response:
            assets_list = response[:limit]
            wanted_keys = ['ID', 'Hostname', 'Score', 'IpAddress', 'VulnerabilitiesCount', 'OperatingSystem', 'Tags',
                           'Fqdn', 'Status', 'Owner', 'Priority', 'Notes', 'OperatingSystem']
            actual_keys = ['id', 'hostname', 'risk_meter_score', 'ip_address', 'vulnerabilities_count',
                           'operating_system',
                           'tags', 'fqdn', 'status', 'owner', 'priority', 'notes', 'operating_system']
            context_list: List[Dict[str, Any]] = parse_response(assets_list, wanted_keys, actual_keys)

            for lst in assets_list:
                human_readable.append({
                    'id': lst.get('id'),
                    'Hostname': lst.get('hostname'),
                    'IP-address': lst.get('ip_address'),
                    'Vulnerabilities Count': args.get('vulnerabilities_count'),
                    'Operating System': lst.get('operating_system'),
                    'Score': lst.get('risk_meter_score')
                })
            context = {
                'Kenna.Assets(val.ID === obj.ID)': context_list
            }
            human_readable_markdown = tableToMarkdown('Kenna Assets', human_readable, removeNull=True)
        else:
            human_readable_markdown = "no assets in response"
        if to_context == "False":
            return human_readable_markdown, {}, response
        return human_readable_markdown, context, response


    def get_asset_vulnerabilities(client: Client, args: dict) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """Get Asset by Vulnerability command.
        Args:
            client:  Client which connects to api
            args: arguments for the request
        Returns:
            Human Readable
            Entry Context
            Raw Data
        """
        args_id = str(args.get('id'))
        limit: int = int(args.get('limit', 500))
        to_context = args.get('to_context')
        url_suffix = f'/assets/{args_id}/vulnerabilities'
        human_readable = []
        context: Dict[str, Any] = {}

        response = client.http_request(message='GET', suffix=url_suffix).get(
            'vulnerabilities')
        if response:
            vulnerabilities_list = response[:limit]
            wanted_keys: List[Any] = ['AssetID', 'CveID', 'ID', 'Patch', 'Status', 'TopPriority', 'Score']
            actual_keys: List[Any] = ['asset_id', 'cve_id', 'id', 'patch', 'status', 'top_priority', 'risk_meter_score']
            context_list: List[Dict[str, Any]] = parse_response(vulnerabilities_list, wanted_keys, actual_keys)

            for lst in vulnerabilities_list:
                human_readable.append({
                    'id': lst.get('id'),
                    'Name': lst.get('cve_id'),
                    'Score': lst.get('risk_meter_score')
                })
            context = {
                'Kenna.VulnerabilitiesOfAsset(val.ID === obj.ID)': context_list
            }
            human_readable_markdown = tableToMarkdown('Kenna Vulnerabilities', human_readable, removeNull=True)
        else:
            human_readable_markdown = "no vulnerabilities in response"
        if to_context == "False":
            return human_readable_markdown, {}, response
        return human_readable_markdown, context, response


    def add_tags(client: Client, args: dict) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """Add tags command.
        Args:
            client:  Client which connects to api
            args: arguments for the request
        Returns:
            Success/ Failure , according to the response
        """
        args_id = str(args.get('id'))
        tags = str(args.get('tag'))
        url_suffix = f'/assets/{args_id}/tags'
        asset = {
            'asset': {
                'tags': tags
            }
        }
        result = client.http_request(message='PUT', suffix=url_suffix, data=asset)
        try:
            if result.get('status') != "success":
                return f'Tag {tags} was not added to asset {args_id}', {}, []
            return f'Tag {tags} was added to asset {args_id}', {}, []
        except DemistoException as err:
            return f'Error occurred while preforming add-tags command {err}', {}, []


    def delete_tags(client: Client, args: dict) -> Tuple[str, Dict[str, Any], List[Dict[str, Any]]]:
        """Delete tags command.
        Args:
            client:  Client which connects to api
            args: arguments for the request
        Returns:
            Success/ Failure , according to the response
        """
        args_id = str(args.get('id'))
        tags = str(args.get('tag'))
        url_suffix = f'/assets/{args_id}/tags'
        asset = {
            'asset': {
                'tags': tags
            }
        }
        result = client.http_request(message='DELETE', suffix=url_suffix, data=asset)
        try:
            if result.get('status') != "success":
                return f'Tag {tags} was not deleted to asset {args_id}', {}, []
            return f'Tag {tags} was deleted to asset {args_id}', {}, []
        except DemistoException as err:
            return f'Error occurred while preforming delete-tags command {err}', {}, []


    def main():
        params = demisto.params()
        api = params.get('key')
        # Service base URL
        base_url = params.get('url')
        # Should we use SSL
        use_ssl = not params.get('insecure', False)
        # Should we use system proxy settings
        use_proxy = params.get('proxy') == 'true'
        # Initialize Client object
        client = Client(base_url=base_url, api_key=api, verify=use_ssl, proxy=use_proxy)
        command = demisto.command()
        LOG(f'Command being called is {command}')
        # Commands dict
        commands: Dict[str, Callable[[Client, Dict[str, str]], Tuple[str, Dict[Any, Any], List[Any]]]] = {
            'test-module': test_module,
            'kenna-search-vulnerabilities': search_vulnerabilities,
            'kenna-get-connectors': get_connectors,
            'kenna-run-connector': run_connector,
            'kenna-search-fixes': search_fixes,
            'kenna-update-asset': update_asset,
            'kenna-update-vulnerability': update_vulnerability,
            'kenna-search-assets': search_assets,
            'kenna-get-asset-vulnerabilities': get_asset_vulnerabilities,
            'kenna-add-tag': add_tags,
            'kenna-delete-tag': delete_tags,
        }

        try:
            if command in commands:
                return_outputs(*commands[command](client, demisto.args()))
            else:
                raise NotImplementedError(f'{command} is not an existing Kenna v2 command')

        except Exception as err:
            return_error(f'Error from Kenna v2 Integration \n\n {err} \n', err)


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
