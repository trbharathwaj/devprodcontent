category: Email Gateway
commonfields:
  id: Proofpoint TAP v2
  version: -1
configuration:
- defaultvalue: https://tap-api-v2.proofpoint.com
  display: Server URL (e.g., https://tap-api-v2.proofpoint.com)
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: Service Principal (the Password refers to Secret)
  name: credentials
  required: true
  type: 9
- defaultvalue: v2
  display: API Version
  name: api_version
  options:
  - v1
  - v2
  required: false
  type: 15
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: A string specifying which threat type to return. If empty, all threat types
    are returned. Can be "url", "attachment", or "messageText".
  name: threat_type
  options:
  - url
  - attachment
  - messageText
  required: false
  type: 16
- defaultvalue: ""
  display: A string specifying which threat statuses to return. If empty, will return
    "active" and "cleared" threats.
  name: threat_status
  options:
  - active
  - cleared
  - falsePositive
  required: false
  type: 16
- defaultvalue: All
  display: Events to fetch
  name: events_type
  options:
  - All
  - Issues
  - Blocked Clicks
  - Permitted Clicks
  - Blocked Messages
  - Delivered Messages
  required: false
  type: 15
- defaultvalue: 1 hour
  display: First fetch time range (<number> <time unit>, e.g., 1 hour, 30 minutes)
    - Proofpoint supports maximum 1 hour fetch back
  name: fetch_time
  required: false
  type: 0
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
description: Use the Proofpoint Targeted Attack Protection (TAP) integration to protect
  against and provide additional visibility into phishing and other malicious email
  attacks.
detaileddescription: |+
  ## Configure an API account
  To configure an instance of the integration in Demisto, you need to supply your Service Principal and Service Secret. When you configure the integration instance, enter the Service Principal in the Service Principal field, and the Service Secret in the Password field.
  1. Log in to your Proofpoint TAP environment.
  2. Navigate to **Connect Applications > Service Credentials**.

display: Proofpoint TAP v2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAACHtJREFUeAHtmHls1UUQxx8KyI1AiiCHpoIkRA0QowSiIRKJyB+igChqMJEoGiNi8IBIsEgUEoxBSRS8SBQFBbWGwwO8QhBNOAppidJCoVQoFChHC6XS+vludx/Lj0d9fbYEyk74vpmdmZ3Znd3f7pZYLFCoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQKhAqECoQEOsQKOGOKnInJrSHn5ZLNYf3qIyFlsPfy/iUx/N0eTsrcDkXAzLqY8kl3rMRhR57uWxWJUDO/qn81EU8ix3Ock3OsWc9zL+hQL9h6cSo3EqnS6iPh0Z6xiNtyoWOwl+Az+ej/GzwCXkKrW5TqSYsx9xzPjpnwu+rm2culhgNmqsGxAvBMlMphN+xyxghprx2xk0B0fB3+AUOBddgeFqIH/Fkv8/wCfZ5KcF3goGSa6BumOTv2K5xUnkrmNfuVtYP/lXgDhxLE+g8ZJVFMcNZwutULUGynckYi732r7sqetW7MKOWgFWE3YGGIC8hiPkKCgFW9A97qXshH2Z9Z+GvhfySvwOII+1fm3hr6DLBopTDkrw+wP9eBDdhCrIy/hs8fwP46+79Rmg4osy0K3FpwJUAsXUuDNAS+Qltj2Xdl/k7/E5DDSPv9C9AKK5taAv4puFzxGgsSr3RvTPAW1SR1PRfyegGGiV82mvBpm0+9L3bbAdHAD54H30aaA58mL88uAaeyVyrvpiuxHUG11PslO6W+CFoNjdMz4nu9u56ficlI3BrUfe7PzwGQfaoP/V6RJx+nyEXxMgaov/qkR+Tof/Z/g1xs/cgbRNgZwd/UrFQV8iHbwYFDq7z9G/qaSWWtN3hW+PytiX4qtTI4b8jbPTHGl1OdIRV2NKmBP75/hqfIc830ov1iDFqi/qSeIylwx5D4kmgYeQPwVmIHAdmT1AV+SjbqCWFzD5LGxDsc30YhWg0xc4DH2G6yc7usdADN3rnr+OxYlgGJiKzSyY9X8K3Q3gEfTHpSNnHu0h4CbQAf0+L1YJuqlgDPp5oEI2uI589/VN8/z3oX8eKPdk/A46G23VQwu8xNPdZ3WbnI4+Oo6nA+VcAPza9UQ/UHrP/0N0g8GVoN4ovsAk151zl5+JSWW6AaFXATriZxZYeuTZ6NoDmsZWZPW6X+4APk10sYi7BkN7+u+y/sqt4vo03vPXkSnqQp9j0hNjU7XK/KahNwsM57qMXxfGiG6+i4U8B2VTeJ7NfYr2CON4+udRxbH2bNQ6Qb5wMWiftcDodP04akb/7V78m61hihfDnYquT1KcuClTPj1/9nvzqel4MUTgPgiMr5qwFVPJmbQOAhWpB0XQK1efqO68XyR79BV6nQT6GtJh/UEntaEdYJWRTv9k4n9ITevfGdG/Q1Gf0ZarSO+BFUayP4xzkWsTszfydaCr1RXAv7WyY8sQim3jWrjeHppjQiKmbGs94wl0rr/UGqvIH78vV1uT+E15gRmQCnMikqPItbG3Rvbj60g67uxw/6jR5KIFkb9ZYLhetlows2GIrU2ir94n+aqPqBloBXD9TzqMR2nEq5iObjwtsbUH5h1gc/vzUFf1VxyRxqq515RbNreIiEb229LVCfkLUKuAjKYtHdzjx/Sl+u1cEOz6U0fHnyNNwJ+E7I7ULzoWFVYQnQS690w8gmhzNAU+taChwoq0+GXAzyd9ItJG0IbwSXNz49Hi6WTQfayAyh3118PK5dZYtdmSyY1b/ZKbRCpZ0unkHiCmP9syfjexElko3VeQKP42/A/IQCV6wW6JOA1Fb4qG305s64AWWaTcA4x0+mcI/vrSRPlAp4n54uE1ka6JO30HijKCWPwzP1theWCP2lA3cLuR7A9JBiMqjqgA7GXMyeQ2HZL8MRssSd+4W8oLzOz18FhApCfA3cjvwEcBnU06wjJB9CuT2dFehC/VIJYeGQsQHwS3gqdpvwY3RLxPEPaDJVLg3wT7B4gPA/mPpz0bbojN9TGCCmIWqVqb+BcH89+ZWJ8FetnPgj8pb/JWEWspok6ERdLh3xifdxHHAuUeh98cxUHWEbMQpkcgbv+b4h8Iu6Uf0W4DbWzULvAOVq4z5r+iDzID8zcuyeP/1ysZ/XSbUX8Hn7C6AnQ6Dn3qTFU2RPv7bewqsDsS02iv8+1RGfty/N3R3oP85fJBn4PePVT8V7T+w6I0Gkdt9PPoQ1dD7RBq/Jsd+w94mlMH2f+LYqQioMt2eWj2kc5SI2wbPZs7zUY6neP46+RKB6+CSUDXyTmJOaRG7NpsdusD8BxwClSB3Wy5yegzbNRydBtoZ8E3o0M8g/agHwreAgXAHENw9fuTWFPg+krdY24/7WHgDbAT6EvRl6b/Z96G/zT4/ah0b4ri+ZGzAeazqJBBjQLrMVYAzaMIzEQ3wetzCN09YBbYAfzcebRnAF1R5m3BguXSP0tApztcn7RqJt0GmmXSOcI/x9o2oXPjX0HMuUDxdezvxqbTEdFwppxwTqiribi1In3BWXRqzmB+J0t/eutr6QmagO3gAPCJzRcnDehcpIdWd6AHyxGQD84oAm2ftHOvAXpcqaj5wBUGMU6J8usLzmYeacwhj7n0wlt+4sq/ExSBc5GOSeXW3PWgkr9ZWLgjfTykMEQKsxD+WJzOupgjPervbJqjTjHVT/nErwK6OkpAnVH8iGYk6+os6vkP5B/RuaRXARskaZfVltwuc7y2/S8Ufzd+xy+UcdXpONyjI9mgnGixMn7E3b2YbN8Lyc/NQ/eZ0GCptrtX92w3oC9fC6xL/2Ik3YW678X1WNoFtOiBQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgVCBUIFQgUuoQr8C4/kmRLXPZUVAAAAAElFTkSuQmCC
name: Proofpoint TAP v2
script:
  commands:
  - arguments:
    - description: 'A string containing an ISO8601-formatted interval. If this interval
        overlaps with previous requests for data, records from the previous request
        might be duplicated. The minimum interval is thirty seconds. The maximum interval
        is one hour. Examples:  2016-05-01T12:00:00Z/2016-05-01T13:00:00Z - an hour
        interval, beginning at noon UTC on 05-01-2016 PT30M/2016-05-01T12:30:00Z -
        the thirty minutes beginning at noon UTC on 05-01-2016 and ending at 12:30pm
        UTC 2016-05-01T05:00:00-0700/PT30M - the same interval as above, but using
        -0700 as the time zone'
      name: interval
    - auto: PREDEFINED
      description: 'A string specifying which threat type to return. If empty, all
        threat types are returned. The following values are accepted: url,attachment,
        messageText'
      name: threatType
      predefined:
      - url
      - attachment
      - messageText
    - auto: PREDEFINED
      description: A string specifying which threat statuses to return. If empty,
        active and cleared threats are returned. Can be "active", "cleared", "falsePositive".
      name: threatStatus
      predefined:
      - active
      - cleared
      - falsePositive
    - description: 'A string containing an ISO8601 date. It represents the start of
        the data retrieval period. The end of the period is determined by the current
        API server time rounded to the nearest minute. If JSON output is selected,
        the end time is included in the returned result. Example: 2016-05-01T12:00:00Z'
      name: sinceTime
    - description: An integer representing a time window (in seconds) from the current
        API server time. The start of the window is the current API server time, rounded
        to the nearest minute, less the number of seconds provided. The end of the
        window is the current API server time rounded to the nearest minute. If JSON
        output is selected, the end time is included in the returned result.
      name: sinceSeconds
    - auto: PREDEFINED
      defaultValue: All
      description: Event types to return.
      name: eventTypes
      predefined:
      - All
      - Issues
      - Delivered Messages
      - Blocked Messages
      - Permitted Clicks
      - Blocked Clicks
    description: Fetches events for all clicks and messages relating to known threats
      within the specified time period. Details as per clicks/blocked.
    name: proofpoint-get-events
    outputs:
    - contextPath: Proofpoint.MessagesDelivered.GUID
      description: The ID of the message within PPS. It can be used to identify the
        message in PPS, which is unique.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.QID
      description: The queue ID of the message within PPS. It can be used to identify
        the message in PPS, which is not unique.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.ccAddresses
      description: 'A list of email addresses contained within the CC: header, excluding,
        and friendly names.'
      type: String
    - contextPath: Proofpoint.MessagesDelivered.clusterId
      description: The name of the PPS cluster which processed the message.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.fromAddress
      description: 'The email address contained in the From: header, excluding friendly,
        and name.'
      type: String
    - contextPath: Proofpoint.MessagesDelivered.headerCC
      description: The CC header.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.headerFrom
      description: 'The full content of the From: header, including any friendly name.'
      type: String
    - contextPath: Proofpoint.MessagesDelivered.headerReplyTo
      description: 'If present, the full content of the Reply-To: header, including
        any friendly names.'
      type: String
    - contextPath: Proofpoint.MessagesDelivered.impostorScore
      description: The impostor score of the message. Higher scores indicate higher
        certainty.
      type: Number
    - contextPath: Proofpoint.MessagesDelivered.malwareScore
      description: The malware score of the message. Higher scores indicate higher
        certainty.
      type: Number
    - contextPath: Proofpoint.MessagesDelivered.messageId
      description: Message-ID extracted from the headers of the email message. It
        can be used to look up the associated message in PPS, which is not unique.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.threatsInfoMap.threat
      description: The artifact which was condemned by Proofpoint. The malicious URL,
        hash of the attachment threat, or email address of the impostor sender.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.threatsInfoMap.threatId
      description: The unique identifier associated with this threat. It can be used
        to query the forensics and campaign endpoints.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.threatsInfoMap.threatStatus
      description: The current state of the threat (active, expired, false-positive,
        cleared).
      type: String
    - contextPath: Proofpoint.MessagesDelivered.threatsInfoMap.threatTime
      description: Proofpoint assigned the threatStatus at this time (ISO8601 format).
      type: Date
    - contextPath: Proofpoint.MessagesDelivered.threatsInfoMap.threatType
      description: Whether the threat was an attachment, URL, or message type.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.threatsInfoMap.threatUrl
      description: A link to the entry about the threat on the TAP Dashboard.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.messageTime
      description: When the message was delivered to the user or quarantined by PPS.
      type: Date
    - contextPath: Proofpoint.MessagesDelivered.messageTime
      description: The list of PPS modules which processed the message.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.modulesRun
      description: The list of PPS modules which processed the message.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.phishScore
      description: The phishing score of the message. Higher scores indicate higher
        certainty.
      type: Number
    - contextPath: Proofpoint.MessagesDelivered.policyRoutes
      description: The policy routes that the message matched during processing by
        PPS.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.quarantineFolder
      description: The name of the folder which contains the quarantined message.
        This appears only for messagesBlocked.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.quarantineRule
      description: The name of the rule which quarantined the message. This appears
        only for messagesBlocked events.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.recipient
      description: A list containing the email addresses of the recipients.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.replyToAddress
      description: 'The email address contained in the Reply-To: header, excluding
        friendly name.'
      type: String
    - contextPath: Proofpoint.MessagesDelivered.sender
      description: The email address of the SMTP (envelope) sender. The user-part
        is hashed. The domain-part is cleartext.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.senderIP
      description: The IP address of the sender.
      type: String
    - contextPath: Proofpoint.MessagesDelivered.spamScore
      description: The spam score of the message. Higher scores indicate higher certainty.
      type: Number
    - contextPath: Proofpoint.MessagesDelivered.subject
      description: The subject line of the message, if available.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.GUID
      description: The ID of the message within PPS. It can be used to identify the
        message in PPS, which is unique.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.QID
      description: The queue ID of the message within PPS. It can be used to identify
        the message in PPS, which is not unique.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.ccAddresses
      description: 'A list of email addresses contained within the CC: header, excluding
        friendly names.'
      type: String
    - contextPath: Proofpoint.MessagesBlocked.clusterId
      description: The name of the PPS cluster which processed the message.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.fromAddress
      description: 'The email address contained in the From: header, excluding friendly
        name.'
      type: String
    - contextPath: Proofpoint.MessagesBlocked.headerCC
      description: The CCheader.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.headerFrom
      description: 'The full content of the From: header, including any friendly name.'
      type: String
    - contextPath: Proofpoint.MessagesBlocked.headerReplyTo
      description: 'If present, the full content of the Reply-To: header, including
        any friendly names.'
      type: String
    - contextPath: Proofpoint.MessagesBlocked.impostorScore
      description: The impostor score of the message. Higher scores indicate higher
        certainty.
      type: Number
    - contextPath: Proofpoint.MessagesBlocked.malwareScore
      description: The malware score of the message. Higher scores indicate higher
        certainty.
      type: Number
    - contextPath: Proofpoint.MessagesBlocked.messageId
      description: Message-ID extracted from the headers of the email message. It
        can be used to look up the associated message in PPS, which is not unique.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.threatsInfoMap.threat
      description: The artifact which was condemned by Proofpoint. The malicious URL,
        hash of the attachment threat, or email address of the impostor sender.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.threatsInfoMap.threatId
      description: The unique identifier associated with this threat. It can be used
        to query the forensics and campaign endpoints.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.threatsInfoMap.threatStatus
      description: The current state of the threat (active, expired, false-positive,
        cleared).
      type: String
    - contextPath: Proofpoint.MessagesBlocked.threatsInfoMap.threatTime
      description: Proofpoint assigned the threatStatus at this time (ISO8601 format).
      type: Date
    - contextPath: Proofpoint.MessagesBlocked.threatsInfoMap.threatType
      description: Whether the threat was an attachment, URL, or message type.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.threatsInfoMap.threatUrl
      description: A link to the entry about the threat on the TAP Dashboard.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.messageTime
      description: When the message was blocked to the user or quarantined by PPS.
      type: Date
    - contextPath: Proofpoint.MessagesBlocked.messageTime
      description: The list of PPS modules which processed the message.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.modulesRun
      description: The list of PPS modules which processed the message.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.phishScore
      description: The phishing score of the message. Higher scores indicate higher
        certainty.
      type: Number
    - contextPath: Proofpoint.MessagesBlocked.policyRoutes
      description: The policy routes that the message matched during processing by
        PPS.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.quarantineFolder
      description: The name of the folder which contains the quarantined message.
        This appears only for messagesBlocked.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.quarantineRule
      description: The name of the rule which quarantined the message. This appears
        only for messagesBlocked events.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.recipient
      description: A list containing the email addresses of the recipients.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.replyToAddress
      description: 'The email address contained in the Reply-To: header, excluding
        friendly name.'
      type: String
    - contextPath: Proofpoint.MessagesBlocked.sender
      description: The email address of the SMTP (envelope) sender. The user-part
        is hashed. The domain-part is cleartext.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.senderIP
      description: The IP address of the sender.
      type: String
    - contextPath: Proofpoint.MessagesBlocked.spamScore
      description: The spam score of the message. Higher scores indicate higher certainty.
      type: Number
    - contextPath: Proofpoint.MessagesBlocked.subject
      description: The subject line of the message, if available.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.GUID
      description: The ID of the message within PPS. It can be used to identify the
        message in PPS, which is unique.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.campaignId
      description: An identifier for the campaign of which the threat is a member,
        if available at the time of the query. Threats can be linked to campaigns
        even after these events are retrieved.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.classification
      description: The threat category of the malicious URL.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.clickIP
      description: The external IP address of the user who clicked on the link. If
        the user is behind a firewall performing network address translation, the
        IP address of the firewall will be shown.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.clickTime
      description: The time the user clicked on the URL.
      type: Date
    - contextPath: Proofpoint.ClicksPermitted.messageID
      description: The Message-ID extracted from the headers of the email message.
        It can be used to look up the associated message in PPS and is not unique.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.recipient
      description: The email address of the recipient.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.sender
      description: The email address of the sender. The user-part is hashed. The domain-part
        is cleartext.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.senderIP
      description: The IP address of the sender.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.threatID
      description: 'The unique identifier associated with this threat. It can be used
        to query the forensics and campaign endpoints. '
      type: String
    - contextPath: Proofpoint.ClicksPermitted.threatTime
      description: Proofpoint identified the URL as a threat at this time.
      type: Date
    - contextPath: Proofpoint.ClicksPermitted.threatURL
      description: A link to the entry on the TAP Dashboard for the particular threat.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.url
      description: The malicious URL which was clicked.
      type: String
    - contextPath: Proofpoint.ClicksPermitted.userAgent
      description: The User-Agent header from the clicker's HTTP request.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.GUID
      description: The ID of the message within PPS. It can be used to identify the
        message in PPS and is guaranteed to be unique.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.campaignId
      description: An identifier for the campaign of which the threat is a member,
        if available at the time of the query. Threats can be linked to campaigns
        even after these events are retrieved.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.classification
      description: The threat category of the malicious URL.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.clickIP
      description: The external IP address of the user who clicked on the link. If
        the user is behind a firewall performing network address translation, the
        IP address of the firewall will be shown.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.clickTime
      description: The time the user clicked on the URL
      type: Date
    - contextPath: Proofpoint.ClicksBlocked.messageID
      description: Message-ID extracted from the headers of the email message. It
        can be used to look up the associated message in PPS and is not unique.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.recipient
      description: The email address of the recipient.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.sender
      description: The email address of the sender. The user-part is hashed. The domain-part
        is cleartext.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.senderIP
      description: The IP address of the sender.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.threatID
      description: 'The unique identifier associated with this threat. It can be used
        to query the forensics and campaign endpoints. '
      type: String
    - contextPath: Proofpoint.ClicksBlocked.threatTime
      description: Proofpoint identified the URL as a threat at this time.
      type: Date
    - contextPath: Proofpoint.ClicksBlocked.threatURL
      description: A link to the entry on the TAP Dashboard for the particular threat.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.url
      description: The malicious URL which was clicked.
      type: String
    - contextPath: Proofpoint.ClicksBlocked.userAgent
      description: The User-Agent header from the clicker's HTTP request.
      type: String
  - arguments:
    - description: The ID of the threat (use with either threadId or campaignId).
      name: threatId
    - description: ID of the campaign (use with either threadId or campaignId).
      name: campaignId
    - defaultValue: "false"
      description: Whether to include forensic evidence for the whole campaign. Can
        be used with threatId only.
      name: includeCampaignForensics
    description: Returns forensics evidence.
    name: proofpoint-get-forensics
    outputs:
    - contextPath: Proofpoint.Report.ID
      description: The ID of the report.
      type: String
    - contextPath: Proofpoint.Report.Type
      description: 'The threat type. Can be: "attachment", "url", or "hybrid".'
      type: String
    - contextPath: Proofpoint.Report.Scope
      description: Whether the report scope covers a campaign or an individual threat.
      type: String
    - contextPath: Proofpoint.Report.Attachment.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.Attachment.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.Attachment.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.Attachment.SHA256
      description: The SHA256 hash of the attachment's contents.
      type: String
    - contextPath: Proofpoint.Report.Attachment.MD5
      description: The MD5 hash of the attachment's contents.
      type: String
    - contextPath: Proofpoint.Report.Attachment.Blacklisted
      description: Optional. Whether the file was blacklisted.
      type: Number
    - contextPath: Proofpoint.Report.Attachment.Offset
      description: Optional. The offset in bytes where the malicious content was found.
      type: Number
    - contextPath: Proofpoint.Report.Attachment.Size
      description: Optional. The size in bytes of the attachment's contents.
      type: Number
    - contextPath: Proofpoint.Report.Attachment.Platform.Name
      description: The name of the platform.
      type: String
    - contextPath: Proofpoint.Report.Attachment.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.Attachment.Platform.Version
      description: The version of the platform.
      type: String
    - contextPath: Proofpoint.Report.Cookie.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.Cookie.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.Cookie.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.Cookie.Action
      description: Whether the cookie was set or deleted.
      type: String
    - contextPath: Proofpoint.Report.Cookie.Domain
      description: Which domain set the cookie.
      type: String
    - contextPath: Proofpoint.Report.Cookie.Key
      description: The name of the cookie being set or deleted.
      type: String
    - contextPath: Proofpoint.Report.Cookie.Value
      description: Optional. The content of the cookie being set.
      type: String
    - contextPath: Proofpoint.Report.Cookie.Platform.Name
      description: Name of the platform.
      type: String
    - contextPath: Proofpoint.Report.Cookie.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.Cookie.Platform.Version
      description: The version of the platform.
      type: String
    - contextPath: Proofpoint.Report.DNS.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.DNS.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.DNS.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.DNS.Host
      description: The hostname being resolved.
      type: String
    - contextPath: Proofpoint.Report.DNS.CNames
      description: Optional. An array of CNames, which were associated with the hostname.
      type: String
    - contextPath: Proofpoint.Report.DNS.IP
      description: Optional. An array of IP addresses which were resolved to the hostname.
      type: String
    - contextPath: Proofpoint.Report.DNS.NameServers
      description: Optional. The nameservers responsible for the hostname's domain.
      type: String
    - contextPath: Proofpoint.Report.DNS.NameServersList
      description: Optional. The nameservers responsible for the hostnames.
      type: String
    - contextPath: Proofpoint.Report.DNS.Platform.Name
      description: The name of the platform.
      type: String
    - contextPath: Proofpoint.Report.DNS.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.DNS.Platform.Version
      description: The version of the platform.
      type: String
    - contextPath: Proofpoint.Report.Dropper.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.Dropper.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.Dropper.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.Dropper.Path
      description: The location of the dropper file.
      type: String
    - contextPath: Proofpoint.Report.Dropper.URL
      description: Optional. The name of the static rule inside the sandbox which
        identified the dropper.
      type: String
    - contextPath: Proofpoint.Report.Dropper.Rule
      description: Optional. The URL the dropper contacted.
      type: String
    - contextPath: Proofpoint.Report.Dropper.Platform.Name
      description: The name of the platform.
      type: String
    - contextPath: Proofpoint.Report.Dropper.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.Dropper.Platform.Version
      description: The version of the platform.
      type: String
    - contextPath: Proofpoint.Report.File.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.File.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.File.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.File.Path
      description: Optional. The location of the file operated on.
      type: String
    - contextPath: Proofpoint.Report.File.Action
      description: Optional. The filesystem call made create (modify, or delete).
      type: String
    - contextPath: Proofpoint.Report.File.Rule
      description: Optional. The name of the static rule inside the sandbox which
        identified the suspicious file.
      type: String
    - contextPath: Proofpoint.Report.File.SHA256
      description: Optional. The SH256 sum of the file's contents.
      type: Unknown
    - contextPath: Proofpoint.Report.File.MD5
      description: Optional. The MD5 sum of the file's contents.
      type: String
    - contextPath: Proofpoint.Report.File.Size
      description: Optional. The size in bytes of the file's contents.
      type: Number
    - contextPath: Proofpoint.Report.File.Platform.Name
      description: The name of the platform.
      type: String
    - contextPath: Proofpoint.Report.File.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.File.Platform.Version
      description: The version of the platform.
      type: String
    - contextPath: Proofpoint.Report.IDS.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.IDS.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.IDS.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.IDS.Name
      description: The friendly name of the IDS rule which observed the malicious
        traffic.
      type: String
    - contextPath: Proofpoint.Report.IDS.SignatureID
      description: The identifier of the IDS rule which observed the malicious traffic.
      type: String
    - contextPath: Proofpoint.Report.IDS.Platform.Name
      description: The name of the platform.
      type: String
    - contextPath: Proofpoint.Report.IDS.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.IDS.Platform.Version
      description: The version of the platform.
      type: String
    - contextPath: Proofpoint.Report.Mutex.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.Mutex.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.Mutex.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.Mutex.Name
      description: The name of the mutex.
      type: String
    - contextPath: Proofpoint.Report.Mutex.Path
      description: Optional. The path to the process which spawned the mutex.
      type: String
    - contextPath: Proofpoint.Report.Mutex.Platform.Name
      description: The name of the platform.
      type: String
    - contextPath: Proofpoint.Report.Mutex.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.Mutex.Platform.Version
      description: The version of the platform.
      type: String
    - contextPath: Proofpoint.Report.Network.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.Network.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.Network.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.Network.Action
      description: The type of network activity being initiated (connect or listen).
      type: String
    - contextPath: Proofpoint.Report.Network.IP
      description: The remote IP address being contacted.
      type: String
    - contextPath: Proofpoint.Report.Network.Port
      description: The remote IP Port being contacted.
      type: String
    - contextPath: Proofpoint.Report.Network.Type
      description: The protocol being used (tcp or udp).
      type: String
    - contextPath: Proofpoint.Report.Network.Platform.Name
      description: The name of the platform.
      type: String
    - contextPath: Proofpoint.Report.Network.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.Network.Platform.Version
      description: The version of the platform.
      type: String
    - contextPath: Proofpoint.Report.Process.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.Process.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.Process.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.Process.Action
      description: The action performed on the process. Relevant when create is produced.
      type: String
    - contextPath: Proofpoint.Report.Process.Path
      description: The location of the executable which spawned the process.
      type: String
    - contextPath: Proofpoint.Report.Process.Platform.Name
      description: The name of the platform.
      type: String
    - contextPath: Proofpoint.Report.Process.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.Process.Platform.Version
      description: The version of the platform.
      type: String
    - contextPath: Proofpoint.Report.Registry.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.Registry.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.Registry.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.Registry.Name
      description: Optional. The name of the registry entry being created or set.
      type: String
    - contextPath: Proofpoint.Report.Registry.Action
      description: The registry change made (create or set).
      type: String
    - contextPath: Proofpoint.Report.Registry.Key
      description: The location of the registry key being modified.
      type: String
    - contextPath: Proofpoint.Report.Registry.Value
      description: Optional. The contents of the key being created or set.
      type: String
    - contextPath: Proofpoint.Report.Registry.Platform.Name
      description: The name of the platform.
      type: String
    - contextPath: Proofpoint.Report.Registry.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.Registry.Platform.Version
      description: The version of the platform.
      type: String
    - contextPath: Proofpoint.Report.URL.Time
      description: The relative time at which the evidence was observed during sandboxing.
      type: Date
    - contextPath: Proofpoint.Report.URL.Malicious
      description: Whether the evidence was used to reach a malicious verdict.
      type: String
    - contextPath: Proofpoint.Report.URL.Display
      description: A friendly display string.
      type: String
    - contextPath: Proofpoint.Report.URL.URL
      description: The URL which was observed.
      type: String
    - contextPath: Proofpoint.Report.URL.Blacklisted
      description: Optional. Whether the URL was listed on a blacklist.
      type: Boolean
    - contextPath: Proofpoint.Report.URL.SHA256
      description: Optional. The sha256 value of the file downloaded from the URL.
      type: String
    - contextPath: Proofpoint.Report.URL.MD5
      description: Optional. The md5 value of the file downloaded from the URL.
      type: String
    - contextPath: Proofpoint.Report.URL.Size
      description: Optional. The size in bytes of the file retrieved from the URL.
      type: Number
    - contextPath: Proofpoint.Report.URL.HTTPStatus
      description: Optional. The HTTP status code which was produced when our sandbox
        visited the URL.
      type: Number
    - contextPath: Proofpoint.Report.URL.IP
      description: Optional. The IP address that was resolved to the hostname by the
        sandbox.
      type: String
    - contextPath: Proofpoint.Report.URL.Platform.Name
      description: The name of the platform.
      type: String
    - contextPath: Proofpoint.Report.URL.Platform.OS
      description: The OS of the platform.
      type: String
    - contextPath: Proofpoint.Report.URL.Platform.Version
      description: The version of the platform.
      type: String
  dockerimage: demisto/python3:3.7.4.977
  isfetch: true
  runonce: false
  script: |2



    ''' IMPORTS '''
    from typing import Dict, Tuple
    from datetime import datetime, timedelta
    import json
    import requests
    import urllib3

    # Disable insecure warnings
    urllib3.disable_warnings()

    ALL_EVENTS = "All"
    ISSUES_EVENTS = "Issues"
    BLOCKED_CLICKS = "Blocked Clicks"
    PERMITTED_CLICKS = "Permitted Clicks"
    BLOCKED_MESSAGES = "Blocked Messages"
    DELIVERED_MESSAGES = "Delivered Messages"

    DEFAULT_LIMIT = 50
    DATE_FORMAT = "%Y-%m-%dT%H:%M:%SZ"


    """ Helper functions """


    def get_now():
        """ A wrapper function of datetime.now
        helps handle tests

        Returns:
            datetime: time right now
        """
        return datetime.now()


    def get_fetch_times(last_fetch):
        """ Get list of every hour since last_fetch. last is now.
        Args:
            last_fetch (datetime or str): last_fetch time

        Returns:
            List[str]: list of str represents every hour since last_fetch
        """
        now = get_now()
        times = list()
        time_format = "%Y-%m-%dT%H:%M:%SZ"
        if isinstance(last_fetch, str):
            times.append(last_fetch)
            last_fetch = datetime.strptime(last_fetch, time_format)
        elif isinstance(last_fetch, datetime):
            times.append(last_fetch.strftime(time_format))
        while now - last_fetch > timedelta(minutes=59):
            last_fetch += timedelta(minutes=59)
            times.append(last_fetch.strftime(time_format))
        times.append(now.strftime(time_format))
        return times


    class Client:
        def __init__(self, proofpoint_url, api_version, verify, service_principal, secret, proxies):
            self.base_url = proofpoint_url
            self.api_version = api_version
            self.verify = verify
            self.service_principal = service_principal
            self.secret = secret
            self.proxies = proxies

        def http_request(self, method, url_suffix, params=None, data=None, forensics_api=False):
            if forensics_api:
                full_url = urljoin(self.base_url, '/v2/forensics')
            else:
                full_url = urljoin(urljoin(self.base_url, self.api_version), url_suffix)

            res = requests.request(
                method,
                full_url,
                verify=self.verify,
                params=params,
                json=data,
                auth=(self.service_principal, self.secret),
                proxies=self.proxies
            )

            if res.status_code not in [200, 204]:
                raise ValueError(f'Error in API call to Proofpoint TAP {res.status_code}. Reason: {res.text}')

            try:
                return res.json()
            except Exception:
                raise ValueError(f"Failed to parse http response to JSON format. Original response body: \n{res.text}")

        def get_events(self, interval=None, since_time=None, since_seconds=None, threat_type=None, threat_status=None,
                       event_type_filter="All"):

            if not interval and not since_time and not since_seconds:
                raise ValueError("Required to pass interval or sinceTime or sinceSeconds.")

            query_params = {
                "format": "json"
            }
            query_params.update(
                assign_params(
                    interval=interval,
                    sinceTime=since_time,
                    sinceSeconds=since_seconds,
                    threatStatus=threat_status,
                    threatType=threat_type
                )
            )

            url_route = {
                "All": "/all",
                "Issues": "/issues",
                "Blocked Clicks": "/clicks/blocked",
                "Permitted Clicks": "/clicks/permitted",
                "Blocked Messages": "/messages/blocked",
                "Delivered Messages": "/messages/delivered"
            }[event_type_filter]

            events = self.http_request("GET", urljoin('siem', url_route), params=query_params)

            return events

        def get_forensics(self, threat_id=None, campaign_id=None, include_campaign_forensics=None):
            if threat_id and campaign_id:
                raise DemistoException('threadId and campaignID supplied, supply only one of them')
            if include_campaign_forensics and campaign_id:
                raise DemistoException('includeCampaignForensics can be true only with threadId')
            params = assign_params(
                threatId=threat_id,
                campaingId=campaign_id,
                includeCampaignForensics=include_campaign_forensics)
            return self.http_request('GET', None, params=params, forensics_api=True)


    def test_module(client, first_fetch_time, event_type_filter):
        """
        Performs basic get request to get item samples
        """
        since_time, _ = parse_date_range(first_fetch_time, date_format=DATE_FORMAT, utc=True)
        client.get_events(since_time=since_time, event_type_filter=event_type_filter)

        # test was successful
        return 'ok'


    def build_context_attachment(what: dict) -> Dict:
        return assign_params(
            SHA256=what.get('sha256'),
            MD5=what.get('md5'),
            Blacklisted=what.get('blacklisted'),
            Offset=what.get('offset'),
            Size=what.get('size'),
        )


    def build_context_cookie(what: dict) -> dict:
        return assign_params(
            Action=what.get('action'),
            Domain=what.get('domain'),
            Key=what.get('key'),
            Value=what.get('value'),
        )


    def build_context_dns(what: dict) -> dict:
        return assign_params(
            Host=what.get('host'),
            CNames=what.get('cnames'),
            IP=what.get('ips'),
            NameServers=what.get('nameservers'),
            NameServersList=what.get('nameserversList'),
        )


    def build_context_mutex(what: dict) -> dict:
        return assign_params(
            Name=what.get('name'),
            Path=what.get('path')
        )


    def build_context_ids(what: dict) -> dict:
        return assign_params(
            Name=what.get('name'),
            SignatureID=what.get('signatureId')
        )


    def build_context_network(what: dict) -> dict:
        return assign_params(
            Action=what.get('action'),
            IP=what.get('ip'),
            Port=what.get('port'),
            Protocol=what.get('type')
        )


    def build_context_process(what: dict) -> dict:
        return assign_params(
            Action=what.get('action'),
            Path=what.get('path'),
        )


    def build_context_dropper(what: dict) -> dict:
        return assign_params(
            Path=what.get('path'),
            URL=what.get('url'),
            Rule=what.get('rule'),
        )


    def build_context_registry(what: dict) -> dict:
        return assign_params(
            Name=what.get('name'),
            Action=what.get('action'),
            Key=what.get('key'),
            Value=what.get('value'),
        )


    def build_context_file(what: dict) -> dict:
        return assign_params(
            Path=what.get('path'),
            Action=what.get('action'),
            SHA256=what.get('sha256'),
            MD5=what.get('md5'),
            Size=what.get('size'),
        )


    def build_context_url(what: dict) -> dict:
        return assign_params(
            URL=what.get('url'),
            Blacklisted=what.get('blacklisted'),
            SHA256=what.get('sha256'),
            MD5=what.get('md5'),
            Size=what.get('size'),
            HTTPStatus=what.get('httpStatus'),
            IP=what.get('ip'),
        )


    def get_forensic_command(client: Client, args: Dict) -> Tuple[str, dict, dict]:
        """
        Args:
            client:
            args: demisto.args()
        Returns:
            Outputs
        """
        forensic_types = {
            'attachment': 'Attachment',
            'cookie': 'Cookie',
            'dns': 'DNS',
            'dropper': 'Dropper',
            'file': 'File',
            'ids': 'IDS',
            'mutex': 'Mutex',
            'network': 'Network',
            'process': 'Process',
            'registry': 'Registry',
            'url': 'URL'
        }
        threat_id = args.get('threatId')
        campaign_id = args.get('campaignId')
        include_campaign_forensics = args.get('includeCampaignForensics') == 'true'
        limit = args.get('limit', DEFAULT_LIMIT)
        raw_response = client.get_forensics(
            threat_id=threat_id,
            campaign_id=campaign_id,
            include_campaign_forensics=include_campaign_forensics
        )
        reports = raw_response.get('reports', [])
        if len(reports) > limit:
            reports = reports[:limit]
        reports_context = list()
        for report in reports:
            report_context = assign_params(
                Scope=report.get('scope'),
                Type=report.get('type'),
                ID=report.get('id')
            )
            for evidence in report.get('forensics', []):
                evidence_type = evidence.get('type')
                evidence_type = forensic_types.get(evidence_type)
                if evidence_type:
                    # Create list in report
                    if evidence_type not in report_context:
                        report_context[evidence_type] = list()
                    what = evidence.get('what', {})
                    basic_report = assign_params(
                        Time=evidence.get('time'),
                        Display=evidence.get('display'),
                        Malicious=evidence.get('malicious'),
                    )
                    basic_report['Platform'] = [{
                        'Name': platform.get('name'),
                        'OS': platform.get('os'),
                        'Version': platform.get('version')
                    } for platform in evidence.get('platforms', [])]

                    if evidence_type == 'Attachment':
                        basic_report.update(build_context_attachment(what))
                        report_context[evidence_type].append(basic_report)
                    elif evidence_type == 'Cookie':
                        basic_report.update(build_context_cookie(what))
                        report_context[evidence_type].append(basic_report)
                    elif evidence_type == 'DNS':
                        basic_report.update(build_context_dns(what))
                        report_context['DNS'].append(basic_report)
                    elif evidence_type == 'Dropper':
                        basic_report.update(build_context_dropper(what))
                        report_context['Dropper'].append(basic_report)
                    elif evidence_type == 'File':
                        basic_report.update(build_context_file(what))
                        report_context['File'].append(basic_report)
                    elif evidence_type == 'IDS':
                        basic_report.update(build_context_ids(what))
                        report_context['IDS'].append(basic_report)
                    elif evidence_type == 'Mutex':
                        basic_report.update(build_context_mutex(what))
                        report_context['Mutex'].append(basic_report)
                    elif evidence_type == 'Network':
                        basic_report.update(build_context_network(what))
                        report_context['Network'].append(basic_report)
                    elif evidence_type == 'Process':
                        basic_report.update(build_context_process(what))
                        report_context['Process'].append(basic_report)
                    elif evidence_type == 'Registry':
                        basic_report.update(build_context_registry(what))
                        report_context['Registry'].append(basic_report)
                    elif evidence_type == 'URL':
                        basic_report.update(build_context_url(what))
                        report_context['URL'].append(basic_report)
            reports_context.append(report_context)
        outputs = {'Proofpoint.Report(var.ID === obj.ID)': reports_context}
        readable_outputs = tableToMarkdown(
            f'Forensic results from ProofPoint for ID: {threat_id or campaign_id}',
            reports_context,
            headers=['ID', 'Scope', 'Type']
        )
        return readable_outputs, outputs, raw_response


    @logger
    def get_events_command(client, args):
        interval = args.get("interval")
        threat_type = argToList(args.get("threatType"))
        threat_status = args.get("threatStatus")
        since_time = args.get("sinceTime")
        since_seconds = int(args.get("sinceSeconds")) if args.get("sinceSeconds") else None
        event_type_filter = args.get("eventTypes")

        raw_events = client.get_events(interval, since_time, since_seconds, threat_type, threat_status, event_type_filter)

        return (
            tableToMarkdown("Proofpoint Events", raw_events),
            {
                'Proofpoint.MessagesDelivered(val.GUID == obj.GUID)': raw_events.get("messagesDelivered"),
                'Proofpoint.MessagesBlocked(val.GUID == obj.GUID)': raw_events.get("messagesBlocked"),
                'Proofpoint.ClicksBlocked(val.GUID == obj.GUID)': raw_events.get("clicksBlocked"),
                'Proofpoint.ClicksPermitted(val.GUID == obj.GUID)': raw_events.get("clicksPermitted")
            },
            raw_events
        )


    def fetch_incidents(client, last_run, first_fetch_time, event_type_filter, threat_type, threat_status,
                        limit=DEFAULT_LIMIT, integration_context=None):
        incidents: list = []
        end_query_time = ''
        # check if there're incidents saved in context
        if integration_context:
            remained_incidents = integration_context.get("incidents")
            # return incidents if exists in context.
            if remained_incidents:
                return last_run, remained_incidents[:limit], remained_incidents[limit:]
        # Get the last fetch time, if exists
        start_query_time = last_run.get("last_fetch")
        # Handle first time fetch, fetch incidents retroactively
        if not start_query_time:
            start_query_time, _ = parse_date_range(first_fetch_time, date_format=DATE_FORMAT, utc=True)
        fetch_times = get_fetch_times(start_query_time)
        for i in range(len(fetch_times) - 1):
            start_query_time = fetch_times[i]
            end_query_time = fetch_times[i + 1]
            raw_events = client.get_events(interval=start_query_time + "/" + end_query_time,
                                           event_type_filter=event_type_filter,
                                           threat_status=threat_status, threat_type=threat_type)

            message_delivered = raw_events.get("messagesDelivered", [])
            for raw_event in message_delivered:
                raw_event["type"] = "messages delivered"
                event_guid = raw_event.get("GUID", "")
                incident = {
                    "name": "Proofpoint - Message Delivered - {}".format(event_guid),
                    "rawJSON": json.dumps(raw_event),
                    "occurred": raw_event["messageTime"]
                }
                incidents.append(incident)

            message_blocked = raw_events.get("messagesBlocked", [])
            for raw_event in message_blocked:
                raw_event["type"] = "messages blocked"
                event_guid = raw_event.get("GUID", "")
                incident = {
                    "name": "Proofpoint - Message Blocked - {}".format(event_guid),
                    "rawJSON": json.dumps(raw_event),
                    "occured": raw_event["messageTime"],
                }
                incidents.append(incident)

            clicks_permitted = raw_events.get("clicksPermitted", [])
            for raw_event in clicks_permitted:
                raw_event["type"] = "clicks permitted"
                event_guid = raw_event.get("GUID", "")
                incident = {
                    "name": "Proofpoint - Click Permitted - {}".format(event_guid),
                    "rawJSON": json.dumps(raw_event),
                    "occurred": raw_event["clickTime"] if raw_event["clickTime"] > raw_event["threatTime"] else raw_event[
                        "threatTime"]
                }
                incidents.append(incident)

            clicks_blocked = raw_events.get("clicksBlocked", [])
            for raw_event in clicks_blocked:
                raw_event["type"] = "clicks blocked"
                event_guid = raw_event.get("GUID", "")
                incident = {
                    "name": "Proofpoint - Click Blocked - {}".format(event_guid),
                    "rawJSON": json.dumps(raw_event),
                    "occurred": raw_event["clickTime"] if raw_event["clickTime"] > raw_event["threatTime"] else raw_event[
                        "threatTime"]
                }
                incidents.append(incident)

        # Cut the milliseconds from last fetch if exists
        end_query_time = end_query_time[:-5] + 'Z' if end_query_time[-5] == '.' else end_query_time
        next_run = {"last_fetch": end_query_time}
        return next_run, incidents[:limit], incidents[limit:]


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    def main():
        """
        PARSE AND VALIDATE INTEGRATION PARAMS
        """
        params = demisto.params()
        service_principal = params.get('credentials', {}).get('identifier')
        secret = params.get('credentials', {}).get('password')

        # Remove trailing slash to prevent wrong URL path to service
        server_url = params['url'][:-1] if (params['url'] and params['url'].endswith('/')) else params['url']
        api_version = params.get('api_version')

        verify_certificate = not params.get('insecure', False)
        # How many time before the first fetch to retrieve incidents
        fetch_time = params.get('fetch_time', '60 minutes')

        threat_status = argToList(params.get('threat_status'))

        threat_type = argToList(params.get('threat_type'))

        event_type_filter = params.get('events_type')

        fetch_limit = 50
        # Remove proxy if not set to true in params
        proxies = handle_proxy()

        command = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            client = Client(server_url, api_version, verify_certificate, service_principal, secret, proxies)
            commands = {
                'proofpoint-get-events': get_events_command,
                'proofpoint-get-forensics': get_forensic_command
            }
            if command == 'test-module':
                results = test_module(client, fetch_time, event_type_filter)
                return_outputs(results)

            elif demisto.command() == 'fetch-incidents':
                integration_context = demisto.getIntegrationContext()
                next_run, incidents, remained_incidents = fetch_incidents(
                    client=client,
                    last_run=demisto.getLastRun(),
                    first_fetch_time=fetch_time,
                    event_type_filter=event_type_filter,
                    threat_status=threat_status,
                    threat_type=threat_type,
                    limit=fetch_limit,
                    integration_context=integration_context
                )
                # Save last_run, incidents, remained incidents into integration
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)
                # preserve context dict
                integration_context['incidents'] = remained_incidents
                demisto.setIntegrationContext(integration_context)

            elif command in commands:
                return_outputs(*commands[command](client, demisto.args()))

        except Exception as e:
            return_error(str(e))


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
