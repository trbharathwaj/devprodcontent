category: Endpoint
commonfields:
  id: Cortex XDR - IR
  version: -1
configuration:
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: ""
  display: Server URL (copy URL from XDR - click ? to see more info.)
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: API Key ID
  name: apikey_id
  required: true
  type: 4
- defaultvalue: ""
  display: API Key
  name: apikey
  required: true
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  type: 0
description: Cortex XDR is the world's first detection and response app that natively
  integrates network, endpoint and cloud data to stop sophisticated attacks.
detaileddescription: |
  ## Palo Alto Networks Cortex XDR - IR
  Cortex XDR is the world's first detection and response app that natively integrates network, endpoint and cloud data to stop sophisticated attacks.

  ### Generate an API Key and API Key ID
  1. In your Cortex XDR platform, go to **Settings**.
  2. Click the **+New Key** button in the top right corner
  3. Generate a key of type **Advanced**.
  4. Copy and paste the key.
  5. From the ID column, copy the Key ID.

  ### URL
  1. In your Cortex XDR platform, go to **Settings**.
  2. Click the **Copy URL** button in the top right corner.
display: Palo Alto Networks Cortex XDR - Investigation and Response
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAACXBIWXMAAAsSAAALEgHS3X78AAAD6klEQVR4nO2cS24bMQyGyaL75AbJCeo5QIH6BnVPkOkN3BPER8gN4tzA3XQbB+gBHHTbRbzq1kH3ZaGA4ygUNaPxxBOA4AcIqPWgHv9QosZOkYjAscs719Y2LrBxXGDjuMDGcYGN4wIbxwU2jgtsHBfYOC6wcVxg47jAxnGBjeMCG+f9W04PEacAENIDES2TCs7wNR77+2BEPAeABQBcRNl3RDRNKjuDGdWDEbEGgCsAOEkKnaPQW2BErHhbPY2ydwCwJqJN0uCluNdJQf/+Q79VUiAgonWS+WyjEuMvIRwjDwPs7OL14eMpJrGfm2+YGyLOAeAPAPwloh9Jb1HlogQAQaAwAGpJD5otfiC0dksuW/LnYH+u2SiwpaVg91SxsVbqdqXFQDtr0bYW5cFJKlEniLsR9eZc9hsA/gHAL22d9ja0TKWT4olkbMgHYxNPhs9kWZ4Ic4DAT7YUG28ucMm8owd/7xBR2UdOH7R1alLJFh06+STybnhyQbhz3kJmAHCmbDG1yH8MdbXtKGICACsWs4tvvDDNw1ixdzR9TsJ2KLbsJY8/5jL6951Snt3ymS3bzZHMl4gWHHQ2Aed+3ogoA9EbIqqjtj8z/SSdZBMvVvwEPQnaUn+m5MmnUPME+SQ3aarUlR5cUifpU2nTq77iwYmH9jj+5BrJneFg210ePBOf6zbPI6JVkpl64VVSI8+swHM0kgBGqfPanLPXSTrv+MEzOWCbcFa8Y94rOhTTK4pui0xbeLFtE9EuXzWhM1oODwwixjYrcQ175G3v2JyJbb7hrmPrbpjyUSOPs2nPNXtBL4FDyD6ksyMxaTE7eIFGRIthTnjHqw8dRte7aLkw86RGN9u4BgcVpWTv1RH37CVbkf+d44USG69BeBuHSuoMFDveEVxw+UF0CbxkL2i4DOcMX77jAZ6GQSCidtbJbb3PYEu21jkvYsViN3wecnaNBSLOhLhhvb+Idb8+WGQt8hIRnryQxxH1Wl7EC9vLC70WRa8y48lG0XxN2rX1lUuvEEUfcg+uxHj3LzuUMuIgNxlHW2otFCLJztSUaS9fdOyEMFLgdY8XHdPSRWtLYwusjDN5GBXnKJpLn2tS4+VLRFxxhzMlUt3yZHNRdmh3G30ObW8RsYkwm3M5bLFXHdeKHZ+58ed4rBt+zxtfxxYF23VsUztqNPqc77LuQuQtZbzA6w7iWAtHZF0aOI72dWFHIOFfFx6J0X7RwV75VQQPjhWB4Vnkit9lOyPwpn/h7z/ZOT7+XzgYx39VaRwX2DgusHFcYOO4wMZxgY3jAhvHBTaOC2wcF9g4LrBxXGDjuMDGcYEtAwD/AbjPSozwVJX9AAAAAElFTkSuQmCC
name: Cortex XDR - IR
script:
  commands:
  - arguments:
    - description: Time format 2019-12-31T23:59:00.
      name: lte_creation_time
    - description: Returned incidents that were created on or after the specified
        date/time, in the format 2019-12-31T23:59:00.
      name: gte_creation_time
    - description: Filters returned incidents that were created on or before the specified
        date/time, in the format 2019-12-31T23:59:00.
      name: lte_modification_time
    - description: Filters returned incidents that were modified on or after the specified
        date/time, in the format 2019-12-31T23:59:00.
      name: gte_modification_time
    - description: An array or CSV string of incident IDs.
      isArray: true
      name: incident_id_list
    - description: Filters returned incidents that were created on or after the specified
        date/time range, for example, 1 month, 2 days, 1 hour, and so on.
      name: since_creation_time
    - description: Filters returned incidents that were modified on or after the specified
        date/time range, for example, 1 month, 2 days, 1 hour, and so on.
      name: since_modification_time
    - auto: PREDEFINED
      description: Sorts returned incidents by the date/time that the incident was
        last modified ("asc" - ascending, "desc" - descending).
      name: sort_by_modification_time
      predefined:
      - asc
      - desc
    - auto: PREDEFINED
      description: Sorts returned incidents by the date/time that the incident was
        created ("asc" - ascending, "desc" - descending).
      name: sort_by_creation_time
      predefined:
      - asc
      - desc
    - defaultValue: "0"
      description: Page number (for pagination). The default is 0 (the first page).
      name: page
    - defaultValue: "100"
      description: Maximum number of incidents to return per page. The default and
        maximum is 100.
      name: limit
    description: |-
      Returns a list of incidents, which you can filter by a list of incident IDs (max. 100), the time the incident was last modified, and the time the incident was created.
      If you pass multiple filtering arguments, they will be concatenated using the AND condition. The OR condition is not supported.
    name: xdr-get-incidents
    outputs:
    - contextPath: PaloAltoNetworksXDR.Incident.incident_id
      description: Unique ID assigned to each returned incident.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.manual_severity
      description: Incident severity assigned by the user. This does not affect the
        calculated severity. Can be "low", "medium", "high"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.manual_description
      description: Incident description provided by the user.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.assigned_user_mail
      description: Email address of the assigned user.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.high_severity_alert_count
      description: Number of alerts with the severity HIGH.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.host_count
      description: Number of hosts involved in the incident.
      type: number
    - contextPath: PaloAltoNetworksXDR.Incident.xdr_url
      description: A link to the incident view on XDR.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.assigned_user_pretty_name
      description: Full name of the user assigned to the incident.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alert_count
      description: Total number of alerts in the incident.
      type: number
    - contextPath: PaloAltoNetworksXDR.Incident.med_severity_alert_count
      description: Number of alerts with the severity MEDIUM.
      type: number
    - contextPath: PaloAltoNetworksXDR.Incident.user_count
      description: Number of users involved in the incident.
      type: number
    - contextPath: PaloAltoNetworksXDR.Incident.severity
      description: |
        Calculated severity of the incident
        "low","medium","high"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.low_severity_alert_count
      description: Number of alerts with the severity LOW.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.status
      description: |
        Current status of the incident. Can be "new","under_investigation","resolved_threat_handled","resolved_known_issue","resolved_duplicate","resolved_false_positive", or "resolved_other".
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.description
      description: Dynamic calculated description of the incident.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.resolve_comment
      description: Comments entered by the user when the incident was resolved.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.notes
      description: Comments entered by the user regarding the incident.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.creation_time
      description: Date and time the incident was created on XDR.
      type: date
    - contextPath: PaloAltoNetworksXDR.Incident.detection_time
      description: Date and time that the first alert occurred in the incident.
      type: date
    - contextPath: PaloAltoNetworksXDR.Incident.modification_time
      description: Date and time that the incident was last modified.
      type: date
  - arguments:
    - description: The ID of the incident for which to get additional data.
      name: incident_id
      required: true
    - defaultValue: "1000"
      description: Maximum number of alerts to return. Default is 1,000.
      name: alerts_limit
    description: Returns additional data for the specified incident, for example,
      related alerts, file artifacts, network artifacts, and so on.
    name: xdr-get-incident-extra-data
    outputs:
    - contextPath: PaloAltoNetworksXDR.Incident.incident_id
      description: Unique ID assigned to each returned incident.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.creation_time
      description: Date and time the incident was created on XDR.
      type: Date
    - contextPath: PaloAltoNetworksXDR.Incident.modification_time
      description: Date and time that the incident was last modified.
      type: Date
    - contextPath: PaloAltoNetworksXDR.Incident.detection_time
      description: Date and time that the first alert occurred in the incident.
      type: Date
    - contextPath: PaloAltoNetworksXDR.Incident.status
      description: |-
        Current status of the incident:
        "new","under_investigation","resolved_threat_handled","resolved_known_issue","resolved_duplicate","resolved_false_positive","resolved_other"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.severity
      description: Calculated severity of the incident "low","medium","high"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.description
      description: Dynamic calculated description of the incident.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.assigned_user_mail
      description: Email address of the assigned user.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.assigned_user_pretty_name
      description: Full name of the user assigned to the incident.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alert_count
      description: Total number of alerts in the incident.
      type: Number
    - contextPath: PaloAltoNetworksXDR.Incident.low_severity_alert_count
      description: Number of alerts with the severity LOW.
      type: Number
    - contextPath: PaloAltoNetworksXDR.Incident.med_severity_alert_count
      description: Number of alerts with the severity MEDIUM.
      type: Number
    - contextPath: PaloAltoNetworksXDR.Incident.high_severity_alert_count
      description: Number of alerts with the severity HIGH.
      type: Number
    - contextPath: PaloAltoNetworksXDR.Incident.user_count
      description: Number of users involved in the incident.
      type: Number
    - contextPath: PaloAltoNetworksXDR.Incident.host_count
      description: Number of hosts involved in the incident
      type: Number
    - contextPath: PaloAltoNetworksXDR.Incident.notes
      description: Comments entered by the user regarding the incident.
      type: Unknown
    - contextPath: PaloAltoNetworksXDR.Incident.resolve_comment
      description: Comments entered by the user when the incident was resolved.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.manual_severity
      description: Incident severity assigned by the user. This does not affect the
        calculated severity low medium high
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.manual_description
      description: Incident description provided by the user.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.xdr_url
      description: A link to the incident view on XDR.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.starred
      description: Incident starred
      type: Boolean
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.alert_id
      description: Unique ID for each alert.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.detection_timestamp
      description: Date and time that the alert occurred.
      type: Date
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.source
      description: Source of the alert. The product/vendor this alert came from.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.severity
      description: Severity of the alert.,"low","medium","high"""
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.name
      description: Calculated name of the alert.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.category
      description: Category of the alert, for example, Spyware Detected via Anti-Spyware
        profile.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.description
      description: Textual description of the alert.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.host_ip
      description: Host IP involved in the alert.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.host_name
      description: Host name involved in the alert.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.user_name
      description: User name involved with the alert.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.event_type
      description: Event type "Process Execution","Network Event","File Event","Registry
        Event","Injection Event","Load Image Event","Windows Event Log"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action
      description: The action that triggered the alert. "REPORTED", "BLOCKED", "POST_DETECTED",
        "SCANNED", "DOWNLOAD", "PROMPT_ALLOW", "PROMPT_BLOCK", "DETECTED", "BLOCKED_1",
        "BLOCKED_2", "BLOCKED_3", "BLOCKED_5", "BLOCKED_6", "BLOCKED_7", "BLOCKED_8",
        "BLOCKED_9", "BLOCKED_10", "BLOCKED_11", "BLOCKED_13", "BLOCKED_14", "BLOCKED_15",
        "BLOCKED_16", "BLOCKED_17", "BLOCKED_24", "BLOCKED_25", "DETECTED_0", "DETECTED_4",
        "DETECTED_18", "DETECTED_19", "DETECTED_20", "DETECTED_21", "DETECTED_22",
        "DETECTED_23"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_pretty
      description: The action that triggered the alert "Detected (Reported)" "Prevented
        (Blocked)" "Detected (Post Detected)" "Detected (Scanned)" "Detected (Download)"
        "Detected (Prompt Allow)" "Prevented (Prompt Block)" "Detected" "Prevented
        (Denied The Session)" "Prevented (Dropped The Session)" "Prevented (Dropped
        The Session And Sent a TCP Reset)" "Prevented (Blocked The URL)" "Prevented
        (Blocked The IP)" "Prevented (Dropped The Packet)" "Prevented (Dropped All
        Packets)" "Prevented (Terminated The Session And Sent a TCP Reset To Both
        Sides Of The Connection)" "Prevented (Terminated The Session And Sent a TCP
        Reset To The Client)" "Prevented (Terminated The Session And Sent a TCP Reset
        To The Server)" "Prevented (Continue)" "Prevented (Block-Override)" "Prevented
        (Override-Lockout)" "Prevented (Override)" "Prevented (Random-Drop)" "Prevented
        (Silently Dropped The Session With An ICMP Unreachable Message To The Host
        Or Application)" "Prevented (Block)" "Detected (Allowed The Session)" "Detected
        (Raised An Alert)" "Detected (Syncookie Sent)" "Detected (Forward)" "Detected
        (Wildfire Upload Success)" "Detected (Wildfire Upload Failure)" "Detected
        (Wildfire Upload Skip)" "Detected (Sinkhole)"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.actor_process_image_name
      description: Image name
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.actor_process_command_line
      description: Command line
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.actor_process_signature_status
      description: Signature status "Signed" "Invalid Signature" "Unsigned" "Revoked"
        "Signature Fail" "N/A" "Weak Hash"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.actor_process_signature_vendor
      description: Singature vendor name
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.causality_actor_process_image_name
      description: Image name
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.causality_actor_process_command_line
      description: Command line
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.causality_actor_process_signature_status
      description: Signature status "Signed" "Invalid Signature" "Unsigned" "Revoked"
        "Signature Fail" "N/A" "Weak Hash"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.causality_actor_process_signature_vendor
      description: Signature vendor
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.causality_actor_causality_id
      description: Causality id
      type: Unknown
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_process_image_name
      description: Image name
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_process_image_command_line
      description: Command line
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_process_image_sha256
      description: Image SHA256
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_process_signature_status
      description: Signature status "Signed" "Invalid Signature" "Unsigned" "Revoked"
        "Signature Fail" "N/A" "Weak Hash"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_process_signature_vendor
      description: Signature vendor name
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_file_path
      description: File path
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_file_md5
      description: File MD5
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_file_sha256
      description: File SHA256
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_registry_data
      description: Registry data
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_registry_full_key
      description: Registry full key
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_local_ip
      description: Local IP
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_local_port
      description: Local port
      type: Number
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_remote_ip
      description: Remote IP
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_remote_port
      description: Remote port
      type: Number
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.action_external_hostname
      description: External hostname
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.fw_app_id
      description: Firewall app id
      type: Unknown
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.is_whitelisted
      description: Is whitelisted "Yes" "No"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.alerts.starred
      description: Alert starred
      type: Boolean
    - contextPath: PaloAltoNetworksXDR.Incident.network_artifacts.type
      description: Network artifact type "IP"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.network_artifacts.network_remote_port
      description: The remote port related to the artifact.
      type: number
    - contextPath: PaloAltoNetworksXDR.Incident.network_artifacts.alert_count
      description: Number of alerts related to the artifact.
      type: number
    - contextPath: PaloAltoNetworksXDR.Incident.network_artifacts.network_remote_ip
      description: The remote IP related to the artifact.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.network_artifacts.is_manual
      description: Whether the artifact was created by the user (manually).
      type: boolean
    - contextPath: PaloAltoNetworksXDR.Incident.network_artifacts.network_domain
      description: The domain related to the artifact.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.network_artifacts.type
      description: The artifact type. "META", "GID", "CID", "HASH", "IP", "DOMAIN",
        "REGISTRY", "HOSTNAME"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.network_artifacts.network_country
      description: The country related to the artifact
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.file_artifacts.file_signature_status
      description: Digital signature status of the file. "SIGNATURE_UNAVAILABLE" "SIGNATURE_SIGNED"
        "SIGNATURE_INVALID" "SIGNATURE_UNSIGNED" "SIGNATURE_WEAK_HASH"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.file_artifacts.is_process
      description: Whether the file artifact is related to a process execution.
      type: boolean
    - contextPath: PaloAltoNetworksXDR.Incident.file_artifacts.file_name
      description: Name of the file.
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.file_artifacts.file_wildfire_verdict
      description: The file verdict, calculated by Wildfire. "BENIGN" "MALWARE" "GRAYWARE"
        "PHISING" "UNKNOWN"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.file_artifacts.alert_count
      description: Number of alerts related to the artifact.
      type: number
    - contextPath: PaloAltoNetworksXDR.Incident.file_artifacts.is_malicious
      description: Whether the artifact is malicious, decided by the Wildfire verdic
      type: boolean
    - contextPath: PaloAltoNetworksXDR.Incident.file_artifacts.is_manual
      description: Whether the artifact was created by the user (manually).
      type: boolean
    - contextPath: PaloAltoNetworksXDR.Incident.file_artifacts.type
      description: The artifact type "META" "GID" "CID" "HASH" "IP" "DOMAIN" "REGISTRY"
        "HOSTNAME"
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.file_artifacts.file_sha256
      description: SHA-256 hash of the file
      type: String
    - contextPath: PaloAltoNetworksXDR.Incident.file_artifacts.file_signature_vendor_name
      description: File signature vendor name
      type: String
  - arguments:
    - description: XDR incident ID. You can get the incident ID from the output of
        the 'xdr-get-incidents' command or the 'xdr-get-incident-extra-details' command.
      name: incident_id
      required: true
    - auto: PREDEFINED
      description: Severity to assign to the incident (LOW, MEDIUM, or HIGH).
      name: manual_severity
      predefined:
      - HIGH
      - MEDIUM
      - LOW
    - description: Email address of the user to assigned to the incident.
      name: assigned_user_mail
    - description: Full name of the user assigned to the incident.
      name: assigned_user_pretty_name
    - auto: PREDEFINED
      description: Status of the incident (NEW, UNDER_INVESTIGATION, RESOLVED_THREAT_HANDLED,
        RESOLVED_KNOWN_ISSUE, RESOLVED_DUPLICATE, RESOLVED_FALSE_POSITIVE, RESOLVED_OTHER).
      name: status
      predefined:
      - NEW
      - UNDER_INVESTIGATION
      - RESOLVED_THREAT_HANDLED
      - RESOLVED_KNOWN_ISSUE
      - RESOLVED_DUPLICATE
      - RESOLVED_FALSE_POSITIVE
      - RESOLVED_OTHER
    - description: Comment explaining why the incident was resolved. This should be
        set when the incident is resolved.
      name: resolve_comment
    - auto: PREDEFINED
      description: If true, will remove all assigned users from the incident.
      name: unassign_user
      predefined:
      - "true"
    description: Updates one or more fields of a specified incident. Missing fields
      will be ignored. To remove the assignment for an incident, pass a null value
      in assignee email argument.
    name: xdr-update-incident
  - arguments:
    - description: String value that defines the product.
      name: product
      required: true
    - description: String value that defines the product.
      name: vendor
      required: true
    - description: String value for the source IP address
      name: local_ip
    - description: Integer value for the source port.
      name: local_port
      required: true
    - description: |-
        String value of the destination IP
        address.
      name: remote_ip
      required: true
    - description: |-
        Integer value for the destination
        port.
      name: remote_port
      required: true
    - description: Integer value representing the epoch of the time the alert occurred
        in milliseconds or String value of date format 2019-10-23T10:00:00. If not
        set then the event time will be defined as now.
      name: event_timestampt
    - auto: PREDEFINED
      description: |-
        String value of alert severity:
        Informational, Low, Medium, High, or Unknown
      name: severity
      predefined:
      - Informational
      - Low
      - Medium
      - High
      - Unknown
    - description: String defining the alert name
      name: alert_name
      required: true
    - description: String defining the alert description
      name: alert_description
    description: |-
      Upload alert from external alert sources in Cortex XDR format. Cortex XDR displays alerts that are parsed
      successfully in related incidents and views. You can send 600 alerts per minute. Each request can contain a
      maximum of 60 alerts.
    name: xdr-insert-parsed-alert
  - arguments:
    - description: List of alerts in CEF format.
      isArray: true
      name: cef_alerts
      required: true
    description: Upload alerts in CEF format from external alert sources. After you
      map CEF alert fields to Cortex XDR fields, Cortex XDR displays the alerts in
      related incidents and views. You can send 600 requests per minute. Each request
      can contain a maximum of 60 alerts.
    name: xdr-insert-cef-alerts
  - arguments:
    - description: The endpoint ID (string) to isolate. You can retrieve the string
        from the xdr-get-endpoints command.
      name: endpoint_id
      required: true
    description: Isolates the specified endpoint.
    execution: true
    name: xdr-isolate-endpoint
  - arguments:
    - description: The endpoint ID (string) for which to reverse the isolation. You
        can retrieve it from the xdr-get-endpoints command.
      name: endpoint_id
      required: true
    description: Reverses the isolation of an endpoint.
    execution: true
    name: xdr-unisolate-endpoint
  - arguments:
    - description: A comma-separated list of endpoint IDs.
      isArray: true
      name: endpoint_id_list
    - description: "A comma-separated list of distribution package names or installation
        package names. \nExample: dist_name1,dist_name2"
      isArray: true
      name: dist_name
    - description: |-
        A comma-separated list of IP addresses.
        Example: 8.8.8.8,1.1.1.1
      isArray: true
      name: ip_list
    - description: |-
        The group name to which the agent belongs.
        Example: group_name1,group_name2
      isArray: true
      name: group_name
    - auto: PREDEFINED
      description: 'The endpoint platform. Can be "windows", "linux", "macos", or
        "android". '
      isArray: true
      name: platform
      predefined:
      - windows
      - linux
      - macos
      - android
    - description: |-
        A comma-separated list of alias names.
        Examples: alias_name1,alias_name2
      isArray: true
      name: alias_name
    - auto: PREDEFINED
      description: '"Specifies whether the endpoint was isolated or unisolated. Can
        be "isolated" or "unisolated".'
      name: isolate
      predefined:
      - isolated
      - unisolated
    - description: |-
        Hostname
        Example: hostname1,hostname2
      isArray: true
      name: hostname
    - description: |-
        All the agents that were first seen after {first_seen_gte}.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      name: first_seen_gte
    - description: |-
        All the agents that were first seen before {first_seen_lte}.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      name: first_seen_lte
    - description: |-
        All the agents that were last seen before {last_seen_gte}.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      name: last_seen_gte
    - description: |-
        All the agents that were last seen before {last_seen_lte}.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      name: last_seen_lte
    - defaultValue: "0"
      description: Page number (for pagination). The default is 0 (the first page).
      name: page
    - defaultValue: "30"
      description: Maximum number of endpoints to return per page. The default and
        maximum is 30.
      name: limit
    - auto: PREDEFINED
      description: Specifies whether to sort endpoints by the first time or last time
        they were seen. Can be "first_seen" or "last_seen".
      name: sort_by
      predefined:
      - first_seen
      - last_seen
    - auto: PREDEFINED
      defaultValue: asc
      description: The order by which to sort results. Can be "asc" (ascending) or
        "desc" ( descending). Default set to asc.
      name: sort_order
      predefined:
      - asc
      - desc
    description: Gets a list of endpoints, according to the passed filters. Filtering
      by multiple fields will be concatenated using AND condition (OR is not supported).
      Maximum result set size is 100. Offset is the zero-based number of endpoint
      from the start of the result set (start by counting from 0).
    name: xdr-get-endpoints
    outputs:
    - contextPath: PaloAltoNetworksXDR.Endpoint.endpoint_id
      description: The endpoint ID.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.endpoint_name
      description: The endpoint name.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.endpoint_type
      description: The endpoint type.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.endpoint_status
      description: The status of the endpoint'
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.os_type
      description: The endpoint OS type.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.ip
      description: A list of IP addresses.
      type: Unknown
    - contextPath: PaloAltoNetworksXDR.Endpoint.users
      description: A list of users.
      type: Unknown
    - contextPath: PaloAltoNetworksXDR.Endpoint.domain
      description: The endpoint domain.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.alias
      description: The endpoint's aliases.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.first_seen
      description: First seen date/time in Epoch (milliseconds).
      type: Unknown
    - contextPath: PaloAltoNetworksXDR.Endpoint.last_seen
      description: Last seen date/time in Epoch (milliseconds).
      type: Date
    - contextPath: PaloAltoNetworksXDR.Endpoint.content_version
      description: Content version.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.installation_package
      description: Installation package.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.active_directory
      description: Active directory.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.install_date
      description: Install date in Epoch (milliseconds).
      type: Date
    - contextPath: PaloAltoNetworksXDR.Endpoint.endpoint_version
      description: Endpoint version.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.is_isolated
      description: Whether the endpoint is isolated.
      type: String
    - contextPath: PaloAltoNetworksXDR.Endpoint.group_name
      description: The name of the group to which the endpoint belongs.
      type: String
  - arguments: []
    description: Gets a list of all the agent versions to use for creating a distribution
      list.
    name: xdr-get-distribution-versions
    outputs:
    - contextPath: PaloAltoNetworksXDR.DistributionVersions.windows
      description: A list of Windows agent versions.
      type: Unknown
    - contextPath: PaloAltoNetworksXDR.DistributionVersions.linux
      description: A list of Linux agent versions.
      type: Unknown
    - contextPath: PaloAltoNetworksXDR.DistributionVersions.macos
      description: A list of Mac agent versions.
      type: Unknown
  - arguments:
    - description: A string representing the name of the installation package.
      name: name
      required: true
    - auto: PREDEFINED
      description: "String, valid values are:\n• windows \n• linux\n• macos \n• android"
      name: platform
      predefined:
      - windows
      - linux
      - macos
      - android
      required: true
    - auto: PREDEFINED
      description: |-
        A string representing the type of package to create.
        standalone - An installation for a new agent
        upgrade - An upgrade of an agent from ESM
      name: package_type
      predefined:
      - standalone
      - upgrade
      required: true
    - description: agent_version returned from xdr-get-distribution-versions. Not
        required for Android platfom
      name: agent_version
      required: true
    - description: Information about the package.
      name: description
    description: Creates an installation package. This is an asynchronous call that
      returns the distribution ID. This does not mean that the creation succeeded.
      To confirm that the package has been created, check the status of the distribution
      by running the Get Distribution Status API.
    name: xdr-create-distribution
    outputs:
    - contextPath: PaloAltoNetworksXDR.Distribution.id
      description: The installation package ID.
      type: String
    - contextPath: PaloAltoNetworksXDR.Distribution.name
      description: The name of the installation package.
      type: String
    - contextPath: PaloAltoNetworksXDR.Distribution.platform
      description: The installation OS.
      type: String
    - contextPath: PaloAltoNetworksXDR.Distribution.agent_version
      description: Agent version.
      type: String
    - contextPath: PaloAltoNetworksXDR.Distribution.description
      description: Information about the package.
      type: String
  - arguments:
    - description: |-
        The ID of the installation package.
        Copy the distribution_id from the "id" field on Endpoints > Agent Installation page.
      name: distribution_id
      required: true
    - auto: PREDEFINED
      description: |-
        The installation package type. Valid
        values are:
        • upgrade
        • sh - For Linux
        • rpm - For Linux
        • deb - For Linux
        • pkg - For Mac
        • x86 - For Windows
        • x64 - For Windows
      name: package_type
      predefined:
      - upgrade
      - sh
      - rpm
      - deb
      - pkg
      - x86
      - x64
      required: true
    description: Gets the distribution URL for downloading the installation package.
    name: xdr-get-distribution-url
    outputs:
    - contextPath: PaloAltoNetworksXDR.Distribution.id
      description: Distribution ID.
      type: String
    - contextPath: PaloAltoNetworksXDR.Distribution.url
      description: URL for downloading the installation package.
      type: String
  - arguments:
    - description: A comma-separated list of distribution IDs to get the status of.
      isArray: true
      name: distribution_ids
      required: true
    description: Gets the status of the installation package.
    name: xdr-get-create-distribution-status
    outputs:
    - contextPath: PaloAltoNetworksXDR.Distribution.id
      description: Distribution ID.
      type: String
    - contextPath: PaloAltoNetworksXDR.Distribution.status
      description: The status of installation package.
      type: String
  - arguments:
    - description: User’s email address.
      name: email
    - auto: PREDEFINED
      description: The audit log type.
      name: type
      predefined:
      - REMOTE_TERMINAL
      - RULES
      - AUTH
      - RESPONSE
      - INCIDENT_MANAGEMENT
      - ENDPOINT_MANAGEMENT
      - ALERT_WHITELIST
      - PUBLIC_API
      - DISTRIBUTIONS
      - STARRED_INCIDENTS
      - POLICY_PROFILES
      - DEVICE_CONTROL_PROFILE
      - HOST_FIREWALL_PROFILE
      - POLICY_RULES
      - PROTECTION_POLICY
      - DEVICE_CONTROL_TEMP_EXCEPTIONS
      - DEVICE_CONTROL_GLOBAL_EXCEPTIONS
      - GLOBAL_EXCEPTIONS
      - MSSP
      - REPORTING
      - DASHBOARD
      - BROKER_VM
    - description: The audit log subtype.
      name: sub_type
    - auto: PREDEFINED
      description: Result type
      name: result
      predefined:
      - SUCCESS
      - FAIL
      - PARTIAL
    - description: |-
        Return logs for which the timestamp is after 'log_time_after'.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      name: timestamp_gte
    - description: |-
        Return logs for which the timestamp is before the 'log_time_after'.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      name: timestamp_lte
    - defaultValue: "0"
      description: Page number (for pagination). The default is 0 (the first page).
      name: page
    - defaultValue: "30"
      description: Maximum number of audit logs to return per page. The default and
        maximum is 30.
      name: limit
    - auto: PREDEFINED
      description: Specifies the field by which to sort the results. By default the
        sort is defined as creation-time and DESC. Can be "type", "sub_type", "result",
        or "timestamp".
      name: sort_by
      predefined:
      - type
      - sub_type
      - result
      - timestamp
    - auto: PREDEFINED
      defaultValue: desc
      description: 'The sort order. Can be "asc" (ascending) or "desc" (descending).
        Default set to "desc". '
      name: sort_order
      predefined:
      - asc
      - desc
    description: Gets management logs. You can filter by multiple fields, which will
      be concatenated using AND condition (OR is not supported). Maximum result set
      size is 100. Offset is the zero-based number of management logs from the start
      of the result set (start by counting from 0).
    name: xdr-get-audit-management-logs
    outputs:
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_ID
      description: Audit log ID.
      type: Number
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_OWNER_NAME
      description: Audit owner name.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_OWNER_EMAIL
      description: Audit owner email address.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_ASSET_JSON
      description: Asset JSON.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_ASSET_NAMES
      description: Audit asset names.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_HOSTNAME
      description: Host name.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_RESULT
      description: Audit result.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_REASON
      description: Audit reason.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_DESCRIPTION
      description: Description of the audit.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_ENTITY
      description: Audit entity (e.g., AUTH, DISTRIBUTIONS).
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_ENTITY_SUBTYPE
      description: Entity subtype (e.g., Login, Create).
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_CASE_ID
      description: Audit case ID.
      type: Number
    - contextPath: PaloAltoNetworksXDR.AuditManagementLogs.AUDIT_INSERT_TIME
      description: Log's insert time.
      type: Date
  - arguments:
    - description: A comma-separated list of endpoint IDs.
      isArray: true
      name: endpoint_ids
    - description: A comma-separated list of endpoint names.
      isArray: true
      name: endpoint_names
    - auto: PREDEFINED
      description: The report type. Can be "Installation", "Policy", "Action", "Agent
        Service", "Agent Modules", or "Agent Status".
      isArray: true
      name: type
      predefined:
      - Installation
      - Policy
      - Action
      - Agent Service
      - Agent Modules
      - Agent Status
    - auto: PREDEFINED
      description: The report subtype.
      isArray: true
      name: sub_type
      predefined:
      - Install
      - Uninstall
      - Upgrade
      - Local Configuration
      - Content Update
      - Policy Update
      - Process Exception
      - Hash Exception
      - Scan
      - File Retrieval
      - File Scan
      - Terminate Process
      - Isolate
      - Cancel Isolation
      - Payload Execution
      - Quarantine
      - Restore
      - Stop
      - Start
      - Module Initialization
      - Local Analysis Model
      - Local Analysis Feature Extraction
      - Fully Protected
      - OS Incompatible
      - Software Incompatible
      - Kernel Driver Initialization
      - Kernel Extension Initialization
      - Proxy Communication
      - Quota Exceeded
      - Minimal Content
      - Reboot Eequired
      - Missing Disc Access
    - auto: PREDEFINED
      description: The result type. Can be "Success" or "Fail". If not passed, returns
        all event reports.
      isArray: true
      name: result
      predefined:
      - Success
      - Fail
    - description: |-
        Return logs that their timestamp is greater than 'log_time_after'.
        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      name: timestamp_gte
    - description: |-
        Return logs for which the timestamp is before the 'timestamp_lte'.

        Supported values:
        1579039377301 (time in milliseconds)
        "3 days" (relative date)
        "2019-10-21T23:45:00" (date)
      name: timestamp_lte
    - defaultValue: "0"
      description: Page number (for pagination). The default is 0 (the first page).
      name: page
    - defaultValue: "30"
      description: The maximum number of reports to return. Default and maximum is
        30.
      name: limit
    - auto: PREDEFINED
      description: The field by which to sort results. Can be "type", "category",
        "trapsversion", "timestamp", or "domain").
      name: sort_by
      predefined:
      - type
      - category
      - trapsversion
      - timestamp
      - domain
    - auto: PREDEFINED
      defaultValue: asc
      description: 'The sort order. Can be "asc" (ascending) or "desc" (descending).
        Default is "asc". '
      name: sort_order
      predefined:
      - asc
      - desc
    description: Gets agent event reports. You can filter by multiple fields, which
      will be concatenated using AND condition (OR is not supported). Maximum result
      set size is 100. Offset is the zero-based number of reports from the start of
      the result set (start by counting from 0).
    name: xdr-get-audit-agent-reports
    outputs:
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.ENDPOINTID
      description: Endpoint ID.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.ENDPOINTNAME
      description: Endpoint name.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.DOMAIN
      description: Agent domain.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.TRAPSVERSION
      description: Traps version.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.RECEIVEDTIME
      description: Received time in Epoch time.
      type: Date
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.TIMESTAMP
      description: Timestamp in Epoch time.
      type: Date
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.CATEGORY
      description: Report category (e.g., Audit).
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.TYPE
      description: Report type (e.g., Action, Policy).
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.SUBTYPE
      description: Report subtype (e.g., Fully Protected,Policy Update,Cancel Isolation).
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.RESULT
      description: Report result.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.REASON
      description: Report reason.
      type: String
    - contextPath: PaloAltoNetworksXDR.AuditAgentReports.DESCRIPTION
      description: Agent report description.
      type: String
  dockerimage: demisto/python3:3.7.4.977
  isfetch: true
  runonce: false
  script: |
    from datetime import timezone
    import secrets
    import string
    import hashlib
    from typing import Any, Dict
    import dateparser
    import urllib3


    # Disable insecure warnings
    urllib3.disable_warnings()

    TIME_FORMAT = "%Y-%m-%dT%H:%M:%S"
    NONCE_LENGTH = 64
    API_KEY_LENGTH = 128

    INTEGRATION_CONTEXT_BRAND = 'PaloAltoNetworksXDR'


    def convert_epoch_to_milli(timestamp):
        if timestamp is None:
            return None
        if 9 < len(str(timestamp)) < 13:
            timestamp = int(timestamp) * 1000
        return int(timestamp)


    def convert_datetime_to_epoch(the_time=0):
        if the_time is None:
            return None
        try:
            if isinstance(the_time, datetime):
                return int(the_time.strftime('%s'))
        except Exception as err:
            print(err)
            return 0


    def convert_datetime_to_epoch_millis(the_time=0):
        return convert_epoch_to_milli(convert_datetime_to_epoch(the_time=the_time))


    def generate_current_epoch_utc():
        return convert_datetime_to_epoch_millis(datetime.now(timezone.utc))


    def generate_key():
        return "".join([secrets.choice(string.ascii_letters + string.digits) for _ in range(API_KEY_LENGTH)])


    def create_auth(api_key):
        nonce = "".join([secrets.choice(string.ascii_letters + string.digits) for _ in range(NONCE_LENGTH)])
        timestamp = str(generate_current_epoch_utc())  # Get epoch time utc millis
        hash_ = hashlib.sha256()
        hash_.update((api_key + nonce + timestamp).encode("utf-8"))
        return nonce, timestamp, hash_.hexdigest()


    def clear_trailing_whitespace(res):
        index = 0
        while index < len(res):
            for key, value in res[index].items():
                if isinstance(value, str):
                    res[index][key] = value.rstrip()
            index += 1
        return res


    class Client(BaseClient):
        def test_module(self, first_fetch_time):
            """
                Performs basic get request to get item samples
            """
            last_one_day, _ = parse_date_range(first_fetch_time, TIME_FORMAT)
            self.get_incidents(lte_creation_time=last_one_day, limit=1)

        def get_incidents(self, incident_id_list=None, lte_modification_time=None, gte_modification_time=None,
                          lte_creation_time=None, gte_creation_time=None, sort_by_modification_time=None,
                          sort_by_creation_time=None, page_number=0, limit=100, gte_creation_time_milliseconds=0):
            """
            Filters and returns incidents

            :param incident_id_list: List of incident ids - must be list
            :param lte_modification_time: string of time format "2019-12-31T23:59:00"
            :param gte_modification_time: string of time format "2019-12-31T23:59:00"
            :param lte_creation_time: string of time format "2019-12-31T23:59:00"
            :param gte_creation_time: string of time format "2019-12-31T23:59:00"
            :param sort_by_modification_time: optional - enum (asc,desc)
            :param sort_by_creation_time: optional - enum (asc,desc)
            :param page_number: page number
            :param limit: maximum number of incidents to return per page
            :param gte_creation_time_milliseconds: greater than time in milliseconds
            :return:
            """
            search_from = page_number * limit
            search_to = search_from + limit

            request_data = {
                'search_from': search_from,
                'search_to': search_to
            }

            if sort_by_creation_time and sort_by_modification_time:
                raise ValueError('Should be provide either sort_by_creation_time or '
                                 'sort_by_modification_time. Can\'t provide both')
            if sort_by_creation_time:
                request_data['sort'] = {
                    'field': 'creation_time',
                    'keyword': sort_by_creation_time
                }
            elif sort_by_modification_time:
                request_data['sort'] = {
                    'field': 'modification_time',
                    'keyword': sort_by_modification_time
                }

            filters = []
            if incident_id_list is not None and len(incident_id_list) > 0:
                filters.append({
                    'field': 'incident_id_list',
                    'operator': 'in',
                    'value': incident_id_list
                })

            if lte_creation_time:
                filters.append({
                    'field': 'creation_time',
                    'operator': 'lte',
                    'value': date_to_timestamp(lte_creation_time, TIME_FORMAT)
                })

            if gte_creation_time:
                filters.append({
                    'field': 'creation_time',
                    'operator': 'gte',
                    'value': date_to_timestamp(gte_creation_time, TIME_FORMAT)
                })

            if lte_modification_time:
                filters.append({
                    'field': 'modification_time',
                    'operator': 'lte',
                    'value': date_to_timestamp(lte_modification_time, TIME_FORMAT)
                })

            if gte_modification_time:
                filters.append({
                    'field': 'modification_time',
                    'operator': 'gte',
                    'value': date_to_timestamp(gte_modification_time, TIME_FORMAT)
                })

            if gte_creation_time_milliseconds > 0:
                filters.append({
                    'field': 'creation_time',
                    'operator': 'gte',
                    'value': gte_creation_time_milliseconds
                })

            if len(filters) > 0:
                request_data['filters'] = filters

            res = self._http_request(
                method='POST',
                url_suffix='/incidents/get_incidents/',
                json_data={'request_data': request_data}
            )
            incidents = res.get('reply').get('incidents', [])

            return incidents

        def get_incident_extra_data(self, incident_id, alerts_limit=1000):
            """
            Returns incident by id

            :param incident_id: The id of incident
            :param alerts_limit: Maximum number alerts to get
            :return:
            """
            request_data = {
                'incident_id': incident_id,
                'alerts_limit': alerts_limit
            }

            reply = self._http_request(
                method='POST',
                url_suffix='/incidents/get_incident_extra_data/',
                json_data={'request_data': request_data}
            )

            incident = reply.get('reply')

            return incident

        def update_incident(self, incident_id, assigned_user_mail, assigned_user_pretty_name, status, severity,
                            resolve_comment, unassign_user):
            update_data = {}

            if unassign_user and (assigned_user_mail or assigned_user_pretty_name):
                raise ValueError("Can't provide both assignee_email/assignee_name and unassign_user")
            if unassign_user:
                update_data['assigned_user_mail'] = 'none'

            if assigned_user_mail:
                update_data['assigned_user_mail'] = assigned_user_mail

            if assigned_user_pretty_name:
                update_data['assigned_user_pretty_name'] = assigned_user_pretty_name

            if status:
                update_data['status'] = status

            if severity:
                update_data['manual_severity'] = severity

            if resolve_comment:
                update_data['resolve_comment'] = resolve_comment

            request_data = {
                'incident_id': incident_id,
                'update_data': update_data
            }

            self._http_request(
                method='POST',
                url_suffix='/incidents/update_incident/',
                json_data={'request_data': request_data}
            )

        def get_endpoints(self,
                          endpoint_id_list=None,
                          dist_name=None,
                          ip_list=None,
                          group_name=None,
                          platform=None,
                          alias_name=None,
                          isolate=None,
                          hostname=None,
                          page_number=0,
                          limit=20,
                          first_seen_gte=None,
                          first_seen_lte=None,
                          last_seen_gte=None,
                          last_seen_lte=None,
                          sort_by_first_seen=None,
                          sort_by_last_seen=None
                          ):

            search_from = page_number * limit
            search_to = search_from + limit

            request_data = {
                'search_from': search_from,
                'search_to': search_to
            }

            filters = []
            if endpoint_id_list:
                filters.append({
                    'field': 'endpoint_id_list',
                    'operator': 'in',
                    'value': endpoint_id_list
                })

            if dist_name:
                filters.append({
                    'field': 'dist_name',
                    'operator': 'in',
                    'value': dist_name
                })

            if ip_list:
                filters.append({
                    'field': 'ip_list',
                    'operator': 'in',
                    'value': ip_list
                })

            if group_name:
                filters.append({
                    'field': 'group_name',
                    'operator': 'in',
                    'value': group_name
                })

            if platform:
                filters.append({
                    'field': 'platform',
                    'operator': 'in',
                    'value': platform
                })

            if alias_name:
                filters.append({
                    'field': 'alias_name',
                    'operator': 'in',
                    'value': alias_name
                })

            if isolate:
                filters.append({
                    'field': 'isolate',
                    'operator': 'in',
                    'value': [isolate]
                })

            if hostname:
                filters.append({
                    'field': 'hostname',
                    'operator': 'in',
                    'value': hostname
                })

            if first_seen_gte:
                filters.append({
                    'field': 'first_seen',
                    'operator': 'gte',
                    'value': first_seen_gte
                })

            if first_seen_lte:
                filters.append({
                    'field': 'first_seen',
                    'operator': 'lte',
                    'value': first_seen_lte
                })

            if last_seen_gte:
                filters.append({
                    'field': 'last_seen',
                    'operator': 'gte',
                    'value': last_seen_gte
                })

            if last_seen_lte:
                filters.append({
                    'field': 'last_seen',
                    'operator': 'lte',
                    'value': last_seen_lte
                })

            if search_from:
                request_data['search_from'] = search_from

            if search_to:
                request_data['search_to'] = search_to

            if sort_by_first_seen:
                request_data['sort'] = {
                    'field': 'first_seen',
                    'keyword': sort_by_first_seen
                }
            elif sort_by_last_seen:
                request_data['sort'] = {
                    'field': 'last_seen',
                    'keyword': sort_by_last_seen
                }

            request_data['filters'] = filters

            reply = self._http_request(
                method='POST',
                url_suffix='/endpoints/get_endpoint/',
                json_data={'request_data': request_data}
            )

            endpoints = reply.get('reply').get('endpoints', [])
            return endpoints

        def isolate_endpoint(self, endpoint_id):
            self._http_request(
                method='POST',
                url_suffix='/endpoints/isolate',
                json_data={
                    'request_data': {
                        'endpoint_id': endpoint_id
                    }
                }
            )

        def unisolate_endpoint(self, endpoint_id):
            self._http_request(
                method='POST',
                url_suffix='/endpoints/unisolate',
                json_data={
                    'request_data': {
                        'endpoint_id': endpoint_id
                    }
                }
            )

        def insert_alerts(self, alerts):
            self._http_request(
                method='POST',
                url_suffix='/alerts/insert_parsed_alerts/',
                json_data={
                    'request_data': {
                        'alerts': alerts
                    }
                }
            )

        def insert_cef_alerts(self, alerts):
            self._http_request(
                method='POST',
                url_suffix='/alerts/insert_cef_alerts/',
                json_data={
                    'request_data': {
                        'alerts': alerts
                    }
                }
            )

        def get_distribution_url(self, distribution_id, package_type):
            reply = self._http_request(
                method='POST',
                url_suffix='/distributions/get_dist_url/',
                json_data={
                    'request_data': {
                        'distribution_id': distribution_id,
                        'package_type': package_type
                    }
                }
            )

            return reply.get('reply').get('distribution_url')

        def get_distribution_status(self, distribution_id):
            reply = self._http_request(
                method='POST',
                url_suffix='/distributions/get_status/',
                json_data={
                    'request_data': {
                        'distribution_id': distribution_id
                    }
                }
            )

            return reply.get('reply').get('status')

        def get_distribution_versions(self):
            reply = self._http_request(
                method='POST',
                url_suffix='/distributions/get_versions/',
                json_data={}
            )

            return reply.get('reply')

        def create_distribution(self, name, platform, package_type, agent_version, description):
            if package_type == 'standalone':
                request_data = {
                    'name': name,
                    'platform': platform,
                    'package_type': package_type,
                    'agent_version': agent_version,
                    'description': description
                }
            elif package_type == 'upgrade':
                request_data = {
                    'name': name,
                    'package_type': package_type,
                    'description': description
                }

                if platform == 'windows':
                    request_data['windows_version'] = agent_version
                elif platform == 'linux':
                    request_data['linux_version'] = agent_version
                elif platform == 'macos':
                    request_data['macos_version'] = agent_version

            reply = self._http_request(
                method='POST',
                url_suffix='/distributions/create/',
                json_data={
                    'request_data': request_data
                }
            )

            return reply.get('reply').get('distribution_id')

        def audit_management_logs(self, email, result, _type, sub_type, search_from, search_to, timestamp_gte,
                                  timestamp_lte, sort_by, sort_order):

            request_data: Dict[str, Any] = {}
            filters = []
            if email:
                filters.append({
                    'field': 'email',
                    'operator': 'in',
                    'value': email
                })
            if result:
                filters.append({
                    'field': 'result',
                    'operator': 'in',
                    'value': result
                })
            if _type:
                filters.append({
                    'field': 'type',
                    'operator': 'in',
                    'value': _type
                })
            if sub_type:
                filters.append({
                    'field': 'sub_type',
                    'operator': 'in',
                    'value': sub_type
                })
            if timestamp_gte:
                filters.append({
                    'field': 'timestamp',
                    'operator': 'gte',
                    'value': timestamp_gte
                })
            if timestamp_lte:
                filters.append({
                    'field': 'timestamp',
                    'operator': 'lte',
                    'value': timestamp_lte
                })

            if filters:
                request_data['filters'] = filters

            if search_from > 0:
                request_data['search_from'] = search_from

            if search_to:
                request_data['search_to'] = search_to

            if sort_by:
                request_data['sort'] = {
                    'field': sort_by,
                    'keyword': sort_order
                }

            reply = self._http_request(
                method='POST',
                url_suffix='/audits/management_logs/',
                json_data={'request_data': request_data}
            )

            return reply.get('reply').get('data', [])

        def get_audit_agent_reports(self, endpoint_ids, endpoint_names, result, _type, sub_type, search_from, search_to,
                                    timestamp_gte, timestamp_lte, sort_by, sort_order):
            request_data: Dict[str, Any] = {}
            filters = []
            if endpoint_ids:
                filters.append({
                    'field': 'endpoint_id',
                    'operator': 'in',
                    'value': endpoint_ids
                })
            if endpoint_names:
                filters.append({
                    'field': 'endpoint_name',
                    'operator': 'in',
                    'value': endpoint_names
                })
            if result:
                filters.append({
                    'field': 'result',
                    'operator': 'in',
                    'value': result
                })
            if _type:
                filters.append({
                    'field': 'type',
                    'operator': 'in',
                    'value': _type
                })
            if sub_type:
                filters.append({
                    'field': 'sub_type',
                    'operator': 'in',
                    'value': sub_type
                })
            if timestamp_gte:
                filters.append({
                    'field': 'timestamp',
                    'operator': 'gte',
                    'value': timestamp_gte
                })
            if timestamp_lte:
                filters.append({
                    'field': 'timestamp',
                    'operator': 'lte',
                    'value': timestamp_lte
                })

            if filters:
                request_data['filters'] = filters

            if search_from > 0:
                request_data['search_from'] = search_from

            if search_to:
                request_data['search_to'] = search_to

            if sort_by:
                request_data['sort'] = {
                    'field': sort_by,
                    'keyword': sort_order
                }

            reply = self._http_request(
                method='POST',
                url_suffix='/audits/agents_reports/',
                json_data={'request_data': request_data}
            )

            return reply.get('reply').get('data', [])


    def get_incidents_command(client, args):
        """
        Retrieve a list of incidents from XDR, filtered by some filters.
        """

        # sometimes incident id can be passed as integer from the playbook
        incident_id_list = args.get('incident_id_list')
        if isinstance(incident_id_list, int):
            incident_id_list = str(incident_id_list)

        incident_id_list = argToList(incident_id_list)
        # make sure all the ids passed are strings and not integers
        for index, id_ in enumerate(incident_id_list):
            if isinstance(id_, (int, float)):
                incident_id_list[index] = str(id_)

        lte_modification_time = args.get('lte_modification_time')
        gte_modification_time = args.get('gte_modification_time')
        since_modification_time = args.get('since_modification_time')

        if since_modification_time and gte_modification_time:
            raise ValueError('Can\'t set both since_modification_time and lte_modification_time')
        if since_modification_time:
            gte_modification_time, _ = parse_date_range(since_modification_time, TIME_FORMAT)

        lte_creation_time = args.get('lte_creation_time')
        gte_creation_time = args.get('gte_creation_time')
        since_creation_time = args.get('since_creation_time')

        if since_creation_time and gte_creation_time:
            raise ValueError('Can\'t set both since_creation_time and lte_creation_time')
        if since_creation_time:
            gte_creation_time, _ = parse_date_range(since_creation_time, TIME_FORMAT)

        sort_by_modification_time = args.get('sort_by_modification_time')
        sort_by_creation_time = args.get('sort_by_creation_time')

        page = int(args.get('page', 0))
        limit = int(args.get('limit', 100))

        # If no filters were given, return a meaningful error message
        if not incident_id_list and (not lte_modification_time and not gte_modification_time and not since_modification_time
                                     and not lte_creation_time and not gte_creation_time and not since_creation_time):
            raise ValueError("Specify a query for the incidents.\nFor example:"
                             " !xdr-get-incidents since_creation_time=\"1 year\" sort_by_creation_time=\"desc\" limit=10")

        raw_incidents = client.get_incidents(
            incident_id_list=incident_id_list,
            lte_modification_time=lte_modification_time,
            gte_modification_time=gte_modification_time,
            lte_creation_time=lte_creation_time,
            gte_creation_time=gte_creation_time,
            sort_by_creation_time=sort_by_creation_time,
            sort_by_modification_time=sort_by_modification_time,
            page_number=page,
            limit=limit
        )

        return (
            tableToMarkdown('Incidents', raw_incidents),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.Incident(val.incident_id==obj.incident_id)': raw_incidents
            },
            raw_incidents
        )


    def get_incident_extra_data_command(client, args):
        incident_id = args.get('incident_id')
        alerts_limit = int(args.get('alerts_limit', 1000))

        raw_incident = client.get_incident_extra_data(incident_id, alerts_limit)

        incident = raw_incident.get('incident')
        incident_id = incident.get('incident_id')
        raw_alerts = raw_incident.get('alerts').get('data')
        alerts = clear_trailing_whitespace(raw_alerts)
        file_artifacts = raw_incident.get('file_artifacts').get('data')
        network_artifacts = raw_incident.get('network_artifacts').get('data')

        readable_output = [tableToMarkdown('Incident {}'.format(incident_id), incident)]

        if len(alerts) > 0:
            readable_output.append(tableToMarkdown('Alerts', alerts))
        else:
            readable_output.append(tableToMarkdown('Alerts', []))

        if len(network_artifacts) > 0:
            readable_output.append(tableToMarkdown('Network Artifacts', network_artifacts))
        else:
            readable_output.append(tableToMarkdown('Network Artifacts', []))

        if len(file_artifacts) > 0:
            readable_output.append(tableToMarkdown('File Artifacts', file_artifacts))
        else:
            readable_output.append(tableToMarkdown('File Artifacts', []))

        incident.update({
            'alerts': alerts,
            'file_artifacts': file_artifacts,
            'network_artifacts': network_artifacts
        })
        return (
            '\n'.join(readable_output),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.Incident(val.incident_id==obj.incident_id)': incident
            },
            raw_incident
        )


    def update_incident_command(client, args):
        incident_id = args.get('incident_id')
        assigned_user_mail = args.get('assigned_user_mail')
        assigned_user_pretty_name = args.get('assigned_user_pretty_name')
        status = args.get('status')
        severity = args.get('manual_severity')
        unassign_user = args.get('unassign_user') == 'true'
        resolve_comment = args.get('resolve_comment')

        client.update_incident(
            incident_id=incident_id,
            assigned_user_mail=assigned_user_mail,
            assigned_user_pretty_name=assigned_user_pretty_name,
            unassign_user=unassign_user,
            status=status,
            severity=severity,
            resolve_comment=resolve_comment
        )

        return f'Incident {incident_id} has been updated', None, None


    def arg_to_int(arg, arg_name: str, required: bool = False):
        if arg is None:
            if required is True:
                raise ValueError(f'Missing "{arg_name}"')
            return None
        if isinstance(arg, str):
            if arg.isdigit():
                return int(arg)
            raise ValueError(f'Invalid number: "{arg_name}"="{arg}"')
        if isinstance(arg, int):
            return arg
        return ValueError(f'Invalid number: "{arg_name}"')


    def get_endpoints_command(client, args):
        endpoint_id_list = argToList(args.get('endpoint_id_list'))
        dist_name = argToList(args.get('dist_name'))
        ip_list = argToList(args.get('ip_list'))
        group_name = argToList(args.get('group_name'))
        platform = argToList(args.get('platform'))
        alias_name = argToList(args.get('alias_name'))
        isolate = args.get('isolate')
        hostname = argToList(args.get('hostname'))

        first_seen_gte = arg_to_timestamp(
            arg=args.get('first_seen_gte'),
            arg_name='first_seen_gte'
        )

        first_seen_lte = arg_to_timestamp(
            arg=args.get('first_seen_lte'),
            arg_name='first_seen_lte'
        )

        last_seen_gte = arg_to_timestamp(
            arg=args.get('last_seen_gte'),
            arg_name='last_seen_gte'
        )

        last_seen_lte = arg_to_timestamp(
            arg=args.get('last_seen_lte'),
            arg_name='last_seen_lte'
        )

        page_number = arg_to_int(
            arg=args.get('page'),
            arg_name='Failed to parse "page". Must be a number.',
            required=True
        )

        limit = arg_to_int(
            arg=args.get('limit'),
            arg_name='Failed to parse "limit". Must be a number.',
            required=True
        )

        sort_by_first_seen = args.get('sort_by_first_seen')
        sort_by_last_seen = args.get('sort_by_last_seen')

        endpoints = client.get_endpoints(
            endpoint_id_list=endpoint_id_list,
            dist_name=dist_name,
            ip_list=ip_list,
            group_name=group_name,
            platform=platform,
            alias_name=alias_name,
            isolate=isolate,
            hostname=hostname,
            page_number=page_number,
            limit=limit,
            first_seen_gte=first_seen_gte,
            first_seen_lte=first_seen_lte,
            last_seen_gte=last_seen_gte,
            last_seen_lte=last_seen_lte,
            sort_by_first_seen=sort_by_first_seen,
            sort_by_last_seen=sort_by_last_seen
        )

        return (
            tableToMarkdown('Endpoints', endpoints),
            {f'{INTEGRATION_CONTEXT_BRAND}.Endpoint(val.endpoint_id == val.endpoint_id)': endpoints},
            endpoints
        )


    def create_parsed_alert(product, vendor, local_ip, local_port, remote_ip, remote_port, event_timestamp, severity,
                            alert_name, alert_description):
        alert = {
            "product": product,
            "vendor": vendor,
            "local_ip": local_ip,
            "local_port": local_port,
            "remote_ip": remote_ip,
            "remote_port": remote_port,
            "event_timestamp": event_timestamp,
            "severity": severity,
            "alert_name": alert_name,
            "alert_description": alert_description
        }

        return alert


    def insert_parsed_alert_command(client, args):
        product = args.get('product')
        vendor = args.get('vendor')
        local_ip = args.get('local_ip')
        local_port = arg_to_int(
            arg=args.get('local_port'),
            arg_name='local_port'
        )
        remote_ip = args.get('remote_ip')
        remote_port = arg_to_int(
            arg=args.get('remote_port'),
            arg_name='remote_port'
        )

        severity = args.get('severity')
        alert_name = args.get('alert_name')
        alert_description = args.get('alert_description', '')

        if args.get('event_timestamp') is None:
            # get timestamp now if not provided
            event_timestamp = int(round(time.time() * 1000))
        else:
            event_timestamp = int(args.get('event_timestamp'))

        alert = create_parsed_alert(
            product=product,
            vendor=vendor,
            local_ip=local_ip,
            local_port=local_port,
            remote_ip=remote_ip,
            remote_port=remote_port,
            event_timestamp=event_timestamp,
            severity=severity,
            alert_name=alert_name,
            alert_description=alert_description
        )

        client.insert_alerts([alert])

        return (
            'Alert inserted successfully',
            None,
            None
        )


    def insert_cef_alerts_command(client, args):
        # parsing alerts list. the reason we don't use argToList is because cef_alerts could contain comma (,) so
        # we shouldn't split them by comma
        alerts = args.get('cef_alerts')
        if isinstance(alerts, list):
            pass
        elif isinstance(alerts, str):
            if alerts[0] == '[' and alerts[-1] == ']':
                # if the string contains [] it means it is a list and must be parsed
                alerts = json.loads(alerts)
            else:
                # otherwise it is a single alert
                alerts = [alerts]
        else:
            raise ValueError('Invalid argument "cef_alerts". It should be either list of strings (cef alerts), '
                             'or single string')

        client.insert_cef_alerts(alerts)

        return (
            'Alerts inserted successfully',
            None,
            None
        )


    def isolate_endpoint_command(client, args):
        endpoint_id = args.get('endpoint_id')

        endpoint = client.get_endpoints(endpoint_id_list=[endpoint_id])
        if len(endpoint) == 0:
            raise ValueError(f'Endpoint {endpoint_id} was not found')

        endpoint = endpoint[0]
        is_isolated = endpoint.get('is_isolated')
        if is_isolated == 'AGENT_ISOLATED':
            return (
                f'Endpoint {endpoint_id} already isolated',
                None,
                None
            )

        client.isolate_endpoint(endpoint_id)

        return (
            f'Endpoint {endpoint_id} has isolated successfully',
            None,
            None
        )


    def unisolate_endpoint_command(client, args):
        endpoint_id = args.get('endpoint_id')

        endpoint = client.get_endpoints(endpoint_id_list=[endpoint_id])
        if len(endpoint) == 0:
            raise ValueError(f'Endpoint {endpoint_id} was not found')

        endpoint = endpoint[0]
        is_isolated = endpoint.get('is_isolated')
        if is_isolated == 'AGENT_UNISOLATED':
            return (
                f'Endpoint {endpoint_id} already unisolated',
                None,
                None
            )

        client.unisolate_endpoint(endpoint_id)

        return (
            f'Endpoint {endpoint_id} has un-isolated successfully',
            None,
            None
        )


    def arg_to_timestamp(arg, arg_name: str, required: bool = False):
        if arg is None:
            if required is True:
                raise ValueError(f'Missing "{arg_name}"')
            return None

        if isinstance(arg, str) and arg.isdigit():
            # timestamp that str - we just convert it to int
            return int(arg)
        if isinstance(arg, str):
            # if the arg is string of date format 2019-10-23T00:00:00 or "3 days", etc
            date = dateparser.parse(arg, settings={'TIMEZONE': 'UTC'})
            if date is None:
                # if d is None it means dateparser failed to parse it
                raise ValueError(f'Invalid date: {arg_name}')

            return int(date.timestamp() * 1000)
        if isinstance(arg, (int, float)):
            return arg


    def get_audit_management_logs_command(client, args):
        email = argToList(args.get('email'))
        result = argToList(args.get('result'))
        _type = argToList(args.get('type'))
        sub_type = argToList(args.get('sub_type'))

        timestamp_gte = arg_to_timestamp(
            arg=args.get('timestamp_gte'),
            arg_name='timestamp_gte'
        )

        timestamp_lte = arg_to_timestamp(
            arg=args.get('timestamp_lte'),
            arg_name='timestamp_lte'
        )

        page_number = arg_to_int(
            arg=args.get('page', 0),
            arg_name='Failed to parse "page". Must be a number.',
            required=True
        )
        limit = arg_to_int(
            arg=args.get('limit', 20),
            arg_name='Failed to parse "limit". Must be a number.',
            required=True
        )
        search_from = page_number * limit
        search_to = search_from + limit

        sort_by = args.get('sort_by')
        sort_order = args.get('sort_order', 'asc')

        audit_logs = client.audit_management_logs(
            email=email,
            result=result,
            _type=_type,
            sub_type=sub_type,
            timestamp_gte=timestamp_gte,
            timestamp_lte=timestamp_lte,
            search_from=search_from,
            search_to=search_to,
            sort_by=sort_by,
            sort_order=sort_order
        )

        return (
            tableToMarkdown('Audit Management Logs', audit_logs, [
                'AUDIT_ID',
                'AUDIT_RESULT',
                'AUDIT_DESCRIPTION',
                'AUDIT_OWNER_NAME',
                'AUDIT_OWNER_EMAIL',
                'AUDIT_ASSET_JSON',
                'AUDIT_ASSET_NAMES',
                'AUDIT_HOSTNAME',
                'AUDIT_REASON',
                'AUDIT_ENTITY',
                'AUDIT_ENTITY_SUBTYPE',
                'AUDIT_SESSION_ID',
                'AUDIT_CASE_ID',
                'AUDIT_INSERT_TIME'
            ]),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.AuditManagementLogs(val.AUDIT_ID == obj.AUDIT_ID)': audit_logs
            },
            audit_logs
        )


    def get_audit_agent_reports_command(client, args):
        endpoint_ids = argToList(args.get('endpoint_ids'))
        endpoint_names = argToList(args.get('endpoint_names'))
        result = argToList(args.get('result'))
        _type = argToList(args.get('type'))
        sub_type = argToList(args.get('sub_type'))

        timestamp_gte = arg_to_timestamp(
            arg=args.get('timestamp_gte'),
            arg_name='timestamp_gte'
        )

        timestamp_lte = arg_to_timestamp(
            arg=args.get('timestamp_lte'),
            arg_name='timestamp_lte'
        )

        page_number = arg_to_int(
            arg=args.get('page', 0),
            arg_name='Failed to parse "page". Must be a number.',
            required=True
        )
        limit = arg_to_int(
            arg=args.get('limit', 20),
            arg_name='Failed to parse "limit". Must be a number.',
            required=True
        )
        search_from = page_number * limit
        search_to = search_from + limit

        sort_by = args.get('sort_by')
        sort_order = args.get('sort_order', 'asc')

        audit_logs = client.get_audit_agent_reports(
            endpoint_ids=endpoint_ids,
            endpoint_names=endpoint_names,
            result=result,
            _type=_type,
            sub_type=sub_type,
            timestamp_gte=timestamp_gte,
            timestamp_lte=timestamp_lte,

            search_from=search_from,
            search_to=search_to,
            sort_by=sort_by,
            sort_order=sort_order
        )

        return (
            tableToMarkdown('Audit Agent Reports', audit_logs),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.AuditAgentReports': audit_logs
            },
            audit_logs
        )


    def get_distribution_url_command(client, args):
        distribution_id = args.get('distribution_id')
        package_type = args.get('package_type')

        url = client.get_distribution_url(distribution_id, package_type)

        return (
            f'[Distribution URL]({url})',
            {
                'PaloAltoNetworksXDR.Distribution(val.id == obj.id)': {
                    'id': distribution_id,
                    'url': url
                }
            },
            url
        )


    def get_distribution_status_command(client, args):
        distribution_ids = argToList(args.get('distribution_ids'))

        distribution_list = []
        for distribution_id in distribution_ids:
            status = client.get_distribution_status(distribution_id)

            distribution_list.append({
                'id': distribution_id,
                'status': status
            })

        return (
            tableToMarkdown('Distribution Status', distribution_list, ['id', 'status']),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.Distribution(val.id == obj.id)': distribution_list
            },
            distribution_list
        )


    def get_distribution_versions_command(client):
        versions = client.get_distribution_versions()

        readable_output = []
        for operation_system in versions.keys():
            os_versions = versions[operation_system]

            readable_output.append(
                tableToMarkdown(operation_system, os_versions or [], ['versions'])
            )

        return (
            '\n\n'.join(readable_output),
            {
                f'{INTEGRATION_CONTEXT_BRAND}.DistributionVersions': versions
            },
            versions
        )


    def create_distribution_command(client, args):
        name = args.get('name')
        platform = args.get('platform')
        package_type = args.get('package_type')
        description = args.get('description')
        agent_version = args.get('agent_version')
        if not platform == 'android' and not agent_version:
            # agent_version must be provided for all the platforms except android
            raise ValueError(f'Missing argument "agent_version" for platform "{platform}"')

        distribution_id = client.create_distribution(
            name=name,
            platform=platform,
            package_type=package_type,
            agent_version=agent_version,
            description=description
        )

        distribution = {
            'id': distribution_id,
            'name': name,
            'platform': platform,
            'package_type': package_type,
            'agent_version': agent_version,
            'description': description
        }

        return (
            f'Distribution {distribution_id} created successfully',
            {
                f'{INTEGRATION_CONTEXT_BRAND}.Distribution(val.id == obj.id)': distribution
            },
            distribution
        )


    def fetch_incidents(client, first_fetch_time, last_run: dict = None):
        # Get the last fetch time, if exists
        last_fetch = last_run.get('time') if isinstance(last_run, dict) else None

        # Handle first time fetch, fetch incidents retroactively
        if last_fetch is None:
            last_fetch, _ = parse_date_range(first_fetch_time, to_timestamp=True)

        incidents = []
        raw_incidents = client.get_incidents(gte_creation_time_milliseconds=last_fetch,
                                             limit=50, sort_by_creation_time='asc')

        for raw_incident in raw_incidents:
            incident_id = raw_incident.get('incident_id')
            description = raw_incident.get('description')
            occurred = timestamp_to_datestring(raw_incident['creation_time'], TIME_FORMAT + 'Z')
            incident = {
                'name': f'#{incident_id} - {description}',
                'occurred': occurred,
                'rawJSON': json.dumps(raw_incident)
            }

            # Update last run and add incident if the incident is newer than last fetch
            if raw_incident['creation_time'] > last_fetch:
                last_fetch = raw_incident['creation_time']

            incidents.append(incident)

        next_run = {'time': last_fetch + 1}
        return next_run, incidents


    def main():
        """
        Executes an integration command
        """
        LOG(f'Command being called is {demisto.command()}')

        api_key = demisto.params().get('apikey')
        api_key_id = demisto.params().get('apikey_id')
        first_fetch_time = demisto.params().get('fetch_time', '3 days')
        base_url = urljoin(demisto.params().get('url'), '/public_api/v1')
        proxy = demisto.params().get('proxy')
        verify_cert = not demisto.params().get('insecure', False)

        # nonce, timestamp, auth = create_auth(API_KEY)
        nonce = "".join([secrets.choice(string.ascii_letters + string.digits) for _ in range(64)])
        timestamp = str(int(datetime.now(timezone.utc).timestamp()) * 1000)
        auth_key = "%s%s%s" % (api_key, nonce, timestamp)
        auth_key = auth_key.encode("utf-8")
        api_key_hash = hashlib.sha256(auth_key).hexdigest()

        headers = {
            "x-xdr-timestamp": timestamp,
            "x-xdr-nonce": nonce,
            "x-xdr-auth-id": str(api_key_id),
            "Authorization": api_key_hash
        }

        client = Client(
            base_url=base_url,
            proxy=proxy,
            verify=verify_cert,
            headers=headers
        )

        try:
            if demisto.command() == 'test-module':
                client.test_module(first_fetch_time)
                demisto.results('ok')

            elif demisto.command() == 'fetch-incidents':
                next_run, incidents = fetch_incidents(client, first_fetch_time, demisto.getLastRun())
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)

            elif demisto.command() == 'xdr-get-incidents':
                return_outputs(*get_incidents_command(client, demisto.args()))

            elif demisto.command() == 'xdr-get-incident-extra-data':
                return_outputs(*get_incident_extra_data_command(client, demisto.args()))

            elif demisto.command() == 'xdr-update-incident':
                return_outputs(*update_incident_command(client, demisto.args()))

            elif demisto.command() == 'xdr-get-endpoints':
                return_outputs(*get_endpoints_command(client, demisto.args()))

            elif demisto.command() == 'xdr-insert-parsed-alert':
                return_outputs(*insert_parsed_alert_command(client, demisto.args()))

            elif demisto.command() == 'xdr-insert-cef-alerts':
                return_outputs(*insert_cef_alerts_command(client, demisto.args()))

            elif demisto.command() == 'xdr-isolate-endpoint':
                return_outputs(*isolate_endpoint_command(client, demisto.args()))

            elif demisto.command() == 'xdr-unisolate-endpoint':
                return_outputs(*unisolate_endpoint_command(client, demisto.args()))

            elif demisto.command() == 'xdr-get-distribution-url':
                return_outputs(*get_distribution_url_command(client, demisto.args()))

            elif demisto.command() == 'xdr-get-create-distribution-status':
                return_outputs(*get_distribution_status_command(client, demisto.args()))

            elif demisto.command() == 'xdr-get-distribution-versions':
                return_outputs(*get_distribution_versions_command(client))

            elif demisto.command() == 'xdr-create-distribution':
                return_outputs(*create_distribution_command(client, demisto.args()))

            elif demisto.command() == 'xdr-get-audit-management-logs':
                return_outputs(*get_audit_management_logs_command(client, demisto.args()))

            elif demisto.command() == 'xdr-get-audit-agent-reports':
                return_outputs(*get_audit_agent_reports_command(client, demisto.args()))

        except Exception as err:
            if demisto.command() == 'fetch-incidents':
                LOG(str(err))
                raise
            demisto.error()
            return_error(str(err))


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
system: true
